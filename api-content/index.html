{"posts":[{"title":"WFLS 谔谔赛 Day 2 题解","content":" T1 Hack him 对于三个子任务和自然数 kkk，一种通用的构造如下：（其中 2high2^{high}2high 为一个大于 kkk 的二的整数次幂） Bitwise−and:Bitwise-and:Bitwise−and: (2high+kk2high2high+k2highk)\\begin{pmatrix}2^{high}+k &amp; k\\\\ 2^{high} &amp; 2^{high}+k\\\\2^{high} &amp; k\\end{pmatrix} ⎝⎛​2high+k2high2high​k2high+kk​⎠⎞​ 容易验证假 DP 的答案为 000，正确答案为 kkk。 Bitwise−or:Bitwise-or:Bitwise−or: (0k2high02high2high)\\begin{pmatrix}0&amp;k\\\\2^{high}&amp;0\\\\2^{high}&amp;2^{high}\\end{pmatrix} ⎝⎛​02high2high​k02high​⎠⎞​ 容易验证假 DP 的答案为 2high2^{high}2high，正确答案为 2high+k2^{high} +k2high+k。 Bitwise−xor:Bitwise-xor:Bitwise−xor: (kkk0kk)\\begin{pmatrix}k&amp;k&amp;k\\\\0&amp;k&amp;k\\end{pmatrix} (k0​kk​kk​) 容易验证假 DP 的答案为 000 ,正确答案为 kkk。 这是一道典型 CF 风格的题目（初看完全没有思路，想到正解就很简单）。事实上，这是 CF1332D 的一个扩展。对于信息极少的构造题，从简单情况出发往往是好的办法（而不是尝试构造 100×100100 \\times 100100×100 之类的矩阵）。 emmmm……代码……还要贴吗？…… #include&lt;bits/stdc++.h&gt; signed main() { int k; scanf(&quot;%d&quot;,&amp;k); printf(&quot;2 3\\n%d 512 512\\n%d %d %d\\n&quot;,512+k,k,512+k,k); printf(&quot;2 3\\n0 512 512\\n%d 0 512\\n&quot;,k); printf(&quot;2 3\\n%d %d %d\\n0 %d %d\\n&quot;,k,k,k,k,k); return 0; } T2 Delete 题意：维护给定的数列 {a1,a2,a3,⋯ .an}\\{a_1,a_2,a_3,\\cdots.a_n\\}{a1​,a2​,a3​,⋯.an​}，支持单点修改、区间取 ϕ\\phiϕ（欧拉函数）、区间查询异或和。 这题算是一个很经典的 均摊复杂度 的数据结构题，部分分给的很多，也挺好骗分的。下面主要说正解。 前置知识：线性筛（以及线性递推欧拉函数）、树状数组 + STL 容器（std::set）的使用（线段树也可以）。 我们先看到欧拉函数的 两个很重要的性质：ϕ(2n)≤n, 2∣ϕ(2n+1)\\phi(2n) \\le n,\\ 2|\\phi(2n+1)ϕ(2n)≤n, 2∣ϕ(2n+1)。很容易看出来对于偶数 2n2n2n，所有偶数都与其不互质，所以必有 ϕ(2n)≤n\\phi(2n) \\le nϕ(2n)≤n；对于奇数 2n+12n+12n+1，根据欧拉函数的通式 ϕ(x)=x∏i=1n(1−1pi)\\phi(x)=x\\prod_{i=1}^n\\left(1-\\frac{1}{p_i}\\right)ϕ(x)=x∏i=1n​(1−pi​1​)，也可以看出来 ϕ(2n=1)\\phi(2n=1)ϕ(2n=1) 为偶数。基于这两个性质，我们可以得到一个非常优秀的结论：对于一个数 nnn，在不超过 2⌈log⁡2(n)⌉2\\left\\lceil\\log_2(n)\\right\\rceil2⌈log2​(n)⌉ 次取 ϕ\\phiϕ 后会变成 111。 而可以发现，单点修改是不影响渐进时间复杂度的（只不过多了个 222 的常数）。因此，我们只需要暴力取 ϕ\\phiϕ、暴力单点修改，并维护一下当前哪些位置不是 111 就好了（可以使用线段树或 std::set 维护这个东西）。由于需要查询区间异或和，所以我们还需要维护一个支持单点修改、区间求异或和的数据结构（也可以使用线段树或树状数组时限）。 既然往年提高组没有一题正解是线段树，那我标程就给个 树状数组 + std::set 的实现吧…… #include&lt;bits/stdc++.h&gt; #define rgi register int const int maxn=123460; int a[maxn]; std::set&lt;int&gt; s; int pr[maxn],cntp,phi[maxn]; bool isnp[maxn]; inline void init() { phi[1]=1; for(rgi i=2;i&lt;maxn;++i) { if(!isnp[i]) pr[++cntp]=i,phi[i]=i-1; for(rgi j=1;j&lt;=cntp&amp;&amp;i*pr[j]&lt;maxn;++j) { isnp[i*pr[j]]=1; if(i%pr[j]) phi[i*pr[j]]=phi[i]*phi[pr[j]]; else {phi[i*pr[j]]=phi[i]*pr[j]; break;} } } } class BIT{ private: int size,val[maxn]; public: inline int lowbit(int x) {return x&amp;-x;} inline void update(int p,int v) {while(p&lt;=size) val[p]^=v,p+=lowbit(p);} inline int query(int p) {int res=0; while(p&gt;0) res^=val[p],p-=lowbit(p); return res;} inline int query(int l,int r) {return query(r)^query(l-1);} inline void build(int s) {size=s,memset(val,0,sizeof(int)*(s+1));} }bit; inline void modify(int x,int y) { bit.update(x,a[x]^y),a[x]=y; if(a[x]&gt;1) s.insert(x); else s.erase(x); } signed main() { rgi n,m,op,x,y; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(),bit.build(n),s.insert(maxn); for(rgi i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;x),modify(i,x); while(m--) { scanf(&quot;%d%d%d&quot;,&amp;op,&amp;x,&amp;y); if(op==1) { for(std::set&lt;int&gt;::iterator it=s.lower_bound(x),tmp;*it&lt;=y;) tmp=it,++it,modify(*tmp,phi[a[*tmp]]); } else if(op==2) modify(x,y); else printf(&quot;%d\\n&quot;,bit.query(x,y)); } return 0; } 当然，线段树的解法也给大家一份啦。（下为 Clever_Jimmy\\textsf{C}\\color{red}\\textsf{lever\\_Jimmy}Clever_Jimmy 的代码） #include &lt;bits/stdc++.h&gt; #define LL long long const int N = 123460; int n, m, a[N]; int cnt, f[N], phi[N], pr[N]; struct SEGTREE { static const int MS = N * 4; int lc[MS], rc[MS], dat[MS], max_val[MS], tag[MS]; void pushup(int p) { dat[p] = dat[p &lt;&lt; 1] ^ dat[p &lt;&lt; 1 | 1]; max_val[p] = std::max(max_val[p &lt;&lt; 1], max_val[p &lt;&lt; 1 | 1]); } void build(int p, int l, int r) { lc[p] = l, rc[p] = r; if(l == r) { dat[p] = max_val[p] = a[l]; return; } int mid = l + r &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r); pushup(p); } void modify(int p, int x, int v) { if(lc[p] == rc[p]) { dat[p] = max_val[p] = v; return; } int mid = lc[p] + rc[p] &gt;&gt; 1; if(x &lt;= mid) modify(p &lt;&lt; 1, x, v); else modify(p &lt;&lt; 1 | 1, x, v); pushup(p); } void modiphi(int p, int l, int r) { if(lc[p] == rc[p]) { dat[p] = phi[dat[p]]; max_val[p] = phi[max_val[p]]; return; } int mid = lc[p] + rc[p] &gt;&gt; 1; if(l &lt;= mid &amp;&amp; max_val[p &lt;&lt; 1] &gt; 1) modiphi(p &lt;&lt; 1, l, r); if(mid &lt; r &amp;&amp; max_val[p &lt;&lt; 1 | 1] &gt; 1) modiphi(p &lt;&lt; 1 | 1, l, r); pushup(p); } int query(int p, int l, int r) { if(l &lt;= lc[p] &amp;&amp; rc[p] &lt;= r) return dat[p]; int mid = lc[p] + rc[p] &gt;&gt; 1, res = 0; if(l &lt;= mid) res ^= query(p &lt;&lt; 1, l, r); if(r &gt; mid) res ^= query(p &lt;&lt; 1 | 1, l, r); return res; } } t; void eulerSieve() { phi[1] = 1; for(int i = 2; i &lt; N; ++i){ if(!f[i]) phi[pr[++cnt] = i] = i - 1; for(int j = 1, k; j &lt;= cnt &amp;&amp; (k = i * pr[j]) &lt; N; ++j){ f[k] = 1; if(i % pr[j]) phi[k] = phi[i] * (pr[j] - 1); else { phi[k] = phi[i] * pr[j]; break; } } } } int main() { eulerSieve(); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); t.build(1, 1, n); for(int i = 1; i &lt;= m; ++i) { int opt, x, y; scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;x, &amp;y); if(opt == 1) t.modiphi(1, x, y); else if(opt == 2) t.modify(1, x, y); else printf(&quot;%d\\n&quot;, t.query(1, x, y)); } return 0; } T3 Matrix 此题有一定的思维难度，代码非常简单。 对于 01-05 的数据，采取暴力搜索的方式解决，这里不再赘述。 对于 06-09 的数据，可以推得 ab=0ab=0ab=0 ，也就是 nnn 与 mmm 其中一维是不可被染色的，这样我们只需要关注其中一维。不妨来看只有 a=0a=0a=0 的情况。 在 mmm 行中，每一行可以从 000 填到 nnn，共 n+1n+1n+1 种方法，故答案为 (n+1)m(n+1)^m(n+1)m。b=0b=0b=0 的情况同理。注意对 a=0 and b=0a=0\\ and\\ b=0a=0 and b=0 进行特判。 对于 10 ~ 15 的数据，注意到由于 ∣a∣≠∣b∣|a| \\ne |b|∣a∣​=∣b∣，任意两种方法在一个格子处不可能出现相同的情况，所以所有的方法不可能重复。答案即为 (n+1)m(m+1)n(n+1)^m(m+1)^n(n+1)m(m+1)n。 对于 16 ~ 25 的数据，考虑状压 dp 的做法。首先把 ∣a∣≠∣b∣|a| \\ne |b|∣a∣​=∣b∣ 给判掉，剩下的只会有 ∣a∣=∣b∣|a| = |b|∣a∣=∣b∣ 的情况。当 a=−ba=-ba=−b 时，每个格子的最终结果只可能为 0,a,−a0,a,-a0,a,−a，同理，当 a=ba=ba=b 时，每个格子的最终结果只可能为 0,a,2a0,a,2a0,a,2a。此时状压维护此行的数字状态和此行连续横填的个数，可以做到 O(n2m2⋅3min(n,m))\\mathcal{O}(n^2m^2\\cdot3^{min(n,m)})O(n2m2⋅3min(n,m)) 的复杂度。 对于 26 ~ 32 的数据，出题人并没有想出什么优秀的算法。骗分能力极强的各位应该能拿到分的吧。 对于 33 ~ 40 的数据，首先把 ∣a∣≠∣b∣|a| \\ne |b|∣a∣​=∣b∣ 给判掉，我们考虑何时才会出现相同的盘面。这里以 a=b=1a=b=1a=b=1 举例。 显然，只有在上图所示，即行列染色情况呈这种 &quot;L&quot; 形，才会在这一格出现相同情况。做到这里，这题就解决了一半。 这里我们考虑使用容斥原理来计算最后答案。令 fif_ifi​ 表示：图中已经包含 iii 个 &quot;L&quot; 形后，其他格子瞎填的方案数，答案即为 f0−f1+f2−f3+f4−f5...f_0-f_1+f_2-f_3+f_4-f_5...f0​−f1​+f2​−f3​+f4​−f5​... 。如何求得 fif_ifi​ 呢？ 所以： fi=Cni×Cmi×i!×(m+1)n−i×(n+1)m−if_i=C_n^i\\times C_m^i \\times i! \\times(m+1)^{n-i} \\times (n+1)^{m-i} fi​=Cni​×Cmi​×i!×(m+1)n−i×(n+1)m−i 所以： ans=∑i=0min⁡(n,m)(−1)i×Cni×Cmi×i!×(m+1)n−i×(n+1)m−ians = \\sum_{i=0}^{\\min(n,m)} (-1)^i\\times C_n^i\\times C_m^i \\times i!\\times(m+1)^{n-i}\\times(n+1)^{m-i} ans=i=0∑min(n,m)​(−1)i×Cni​×Cmi​×i!×(m+1)n−i×(n+1)m−i 暴力求每一个 fif_ifi​，可以做到 O(n⋅logn)\\mathcal{O}(n\\cdot logn)O(n⋅logn) 的复杂度。 正解：在此基础上，我们发现每一个都是可以线性递推的。 求 i!,(m+1)n−i,(n+1)m−ii!,(m+1)^{n-i},(n+1)^{m-i}i!,(m+1)n−i,(n+1)m−i 比较简单， 不再赘述。 对于 Cni,CmiC_n^i,C_m^iCni​,Cmi​，以 CniC_n^iCni​ 为例，有： Cni=n!i!(n−i)!=(n−i+1)⋅n!i⋅(i−1)!⋅(n−i+1)!=n−i+1i Cni−1C_n^i=\\frac{n!}{i!(n-i)!}=\\frac{(n-i+1)\\cdot n!}{i\\cdot (i-1)!\\cdot (n-i+1)!}=\\frac{n-i+1}{i}\\ C_n^{i-1} Cni​=i!(n−i)!n!​=i⋅(i−1)!⋅(n−i+1)!(n−i+1)⋅n!​=in−i+1​ Cni−1​ 逆元可以线性递推，CniC_n^iCni​ 的递推也就变成了线性。这样整体的复杂度做到了 O(n)\\mathcal{O}(n)O(n)。 代码如下： #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long namespace IO { #define _CCF_ 1024 #define getchar() (_Ip1==_Ip2&amp;&amp;(_Ip2=(_Ip1=_I)+fread(_I,1,_CCF_,stdin),_Ip1==_Ip2)?EOF:*_Ip1++) #define putchar(c) (_Op-_O&lt;_CCF_)?(*_Op++=c):(fwrite(_O,_Op-_O,1,stdout),_Op=_O,*_Op++=c) char _I[_CCF_],*_Ip1=_I,*_Ip2=_I,_O[_CCF_],*_Op=_O; int _f,_ch,_On[32],_Oh; long long _k; template&lt;typename _T&gt; inline void read(_T&amp;_x){ _x=_f=_ch=0; while(!isdigit(_ch)) _f|=(_ch=='-'),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^'0'),_ch=getchar(); _f&amp;&amp;(_x=-_x);} template&lt;typename _T&gt; inline void write(_T _x){ if(_x==0) return putchar('0'),void(); if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,_On[++_Oh]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^'0',_x=_k; while(_Oh&gt;0) putchar(_On[_Oh]),--_Oh;} inline void _Exit0() {fwrite(_O,_Op-_O,1,stdout),exit(0);} } using namespace IO; const int maxn=5000004,mod=998244853; int inv[maxn]; inline int powm(ll a,int b) {ll k=1; while(b&gt;0) {if(b&amp;1) (k*=a)%=mod; (a*=a)%=mod,b&gt;&gt;=1;} return k;} inline int calc(int n,int m) { if(n&gt;m) std::swap(n,m); ll res=0,fact=1,bn=1,bm=1,pn=powm(n+1,m),pm=powm(m+1,n); for(rgi i=0;i&lt;=n;++i) { (res+=((i&amp;1)?(mod-1ll):1ll)*fact%mod*bn%mod*bm%mod*pn%mod*pm)%=mod; (bn*=(ll)(n-i)*inv[i+1]%mod)%=mod,(bm*=(ll)(m-i)*inv[i+1]%mod)%=mod; (pn*=inv[n+1])%=mod,(pm*=inv[m+1])%=mod; (fact*=i+1)%=mod; } return res; } signed main() { rgi T,n,m,a,b; read(T); inv[1]=1; for(rgi i=2;i&lt;maxn;++i) inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod; while(T--) { read(n),read(m),read(a),read(b); if(a!=0&amp;&amp;(a==b||a==-b)) write(calc(n,m)); else write((ll)(a?powm(m+1,n):1)*(b?powm(n+1,m):1)%mod); putchar('\\n'); } _Exit0(); } P.S. xiong_6 的图有点丑我会修的（ ","link":"https://imzzy1201.github.io/post/6sKk2z2zD/"},{"title":"笔记 - AC 自动机","content":" 本文比较随意地讲解了一下 AC 自动机极其 fail 树的建构以及应用；可能不太严谨，但追求通俗易懂。 建议自学一下 trie 树，然后看一下 我的 KMP 博客，也许就能毫不费力地看懂这篇 AC 自动机的学习笔记。 写在前面 为了更方便地描述字符串相关内容，我们做出以下规定： 字符串通常用 S,TS, TS,T 等表示，ccc 通常表示一个字符，Σ\\SigmaΣ 表示字符集； 字符串长度用 ∣S∣\\left|S\\right|∣S∣ 表示； 字符集大小用 ∣Σ∣\\left|\\Sigma\\right|∣Σ∣ 表示； S[l..r]S[l..r]S[l..r] 表示 S[l],S[l+1],…,S[r−1],S[r]S[l], S[l + 1], \\ldots, S[r - 1], S[r]S[l],S[l+1],…,S[r−1],S[r]； 空串用 ϵ\\epsilonϵ 表示； 由 S1,S2,⋯ ,SnS_1, S_2, \\cdots, S_nS1​,S2​,⋯,Sn​ 构成的 trie 树，用 trie(S1,S2,⋯ ,Sn)\\textrm{trie}(S_1, S_2, \\cdots, S_n)trie(S1​,S2​,⋯,Sn​) 表示； 字典树中从根沿着边走到 iii 节点所形成的的字符串，用 str(i)\\textrm{str}(i)str(i) 表示。 特殊地，本文的字符串下标 从 111 开始，trie 树的 根节点编号为 000。 一些例子：对于 S=ABCBADS = \\mathtt{ABCBAD}S=ABCBAD 而言： ∣S∣=6\\left|S\\right| = 6∣S∣=6； ∣Σ∣=4\\left|\\Sigma\\right| = 4∣Σ∣=4； S[2..4]=BCBAS[2..4] = \\mathtt{BCBA}S[2..4]=BCBA； 定义 笼统地讲，AC 自动机实际上是一个 trie 图 加上很多的 fail 指针形成的结构。 AC 自动机中的 fail 指针就如同 KMP 算法的 π\\piπ 数组； 但不同的是 fail 指针能在多个模式串上迭代，而 π\\piπ 数组只能在单一的模式串上迭代。 注意到我的描述为「是一个 trie 图」，因为 AC 自动机实际上把所有 非法状态 都连向了沿着 fail 指针走后的 合法状态； 而这样就形成了一个图而不是单纯的一棵树。 也许你并不能理解上一句话，不过不要紧，我们先从「基于 trie 树结构的 AC 自动机」的结构开始说起。 对于一个模式串为 S1,S2,⋯ ,SnS_1, S_2, \\cdots, S_nS1​,S2​,⋯,Sn​ 基于 trie 树结构的 AC 自动机而言，有： ch[u,c]\\textrm{ch}[u, c]ch[u,c] 数组。 指向的是 uuu 节点，往后拓展一个字符 ccc 之后到达的节点。 fail[u]\\text{fail}[u]fail[u] 数组。 fail[u]\\textrm{fail}[u]fail[u] 自 uuu 开始，指向 trie(S1,S2,⋯ ,Sn)\\textrm{trie}(S_1, S_2, \\cdots, S_n)trie(S1​,S2​,⋯,Sn​) 中的最长的，前缀与 str(u)\\textrm{str}(u)str(u) 的真后缀相等的节点。 如下图所示，555 号节点的 fail 指针指向的是 222 号节点，因为 str(5)=bab,str(2)=ab\\textrm{str}(5) = \\mathtt{bab}, \\textrm{str}(2) = \\mathtt{ab}str(5)=bab,str(2)=ab； ab\\mathtt{ab}ab 是这棵 trie 树中最长的满足前缀（ab\\mathtt{ab}ab）与 str(5)\\textrm{str}(5)str(5) 的某一真后缀（str(5)[2..3]=ab\\textrm{str}(5)[2..3] = \\mathtt{ab}str(5)[2..3]=ab）相等的节点。 算法流程 一个 AC 自动机的建立以及使用包括三个流程：「trie 树的构建」、「fail 指针的连接，以及」和「对一个文本串进行匹配」。 trie 树的构建 刚才我们在 定义 中提到了「基于 trie 树的 AC 自动机」的结构， 而「trie 树转化为 trie 图」的过程是在连接 fail 指针的时候进行的。 给定一些模式串 S1,S2,⋯ ,SnS_1, S_2, \\cdots, S_nS1​,S2​,⋯,Sn​，让你构建出 trie(S1,S2,⋯ ,Sn)\\textrm{trie}(S_1, S_2, \\cdots, S_n)trie(S1​,S2​,⋯,Sn​)。 若不会构建 trie 树，建议先学习 trie 树之后再来看这篇文章。 void insert(std::string S, int id) { int len = S.size(), u = 0; for(int i = 0; i &lt; len; ++i) { int &amp;v = ch[u][S[i] - 'a' + 1]; if(!v) v = ++cntNode; u = v; } } fail 指针的连接 首先，我们把 000 和 000 的所有儿子节点的 fail 指针都设为 000（即根节点）。 然后我们通过 BFS 来实现每个节点的 fail 指针的连接以及将 trie 树转化为 trie 图的过程。 为什么通过 BFS 呢？ 注意到，fail[u]\\textrm{fail}[u]fail[u] 在 trie 树上的深度一定是小于等于 uuu 在 trie 树上的深度的，因此我们可以使用 BFS 来构建。 怎么构建呢？trie 树为啥变成 trie 图了呢？ 考虑 fail 指针的意义，表示最长的前缀等于当前节点的真后缀的节点，我们尝试着往后拓展一个字符 ccc； 如果存在着 ch[fail[u],c]\\textrm{ch}[\\textrm{fail}[u], c]ch[fail[u],c] ，那么很显然 fail[ch[u,c]]←ch[fail[u],c]\\textrm{fail}[\\textrm{ch}[u, c]] \\gets \\textrm{ch}[\\textrm{fail}[u], c]fail[ch[u,c]]←ch[fail[u],c]，然后我们将 ch[u,c]\\textrm{ch}[u, c]ch[u,c] 放进队列里等候着 BFS； 如果不存在呢？那么这个节点对应着的其实是一个 非法状态，我们应该沿着 fail 指针跳至某一个合法状态。 为了简便，我们 直接将这些非法状态等价到 fail 指针指向的节点！ 不难发现，这样 trie 树就变成了一棵 trie 图（每个节点除了指向父亲，还有指向深度小于等于自身的节点的出边）。 void build() { std::queue &lt;int&gt; q; for(int i = 1; i &lt;= C; ++i) if(ch[0][i]) q.push(ch[0][i]); while(!q.empty()) { int u = q.front(); q.pop(); for(int i = 1; i &lt;= C; ++i) { int &amp;v = ch[u][i]; if(v) fail[v] = ch[fail[u]][i], q.push(v); else v = ch[fail[u]][i]; // 将非法状态等价到 fail 指针指向的节点！ } } } 对一个文本串进行匹配 求所有模式串在文本串中分别出现的次数。 从左至右检查文本串的每个字符然后直接暴力跳 ch[u,c]\\textrm{ch}[u, c]ch[u,c] 即可，因为我们已经建出了 trie 图！ 不用再考虑 fail 指针要怎么跳的问题了。 如同 ouuan 在 他的博客 里说到的，普通的「暴力跳 fail 指针」的 AC 自动机求模式串出现次数其实是 错误 的； 正确的做法是建出 fail 树之后 dfs 求出每棵子树的大小。 void query(std::string S) { int len = S.size(), u = 0; for(int i = 0; i &lt; len; ++i) { u = ch[u][S[i] - 'a' + 1]; ++siz[u]; } } void dfs(int x, int p) { for(int i = first[x]; ~i; i = e[i]._next) { int y = e[i].to; if(y == p) continue; dfs(y, x); siz[x] += siz[y]; } } void refresh() { for(int i = 1; i &lt;= cntNode; ++i) add(i, fail[i]), add(fail[i], i); dfs(0, 0); } 例题 写在最后 简单的一批，我会了。 ","link":"https://imzzy1201.github.io/post/DzEMEwgLv/"},{"title":"笔记 - KMP 算法","content":" 转载自 Clever_Jimmy’s blog\\textsf{C}\\color{red}\\textsf{lever\\_Jimmy&#x27;s\\ blog}Clever_Jimmy’s blog 写在前面 为了更方便地描述字符串相关内容，我们做出以下规定： 字符串通常用 S,TS, TS,T 等表示，ccc 通常表示一个字符，Σ\\SigmaΣ 表示字符集； 字符串长度用 ∣S∣\\left|S\\right|∣S∣ 表示； 字符集大小用 ∣Σ∣\\left|\\Sigma\\right|∣Σ∣ 表示； S[l..r]S[l..r]S[l..r] 表示 S[l],S[l+1],…,S[r−1],S[r]S[l], S[l + 1], \\ldots, S[r - 1], S[r]S[l],S[l+1],…,S[r−1],S[r]； 空串用 ϵ\\epsilonϵ 表示； SSS 是 TTT 的前缀，用 S⊏TS \\sqsubset TS⊏T 表示；SSS 是 TTT 的后缀，用 S⊐TS \\sqsupset TS⊐T 表示； SSS 的第 iii 个前缀，即 S[1..i]S[1..i]S[1..i]，用 SiS_iSi​ 表示。 特殊地，本文的字符串下标、π\\piπ 数组下标 均从 111 开始。 一些例子：对于 S=ABCBADS = \\mathtt{ABCBAD}S=ABCBAD 而言： ∣S∣=6\\left|S\\right| = 6∣S∣=6； ∣Σ∣=4\\left|\\Sigma\\right| = 4∣Σ∣=4； S[2..4]=BCBAS[2..4] = \\mathtt{BCBA}S[2..4]=BCBA； S4=ABCBS_4 = \\mathtt{ABCB}S4​=ABCB。 前缀函数数组 定义 对于一个字符串 SSS，我们定义其前缀函数 π(S)\\pi(S)π(S) 的值为 SSS 的最长相等的真前缀和真后缀的长度，即： π(S)=argmax⁡k&lt;∣S∣{S[1..k]=S[∣S∣−k+1..∣S∣]}=argmax⁡k&lt;∣S∣{Sk⊐S}\\begin{aligned} \\pi(S) &amp; = \\mathop{\\operatorname{argmax}}\\limits_{k &lt; \\left|S\\right|}\\{S[1..k] = S[\\left|S\\right| - k + 1..\\left|S\\right|]\\} \\\\ &amp; = \\mathop{\\operatorname{argmax}}\\limits_{k &lt; \\left|S\\right|}\\{S_k \\sqsupset S\\} \\end{aligned} π(S)​=k&lt;∣S∣argmax​{S[1..k]=S[∣S∣−k+1..∣S∣]}=k&lt;∣S∣argmax​{Sk​⊐S}​ 对于一个字符串 SSS，我们定义其前缀函数数组 π\\piπ 为 π[i]=π(Si)\\pi[i] = \\pi(S_i)π[i]=π(Si​)。 特殊地，当 ∣S∣=1\\left|S\\right| = 1∣S∣=1 时 π(S)=argmax⁡k&lt;1{S[1..k]=S[2−k..1]}\\pi(S) = \\mathop{\\operatorname{argmax}}\\limits_{k &lt; 1}\\{S[1..k] = S[2 - k..1]\\}π(S)=k&lt;1argmax​{S[1..k]=S[2−k..1]} 当 k=0k = 0k=0 时 S[1..0]=S[2..1]=ϵS[1..0] = S[2..1] = \\epsilonS[1..0]=S[2..1]=ϵ，故 π(S)=0\\pi(S) = 0π(S)=0。 性质 1：π(Si)=π[i]&lt;i\\pi(S_i) = \\pi[i] &lt; iπ(Si​)=π[i]&lt;i。 由定义知 π[i]&lt;i\\pi[i] &lt; iπ[i]&lt;i，即得证。 ■ 算法流程 根据定义，π[1]=0\\pi[1] = 0π[1]=0； 假设我们循环到了要求 π[i](i≥2)\\pi[i]\\quad(i \\ge 2)π[i](i≥2)，令 k←π[i−1]k \\gets \\pi[i - 1]k←π[i−1]。 由 π\\piπ 数组的定义得，此时 S[1..k]=S[i−k,i−1]S[1..k] = S[i - k, i - 1]S[1..k]=S[i−k,i−1]。 我们现在要做的，就是从 π[1..i−1]\\pi[1..i - 1]π[1..i−1] 递推到 π[i]\\pi[i]π[i]： 考虑到 π\\piπ 数组的定义，我们不断地枚举共同的前后缀（即使用 k=π[k]k = \\pi[k]k=π[k] 来迭代）。 结束这个迭代，有且仅有两种情况：k=0k = 0k=0 或 S[k+1]=S[i]S[k + 1] = S[i]S[k+1]=S[i]。 对于前者，说明对于字符串 S[1..i]S[1..i]S[1..i]，不存在任何两个真前缀与真后缀相同，π[i]=0\\pi[i] = 0π[i]=0。 对于后者，说明我们找到了一个 kkk，使得 S[1..k+1]=S[i−k..i]S[1..k + 1] = S[i - k..i]S[1..k+1]=S[i−k..i]，根据定义，有 π[i]=k+1\\pi[i] = k + 1π[i]=k+1。 至此，我们求出了字符串 SSS 的前缀函数数组 π\\piπ。 代码实现 void calcPi(char* S) { pi[1] = 0; int len = strlen(S + 1); for(int i = 2, k = 0; i &lt;= len; ++i) { while(k &gt; 0 &amp;&amp; S[k + 1] != S[i]) k = pi[k]; if(S[k + 1] == S[i]) ++k; pi[i] = k; } } 正确性 引理 1（后缀重叠引理）：对于 x,yx, yx,y 满足 x⊐z,y⊐zx \\sqsupset z, y \\sqsupset zx⊐z,y⊐z 而言，有 若 ∣x∣≤∣y∣\\left|x\\right| \\le \\left|y\\right|∣x∣≤∣y∣，则 x⊐yx \\sqsupset yx⊐y； 若 ∣x∣≥∣y∣\\left|x\\right| \\ge \\left|y\\right|∣x∣≥∣y∣，则 y⊐xy \\sqsupset xy⊐x； 若 ∣x∣=∣y∣\\left|x\\right| = \\left|y\\right|∣x∣=∣y∣，则 x=yx = yx=y。 证明 过于显然，证明略。 ■ 设 π⋆[q]={π[q],π(2)[q],⋯ ,π(t)[q]}\\pi^{\\star}[q] = \\{\\pi[q], \\pi^{(2)}[q], \\cdots, \\pi^{(t)}[q]\\} π⋆[q]={π[q],π(2)[q],⋯,π(t)[q]} 其中 π(i)[q]={qi=0π[π(i−1)[q]]i≥1\\pi^{(i)}[q] = \\begin{cases}q &amp; i = 0 \\\\ \\pi[\\pi^{(i - 1)}[q]] &amp; i \\ge 1\\end{cases} π(i)[q]={qπ[π(i−1)[q]]​i=0i≥1​ 当 π(t)[q]=0\\pi^{(t)}[q] = 0π(t)[q]=0 时 π⋆[q]\\pi^{\\star}[q]π⋆[q] 中的序列终止。 引理 2（前缀函数迭代引理）：对任意长度为 nnn 的字符串 SSS，有 ∀q∈[1,n],π⋆[q]={k:k&lt;q∧Sk⊐Sq}\\forall q \\in [1, n], \\pi^{\\star}[q] = \\{k: k &lt; q \\land S_k \\sqsupset S_q\\} ∀q∈[1,n],π⋆[q]={k:k&lt;q∧Sk​⊐Sq​} 证明 先证明 π⋆[q]⊆{k:k&lt;q∧Sk⊐Sq}\\pi^{\\star}[q] \\subseteq \\{k:k &lt; q \\land S_k \\sqsupset S_q\\}π⋆[q]⊆{k:k&lt;q∧Sk​⊐Sq​}， 即证明 ∀x∈π⋆[q],x&lt;q∧Sx⊐Sq\\forall x \\in \\pi^{\\star}[q], x &lt; q \\land S_x \\sqsupset S_q∀x∈π⋆[q],x&lt;q∧Sx​⊐Sq​。 任取 x∈π⋆[q]x \\in \\pi^{\\star}[q]x∈π⋆[q]，不妨设 x=πu[q](u&gt;0)x = \\pi^{u}[q] \\quad (u &gt; 0)x=πu[q](u&gt;0)，下面通过对 uuu 的数学归纳法证明命题成立。 （基础）当 u=1u = 1u=1 时，x=π[q]x = \\pi[q]x=π[q]，由 π\\piπ 数组的定义可知 π[q]&lt;q∧Sπ[q]⊐Sq\\pi[q] &lt; q \\land S_{\\pi[q]} \\sqsupset S_qπ[q]&lt;q∧Sπ[q]​⊐Sq​。 （假设）假设当 u=vu = vu=v 时 πv[q]&lt;q∧Sπv[q]⊐Sq\\pi^{v}[q] &lt; q \\land S_{\\pi^{v}[q]} \\sqsupset S_qπv[q]&lt;q∧Sπv[q]​⊐Sq​。 （推导）则当 u=v+1u = v + 1u=v+1 时，πv+1[q]=π[πv[q]]&lt;πv[q]&lt;q\\pi^{v + 1}[q] = \\pi[\\pi^{v}[q]] &lt; \\pi^{v}[q] &lt; qπv+1[q]=π[πv[q]]&lt;πv[q]&lt;q（性质 1）；Sπv+1[q]⊐Sπv[q]⊐SqS_{\\pi^{v + 1}[q]} \\sqsupset S_{\\pi^{v}[q]} \\sqsupset S_qSπv+1[q]​⊐Sπv[q]​⊐Sq​（由性质 1 得到下标的大小关系，由引理 1 得到前缀之间的关系） 因此 ∀x∈π⋆[q],x&lt;q∧Sx⊐Sq\\forall x \\in \\pi^{\\star}[q], x &lt; q \\land S_x \\sqsupset S_q∀x∈π⋆[q],x&lt;q∧Sx​⊐Sq​。 再证明 {k:k&lt;q∧Sk⊐Sq}⊆π⋆[q]\\{k:k &lt; q \\land S_k \\sqsupset S_q\\} \\subseteq \\pi^{\\star}[q]{k:k&lt;q∧Sk​⊐Sq​}⊆π⋆[q]， 即证明 ∀x∈{k:k&lt;q∧Sx⊐Sq},x∈π⋆[q]\\forall x \\in \\{k:k &lt; q \\land S_x \\sqsupset S_q\\}, x \\in\\pi^{\\star}[q]∀x∈{k:k&lt;q∧Sx​⊐Sq​},x∈π⋆[q] 考虑使用反证法来证明命题成立。 假设集合 M={k:k&lt;q∧Sk⊐Sq}−π⋆[q]M = \\{k:k &lt; q \\land S_k \\sqsupset S_q\\} - \\pi^{\\star}[q]M={k:k&lt;q∧Sk​⊐Sq​}−π⋆[q] 非空，jjj 是 MMM 中的最大值。 ∵\\because∵ π[q]\\pi[q]π[q] 是 {k:k&lt;q∧Sx⊐Sq}\\{k:k &lt; q \\land S_x \\sqsupset S_q\\}{k:k&lt;q∧Sx​⊐Sq​} 中的最大值，且 j∈{k:k&lt;q∧Sx⊐Sq}j \\in \\{k:k &lt; q \\land S_x \\sqsupset S_q\\}j∈{k:k&lt;q∧Sx​⊐Sq​} ∴j&lt;π[q],Sj⊐Sq\\therefore j &lt; \\pi[q], S_j \\sqsupset S_q∴j&lt;π[q],Sj​⊐Sq​ 又 ∵π[q]∈π⋆[q]\\because \\pi[q] \\in \\pi^{\\star}[q]∵π[q]∈π⋆[q] ∴∃j′∈π⋆[q],s.t. j′&gt;j\\therefore \\exists j&#x27; \\in \\pi^{\\star}[q], \\text{s.t. }j&#x27; &gt; j∴∃j′∈π⋆[q],s.t. j′&gt;j 设 j′j&#x27;j′ 表示 π⋆[q]\\pi^{\\star}[q]π⋆[q] 中比 jjj 大的最小整数。 ∵{k:k&lt;q∧Sk⊐Sq}⊆π⋆[q]\\because \\{k:k &lt; q \\land S_k \\sqsupset S_q\\} \\subseteq \\pi^{\\star}[q]∵{k:k&lt;q∧Sk​⊐Sq​}⊆π⋆[q] 且 j′∈π⋆[q]j&#x27; \\in \\pi^{\\star}[q]j′∈π⋆[q] ∴Sj′⊐Sq\\therefore S_{j&#x27;} \\sqsupset S_q∴Sj′​⊐Sq​ ∵j′&gt;j\\because j&#x27; &gt; j∵j′&gt;j 且 jjj 是小于 j′j&#x27;j′ 的最大值 ∴Sj⊐Sj′\\therefore S_j \\sqsupset S_{j&#x27;}∴Sj​⊐Sj′​（引理 1） 由 π\\piπ 数组的定义知 π[j′]=j\\pi[j&#x27;] = jπ[j′]=j ∵j′∈π⋆[q]\\because j&#x27; \\in \\pi^{\\star}[q]∵j′∈π⋆[q] ∴j=π[j′]∈π⋆[q]\\therefore j = \\pi[j&#x27;] \\in \\pi^{\\star}[q]∴j=π[j′]∈π⋆[q]，与假设矛盾 因此 {k:k&lt;q∧Sk⊐Sq}⊆π⋆[q]\\{k:k &lt; q \\land S_k \\sqsupset S_q\\} \\subseteq \\pi^{\\star}[q]{k:k&lt;q∧Sk​⊐Sq​}⊆π⋆[q]。 综上所述，对任意长度为 nnn 的字符串 SSS，有 ∀q∈[1,n],π⋆[q]={k:k&lt;q∧Sk⊐Sq}\\forall q \\in [1, n], \\pi^{\\star}[q] = \\{k: k &lt; q \\land S_k \\sqsupset S_q\\}∀q∈[1,n],π⋆[q]={k:k&lt;q∧Sk​⊐Sq​}。 ■ 引理 3：对任意长度为 nnn 的字符串 SSS，有 ∀q∈[1,n]\\forall q \\in [1, n]∀q∈[1,n]，若 π[q]&gt;0\\pi[q] &gt; 0π[q]&gt;0，则 π[q]−1∈π⋆[q−1]\\pi[q] - 1 \\in \\pi^{\\star}[q - 1]π[q]−1∈π⋆[q−1]。 证明 令 x=π[q]&gt;0x = \\pi[q] &gt; 0x=π[q]&gt;0，则 x&lt;q,Sx⊐Sqx &lt; q, S_x \\sqsupset S_qx&lt;q,Sx​⊐Sq​ ∵x&gt;0\\because x &gt; 0∵x&gt;0，则 x−1x - 1x−1 有意义 ∴x−1&lt;q−1,Sx−1⊐Sq−1\\therefore x - 1 &lt; q - 1, S_{x - 1} \\sqsupset S_{q - 1}∴x−1&lt;q−1,Sx−1​⊐Sq−1​（把 SxS_xSx​ 和 SqS_qSq​ 的最后一个字符去掉） 由引理 2 知 x−1∈π⋆[q−1]x - 1 \\in \\pi^{\\star}[q - 1]x−1∈π⋆[q−1] ∴∀q∈[1,n]∧π[q]&gt;0,π[q]−1∈π⋆[q−1]\\therefore \\forall q \\in [1, n] \\land \\pi[q] &gt; 0,\\pi[q] - 1 \\in \\pi^{\\star}[q - 1]∴∀q∈[1,n]∧π[q]&gt;0,π[q]−1∈π⋆[q−1] ■ 对 q∈[2,n]q \\in [2, n]q∈[2,n] 定义子集 Eq−i⊆π⋆[q−1]E_{q - i} \\subseteq \\pi^{\\star}[q - 1]Eq−i​⊆π⋆[q−1] 为： Eq−1={k∈π⋆[q−1]:Sk+1=Sk}E_{q - 1} = \\{k\\in\\pi^{\\star}[q - 1]:S_{k + 1} = S_k\\} Eq−1​={k∈π⋆[q−1]:Sk+1​=Sk​} 则有： Eq−1={k∈π⋆[q−1]:Sk+1=Sk}={k:k&lt;q−1,Sk⊐Sq−1,S[k+1]=S[q]}={k:k&lt;q−1,Sk+1⊐Sq}\\begin{aligned} E_{q - 1} &amp; = \\{k\\in\\pi^{\\star}[q - 1]:S_{k + 1} = S_k\\} \\\\ &amp; = \\{k: k &lt; q - 1, S_k \\sqsupset S_{q - 1}, S[k + 1] = S[q]\\} \\\\ &amp; = \\{k: k &lt; q - 1, S_{k + 1} \\sqsupset S_q\\} \\end{aligned} Eq−1​​={k∈π⋆[q−1]:Sk+1​=Sk​}={k:k&lt;q−1,Sk​⊐Sq−1​,S[k+1]=S[q]}={k:k&lt;q−1,Sk+1​⊐Sq​}​ 因此，Eq−1E_{q - 1}Eq−1​ 是由 π⋆[q−1]\\pi^{\\star}[q - 1]π⋆[q−1] 中的值组成的、能满足 Sk+1S_{k + 1}Sk+1​ 与 SqS_qSq​ 的某个后缀相等的 kkk 组成的集合。 推论 1：对任意长度为 nnn 的字符串 SSS，有 ∀q∈[2,n],π[q]={0Eq−1=∅1+max⁡{k∈Eq−1}Eq−1≠∅\\forall q \\in [2, n],\\pi[q] = \\begin{cases}0 &amp; E_{q - 1} = \\varnothing \\\\ 1 + \\max\\{k \\in E_{q - 1}\\} &amp; E_{q - 1} \\neq \\varnothing\\end{cases} ∀q∈[2,n],π[q]={01+max{k∈Eq−1​}​Eq−1​=∅Eq−1​​=∅​ 证明 当 Eq−1=∅E_{q - 1} = \\varnothingEq−1​=∅ 时，不存在任何一个 k∈π⋆[q−1]k \\in \\pi^{\\star}[q - 1]k∈π⋆[q−1]，使得 Sk+1⊐SqS_{k + 1} \\sqsupset S_qSk+1​⊐Sq​。 显然此时 π[q]\\pi[q]π[q] 只能为 000。 当 Eq−1≠∅E_{q - 1} \\neq \\varnothingEq−1​​=∅ 时， ∀k∈Eq−1,k&lt;q−1∧Sk+1⊐Sq⟹k+1&lt;q\\forall k \\in E_{q - 1}, k &lt; q - 1 \\land S_{k + 1} \\sqsupset S_q \\Longrightarrow k + 1 &lt; q∀k∈Eq−1​,k&lt;q−1∧Sk+1​⊐Sq​⟹k+1&lt;q 则由 π[q]\\pi[q]π[q] 的定义，kkk 是拓展到 SqS_qSq​ 的某一后缀的备选项，π[q]≥1+max⁡{k∈Eq−1}\\pi[q] \\ge 1 + \\max\\{k \\in E_{q - 1}\\}π[q]≥1+max{k∈Eq−1​}。 注意到此时 π[q]&gt;0\\pi[q] &gt; 0π[q]&gt;0，设 r=π[q]−1r = \\pi[q] - 1r=π[q]−1。 则 r+1=π[q]&lt;q,Sr+1=Sπ[q]⊐Sqr + 1 = \\pi[q] &lt; q, S_{r + 1} = S_{\\pi[q]} \\sqsupset S_qr+1=π[q]&lt;q,Sr+1​=Sπ[q]​⊐Sq​。 ∵r+1&gt;0\\because r + 1 &gt; 0∵r+1&gt;0 ∴Sr+1=Sq\\therefore S_{r + 1} = S_q∴Sr+1​=Sq​ 由引理 3 可得 r=π[q]−1∈π⋆[q−1]r = \\pi[q] - 1 \\in \\pi^{\\star}[q - 1]r=π[q]−1∈π⋆[q−1] ∴r∈Eq−1\\therefore r \\in E_{q - 1}∴r∈Eq−1​ ∴π[q]−1=r≤max⁡{k∈Eq−1}\\therefore \\pi[q] - 1 = r \\le \\max\\{k \\in E_{q - 1}\\}∴π[q]−1=r≤max{k∈Eq−1​} 即 π[q]≤1+max⁡{k∈Eq−1}\\pi[q] \\le 1 + \\max\\{k \\in E_{q - 1}\\}π[q]≤1+max{k∈Eq−1​} 综上所述，当 Eq−1≠∅E_{q - 1} \\neq \\varnothingEq−1​​=∅，π[q]=1+max⁡{k∈Eq−1}\\pi[q] = 1 + \\max\\{k \\in E_{q - 1}\\}π[q]=1+max{k∈Eq−1​}。 ■ 再来看看代码： void calcPi(char* S) { pi[1] = 0; int len = strlen(S + 1); for(int i = 2, k = 0; i &lt;= len; ++i) { while(k &gt; 0 &amp;&amp; S[k + 1] != S[i]) k = pi[k]; if(S[k + 1] == S[i]) ++k; pi[i] = k; } } 接下来我们将使用循环不变式来证明上述代码的正确性。 证明 初始化 在第 4 行的迭代开始前，有 i=1,k=π[i]=0i = 1, k = \\pi[i] = 0i=1,k=π[i]=0，不变式成立。 保持 在每次迭代开始前，有 k=π[i−1]k = \\pi[i - 1]k=π[i−1]： 若是第一次迭代，此等式由第 4 行保证； 其余迭代均由第 9 行保证。 接下来要证明每次迭代结束后均有 k=π[i]k = \\pi[i]k=π[i] 成立。 若 k≠π[i]k \\neq \\pi[i]k​=π[i]，则会在第 5-8 行将 kkk 调整至 π[i]\\pi[i]π[i]。 第 5 行的 while 循环遍历每一个 k∈π⋆[i−1]k \\in \\pi^{\\star}[i - 1]k∈π⋆[i−1]，直至找到一个 kkk，使得 S[k+1]=S[i]S[k + 1] = S[i]S[k+1]=S[i]。（引理 2） 若找不到这样的值，则在第 7 行 k=0k = 0k=0。 若找到了这样的值，此时 kkk 为满足条件的集合中的最大值，应将 π[i]←k+1\\pi[i] \\gets k + 1π[i]←k+1。（推论 1） 第 9 行的赋值语句使得 k=π[i]k = \\pi[i]k=π[i] 恒成立。 终止 当 i=n+1i = n + 1i=n+1 时，迭代终止，此时我们求出了 π[1..n]\\pi[1..n]π[1..n]。 至此，算法结束。 因此，上述代码实现能正确地求出字符串 SSS 的前缀函数数组。 ■ 时间复杂度 不难发现，第 7-9 行代码的时间复杂度均为 O(n)O(n)O(n)，唯一棘手的是第 6-7 行代码。 考虑 kkk 的变化，kkk 在第 7-8 行增加的次数不超过 nnn 次，即 k≤nk \\le nk≤n； kkk 在第 6 行的操作中，因为有 π(Si)&lt;i\\pi(S_i) &lt; iπ(Si​)&lt;i 的性质，导致每次迭代至少使 kkk 减小 111，即最多迭代 nnn 次。 综上所述，用上述方法求一个字符串的前缀函数数组的时间复杂度为 O(n)O(n)O(n)。 空间复杂度 易知用此种方法求前缀函数数组的空间复杂度为 O(n)O(n)O(n)。 KMP 算法 算法流程 我们举一个例子：用 S=CCFCCFMONEYS = \\mathtt{CCFCCFMONEY}S=CCFCCFMONEY 被 T=CCFCCFSBT = \\mathtt{CCFCCFSB}T=CCFCCFSB 匹配。 我们定义两个指针 i,ki,ki,k，表示 S[i−k..i−1]=T[1..k]S[i - k..i - 1] = T[1..k]S[i−k..i−1]=T[1..k]。 我们要拓展的，就是 S[i]S[i]S[i] 与 T[k+1]T[k + 1]T[k+1] 之间的关系。 首先我们考虑朴素算法的弊端：当你匹配到了 i=8,k=7i = 8, k = 7i=8,k=7 时： S=CCFXCCFMONEYT=CCFXCCFSBindex=123456789\\begin{aligned} S &amp; = \\mathtt{\\color{green}CCFXCCF\\color{red}M\\color{black}ONEY} \\\\ T &amp; = \\mathtt{\\color{green}CCFXCCF\\color{red}S\\color{black}B} \\\\ \\text{index} &amp; =\\mathtt{123456789} \\end{aligned} STindex​=CCFXCCFMONEY=CCFXCCFSB=123456789​ 你发现 S[i]=S[8]=MS[i] = S[8] = \\mathtt{M}S[i]=S[8]=M，可 T[k+1]=T[8]=ST[k + 1] = T[8] = \\mathtt{S}T[k+1]=T[8]=S，我们前功尽弃，只能将 TTT 往右平移一格。 而且要重新开始：i=1,k=1i = 1, k = 1i=1,k=1。 S=CCFXCCFMONEYT= CCFXCCFSBindex=123456789\\begin{aligned} S &amp; = \\mathtt{CCFXCCFMONEY} \\\\ T &amp; = \\mathtt{\\text{ }CCFXCCFSB} \\\\ \\text{index} &amp; =\\mathtt{123456789} \\end{aligned} STindex​=CCFXCCFMONEY= CCFXCCFSB=123456789​ 显然朴素算法的时间复杂度为 O(nm)O(nm)O(nm)。 再考虑使用前缀函数 π\\piπ 来优化匹配的过程。 不难求出 TTT 的前缀数组 π[1..n]={0,1,0,0,1,2,3,0,0}\\pi[1..n] = \\{0, 1, 0, 0, 1, 2, 3, 0, 0\\}π[1..n]={0,1,0,0,1,2,3,0,0}。 考虑前缀数组的意义：TiT_iTi​ 的最长的相等的前后缀长度。 你知道了当 i=8,k=7i = 8, k = 7i=8,k=7 时，有 S[1..7]=T[1..7]S[1..7] = T[1..7]S[1..7]=T[1..7]，而且 T[1..3]=T[5..7]T[1..3] = T[5..7]T[1..3]=T[5..7]。 在上述的例子中，也就是我们可以把 T[1..3]T[1..3]T[1..3] 这个地方匹配到的 CCF\\mathtt{\\color{green}CCF}CCF 移动到 S[5..8]S[5..8]S[5..8] 去。 这样就直接节省了三次移动。 总结一下使用前缀函数 π\\piπ 时我们的匹配过程： 使用 i,ki, ki,k 来表示当前 S[i−k..i−1]=T[1..k]S[i - k..i - 1] = T[1..k]S[i−k..i−1]=T[1..k]； 如果 S[i]≠T[k+1]S[i] \\neq T[k + 1]S[i]​=T[k+1]，我们就用 π\\piπ 函数来实现大幅度的跳跃； 否则 k′←k+1k&#x27; \\gets k + 1k′←k+1，表示 S[i−k..i]=T[1..k+1]S[i - k..i] = T[1..k + 1]S[i−k..i]=T[1..k+1]； 当 k=mk = mk=m 时，说明找到了一个匹配 S[i−m+1..i]=T[1..m]S[i - m + 1..i] = T[1..m]S[i−m+1..i]=T[1..m]。 代码实现 for(int i = 1, k = 0; i &lt;= n; ++i) { while(k &gt; 0 &amp;&amp; T[k + 1] != S[i]) k = pi[k]; if(T[k + 1] == S[i]) ++k; if(k == m) { printf(&quot;%d\\n&quot;, i - m + 1); // S[i - m + 1..i] = T[1..m] k = pi[k]; } } 正确性 可以证明，上述代码实现是正确的。 时间复杂度 依葫芦画瓢地使用求前缀函数数组时的摊还分析方法，不难得出 KMP 算法的时间复杂度为 O(n+m)O(n + m)O(n+m)。 空间复杂度 不难发现 KMP 算法的空间复杂度为 O(n+m)O(n + m)O(n+m)。 例题 NOI2014 动物园 POJ 1961-Period CF1200E Compress Words POI2006 OKR-Periods of Words 写在最后 《算法导论》是本好书，上面的算法均有使用循环不变式的正确性证明，很值得一看。 ","link":"https://imzzy1201.github.io/post/_6LRu8zNr/"},{"title":"20200224 校内测试订正","content":" Tough time don't last, tough people do. 1. 概况 ouuan 出的神仙题！ 好题！ T1 100pts 很妙 T2 100pts 也很妙 T3 15pts EA 都不会啊，，但挺有意思的 总分 215pts 感觉良好（?） 2. 题解 测试资源链接（校内题库，不公开密码） T1 纳沃和国际象棋 题面（Codeforces） 思路 构造题啦。 大概像下面这样放的： 1 2 - - - - - ... - 3 4 - - - - ... - - 5 6 - - - ... - - - 7 8 - - ... - - - - 9 10 - ... - - - - - 11 12 ... 然后就……就这样放了呗。 Code #include&lt;bits/stdc++.h&gt; #define rgi register int using namespace std; signed main() { // freopen(&quot;chess.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;chess.out&quot;,&quot;w&quot;,stdout); int n; cin&gt;&gt;n; cout&lt;&lt;n/2+1&lt;&lt;endl; for(rgi i=1;i&lt;=n;++i) cout&lt;&lt;(i+1)/2&lt;&lt;' '&lt;&lt;(i+1)/2+(i%2==0)&lt;&lt;endl; return 0; } T2 纳沃和圆 题面（Codeforces） 思路 题解讲得非常清楚了，所以呢……直接搬运吧： 首先，如果选一个根使其变为有根树，可以发现每棵子树一定在一段连续的弧上。 考虑 DP，令 fuf_ufu​ 为子树 uuu 方案数，那么 fu=(∣son(u)∣+[u≠root])!∏v∈son(u)fu, ans=nfrootf_u=(|son(u)|+[u\\neq root])!\\prod_{v\\in son(u)}f_u,\\ ans=nf_{root}fu​=(∣son(u)∣+[u​=root])!∏v∈son(u)​fu​, ans=nfroot​（先固定根的位置，每 棵子树要为儿子排位置，如果非根自己也要参与排位置，然后再画子树） 事实上不需要 DP，答案为每个点的度数阶乘之积乘上 nnn。 然而我菜所以还是写的 DP（ Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long using namespace std; const int maxn=200004,mod=998244353; struct EDGE{int v,nxt;}e[maxn&lt;&lt;1]; int fst[maxn],cnte; inline void addedge(int u,int v) {e[++cnte]=(EDGE){v,fst[u]},fst[u]=cnte;} int fa[maxn]; ll val[maxn],fact[maxn]; // val 就是上面的 f vector&lt;int&gt; son[maxn]; ll dfs(int u,int f) { fa[u]=f,val[u]=1; for(rgi i=fst[u];i;i=e[i].nxt) if(e[i].v!=f) (val[u]*=dfs(e[i].v,u))%=mod,son[u].push_back(e[i].v); val[u]=val[u]*(son[u].size()+1ll)%mod*fact[son[u].size()]%mod; return val[u]; } signed main() { // freopen(&quot;circle.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;circle.out&quot;,&quot;w&quot;,stdout); int num,n,u,v; cin&gt;&gt;num&gt;&gt;n; fact[0]=1; for(rgi i=1;i&lt;=n;++i) fact[i]=fact[i-1]*i%mod; for(rgi i=1;i&lt;n;++i) cin&gt;&gt;u&gt;&gt;v,addedge(u,v),addedge(v,u); dfs(1,1); ll ans=n*fact[son[1].size()]%mod; for(rgi i=0;i&lt;son[1].size();++i) (ans*=val[son[1][i]])%=mod; cout&lt;&lt;ans&lt;&lt;endl; return 0; } T3 纳沃和无线电 咕咕咕 ","link":"https://imzzy1201.github.io/post/Y66PjEqEi/"},{"title":"20200722 校内测试订正","content":" If you're not satisfied with the life you're living, don't just complain. Do something about it. 1. 概况 太毒瘤了。 太太太毒瘤了。 T1 0pts 大模拟（猪国杀+智慧猪.jpg） T2 40pts 算是挺好的 DP 题了 T3 10pts 不会，神仙题 总分 50pts emmmm… 2. 题解 测试资源链接（校内题库，不公开密码） T1 低仿机器人 题面（暂无） 思路 毒瘤大模拟。听说 Clever_Jimmy\\textsf{C}\\color{red}\\textsf{lever\\_Jimmy}Clever_Jimmy 写了 777kb 的代码。但好像 std 没压行也就 150150150 行啊。 反正蛮多细节，代码马上补。 Code Empty! T2 迷路的刺豚 题面（暂无） 思路 可以看到 ppp 很小，所以可以状压当前已经经过了的菜店。 总共有以下步骤： 先动态规划求出刺豚在每个点的最大体积 用类似 SPFA 的 bfs 方法以每个菜店为起点求它到所有点的最短路以及最短路上的最大体积和（注意这里的体积和不包含起点那个菜店的体积） 状压当前已经到过的菜店，动态规划求出经过所有菜店的最短路以及最短路上的最大体积和 大概就是这样的，实现上有一些小细节吧。 Code #include&lt;bits/stdc++.h&gt; namespace imzzy{ #define endl '\\n' #define rgi register int #define ll long long class fastin{private:int _ch,_f; public:inline fastin&amp;operator&gt;&gt;(char&amp;c){c=getchar();return*this;} template&lt;typename _Tp&gt;inline fastin&amp;operator&gt;&gt;(_Tp&amp;_x){ _x=0;while(!isdigit(_ch))_f|=(_ch==45),_ch=getchar(); while(isdigit(_ch))_x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0);return*this;}fastin(){_ch=_f=0;} }fin;class fastout{private:int _num[32],_head; public:inline fastout&amp;operator&lt;&lt;(char c){putchar(c);return*this;} template&lt;typename _Tp&gt; inline fastout&amp;operator&lt;&lt;(_Tp _x){ _Tp _k;if(_x==0){putchar('0');return *this;}if(_x&lt;0)putchar('-'),_x=-_x; while(_x&gt;0)_k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0)putchar(_num[_head]),--_head;return*this;}fastout(){_head=0;} }fout;inline void P_INIT(){ #ifdef D_STDOUT_UNBUFFERED setbuf(stdout,NULL); #endif }}using namespace imzzy; // ---------------------------- // #define int ll using namespace std; const int maxn=304; const int mod=1000000007,inf=1201201201; const int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}}; int n,m,s,p; int a[maxn][maxn],px[maxn],py[maxn]; // a 存地图，px py 存菜店的坐标（特别的，px[0] py[0] 存起点坐标） int f[maxn][maxn],g[maxn][maxn]; // f[x][y] 是右下角坐标 (x,y) 的最大空正方形，g[x][y] 是中心为 (x,y) 的最大空正方形（即最大体积） int to1[20][20],to2[20][20]; // 记录菜店两两之间的最短路、最短路对应的最大体积和 int dist[maxn][maxn],kkk[maxn][maxn]; // bfs 时分别记录最短路、最短路对应的最大体积和 queue&lt;pair&lt;int,int&gt; &gt;q; bool book[maxn][maxn]; void bfs(int t) { q.push(make_pair(px[t],py[t])); memset(dist,0x3f,sizeof(dist)); memset(kkk,0x3f,sizeof(kkk)); dist[px[t]][py[t]]=kkk[px[t]][py[t]]=0; while(!q.empty()) { pair&lt;int,int&gt; pos=q.front(); q.pop(); int x=pos.first,y=pos.second; book[x][y]=0; for(rgi i=0;i&lt;4;++i) { int tx=x+dir[i][0],ty=y+dir[i][1]; if(tx&gt;=0&amp;&amp;tx&lt;=n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;=m&amp;&amp;!a[tx][ty]) if(dist[tx][ty]&gt;dist[x][y]+1 || dist[tx][ty]==dist[x][y]+1 &amp;&amp; kkk[tx][ty]&lt;kkk[x][y]+g[tx][ty]) { dist[tx][ty]=dist[x][y]+1,kkk[tx][ty]=kkk[x][y]+g[tx][ty]; if(!book[tx][ty]) book[tx][ty]=1,q.push(make_pair(tx,ty)); } } } for(rgi i=0;i&lt;=p;++i) if(i!=t) to1[t][i]=dist[px[i]][py[i]],to2[t][i]=kkk[px[i]][py[i]]; } int dp[34000][20],ccf[34000][20]; // dp[i][j] 是状态为 i、以 j 为终点的最短路，ccf 类似地记录最短路对应的最大体积和 signed main() {P_INIT(); // freopen(&quot;expand.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;expand.out&quot;,&quot;w&quot;,stdout); fin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(rgi i=1;i&lt;=n;++i) for(rgi j=1;j&lt;=m;++j) fin&gt;&gt;a[i][j]; for(rgi i=1;i&lt;=n;++i) for(rgi j=1;j&lt;=m;++j) if(a[i][j]==0) f[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1; for(rgi i=1;i&lt;=n;++i) for(rgi j=1;j&lt;=m;++j) for(rgi k=1;k&lt;=s&amp;&amp;i+k&lt;=n&amp;&amp;j+k&lt;=m;++k) if(f[i+k][j+k]&gt;=2*k+1) g[i][j]=k; else break; fin&gt;&gt;px[0]&gt;&gt;py[0]&gt;&gt;p,++px[0],++py[0]; for(rgi i=1;i&lt;=p;++i) fin&gt;&gt;px[i]&gt;&gt;py[i],++px[i],++py[i]; for(rgi i=0;i&lt;=p;++i) bfs(i); memset(dp,0x3f,sizeof(dp)),memset(dp[1],0,sizeof(dp[1])); memset(ccf,0,sizeof(ccf)),ccf[1][0]=g[px[0]][py[0]]; for(rgi i=1;i&lt;1&lt;&lt;(p+1);++i) for(rgi j=0;j&lt;=p;++j) if(i&amp;(1&lt;&lt;j)) for(rgi k=0;k&lt;=p;++k) if((i&amp;(1&lt;&lt;k))&amp;&amp;j!=k) if(dp[i][j]&gt;dp[i-(1&lt;&lt;j)][k]+to1[k][j] || dp[i][j]==dp[i-(1&lt;&lt;j)][k]+to1[k][j] &amp;&amp; ccf[i][j]&lt;ccf[i-(1&lt;&lt;j)][k]+to2[k][j]) dp[i][j]=dp[i-(1&lt;&lt;j)][k]+to1[k][j],ccf[i][j]=ccf[i-(1&lt;&lt;j)][k]+to2[k][j]; int ans1=inf,ans2=0; for(rgi i=0;i&lt;=p;++i) { if(ans1&gt;dp[(1&lt;&lt;(p+1))-1][i] || ans1==dp[(1&lt;&lt;(p+1))-1][i] &amp;&amp; ans2&lt;ccf[(1&lt;&lt;(p+1))-1][i]) ans1=dp[(1&lt;&lt;(p+1))-1][i],ans2=ccf[(1&lt;&lt;(p+1))-1][i]; } fout&lt;&lt;ans1&lt;&lt;' '&lt;&lt;ans2&lt;&lt;endl; return 0; } // ---------------------------- // by imzzy T3 生日 咕咕咕神仙题 ","link":"https://imzzy1201.github.io/post/1kYV7zMuz/"},{"title":"咕咕咕","content":" What is lost is lost. 改来的，总是要来的；该补的，总是要补的。 待补的题： 20200717T1 20200720T2 20200722T1 20200722T3 20200724T3 待总结的知识点： 平衡树（大概得写半年） 莫比乌斯函数及莫比乌斯反演 欧拉函数及欧拉反演 杜教筛、min_25 筛、州阁筛（不会） Matrix tree 定理 Stirling 数及 Stirling 反演 ","link":"https://imzzy1201.github.io/post/7kZGCxGbI/"},{"title":"20200720 校内测试订正","content":" It's not the altitude, it's the attitude. 1. 概况 T1 100pts 差点死在这题了 T2 100pts 码了快 0.5h 的后缀树发现这题根本不用后缀树 T3 30pst 一眼分码完就走人了 总分 230pts 算是这几次考得最好的了 2. 题解 测试资源链接（校内题库，不公开密码） T1 故障检测 题面（暂无） 思路 考虑二分法。我们发现，每次询问一串节点，可以确定选中的 mmm 个点中后 m−1m-1m−1 个点是否为故障点，并确定故障点在这 mmm 个点的左侧还是右侧，稍加分析可以得出，令 f(i)f(i)f(i) 表示确定 iii 个点中的故障点所需询问次数，则易得： f(n)={f(⌈n−m+12⌉)+1n&gt;m+11n≤m+1f(n)= \\begin{cases} f\\left(\\left\\lceil\\frac{n-m+1}{2}\\right\\rceil\\right)+1&amp;n&gt;m+1\\\\ 1&amp;n\\le m+1 \\end{cases} f(n)={f(⌈2n−m+1​⌉)+11​n&gt;m+1n≤m+1​ Code #include&lt;bits/stdc++.h&gt; namespace P_TEMPLATE{ #define endl '\\n' #define ccf std::cout&lt;&lt;&quot;f**k&quot;&lt;&lt;endl #define rgi register int #define ll long long class fastin{private:int _ch,_f; public:inline fastin&amp;operator&gt;&gt;(char&amp;c){c=getchar();return*this;} template&lt;typename _Tp&gt;inline fastin&amp;operator&gt;&gt;(_Tp&amp;_x){ _x=0;while(!isdigit(_ch))_f|=(_ch==45),_ch=getchar(); while(isdigit(_ch))_x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0);return*this;}fastin(){_ch=_f=0;} }fin;class fastout{private:int _num[32],_head; public:inline fastout&amp;operator&lt;&lt;(char c){putchar(c);return*this;} template&lt;typename _Tp&gt; inline fastout&amp;operator&lt;&lt;(_Tp _x){ _Tp _k;if(_x==0){putchar('0');return *this;}if(_x&lt;0)putchar('-'),_x=-_x; while(_x&gt;0)_k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0)putchar(_num[_head]),--_head;return*this;}fastout(){_head=0;} }fout;inline void P_INIT(){ #ifdef D_STDOUT_UNBUFFERED setbuf(stdout,NULL),setbuf(stdin,NULL); #endif }}using namespace P_TEMPLATE; // ---------------------------- // #define int ll // using namespace std; const int maxn=1000004; const int mod=1000000007,inf=1201201201; signed main() { // freopen(&quot;test.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;test.out&quot;,&quot;w&quot;,stdout); ll n,m,ans=0; fin&gt;&gt;n&gt;&gt;m; while(1) { ++ans; if(n&lt;=m+1) break; n=(n-m)/2+1; // ⌈(n-m+1)/2⌉ = ⌊(n-m)/2+1⌋ } fout&lt;&lt;ans; return 0; } // ---------------------------- // by imzzy T2 妮可妮可妮 题面（暂无） 思路 首先我们发现原串和其反串的计算效果是一样的，而算反串就算的是前缀，所以果断取反串。 观察形如 ABABAABABAABABA 的串的性质，我们可以发现，它前面重复了两次 ABABAB，最后由一个 AAA。对于判断 AB 是否重复了两次，只需哈希即可。而对于最后一个 AAA，我们可以预处理时顺序比较，可以做到 O(n)\\mathcal{O}(n)O(n)。 具体实现看代码。 Code #include&lt;bits/stdc++.h&gt; namespace P_TEMPLATE{ #define endl '\\n' #define ccf std::cout&lt;&lt;&quot;f**k&quot;&lt;&lt;endl #define rgi register int #define ll long long class fastin{private:int _ch,_f; public:inline fastin&amp;operator&gt;&gt;(char&amp;c){c=getchar();return*this;} template&lt;typename _Tp&gt;inline fastin&amp;operator&gt;&gt;(_Tp&amp;_x){ _x=0;while(!isdigit(_ch))_f|=(_ch==45),_ch=getchar(); while(isdigit(_ch))_x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0);return*this;}fastin(){_ch=_f=0;} }fin;class fastout{private:int _num[32],_head; public:inline fastout&amp;operator&lt;&lt;(char c){putchar(c);return*this;} template&lt;typename _Tp&gt; inline fastout&amp;operator&lt;&lt;(_Tp _x){ _Tp _k;if(_x==0){putchar('0');return *this;}if(_x&lt;0)putchar('-'),_x=-_x; while(_x&gt;0)_k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0)putchar(_num[_head]),--_head;return*this;}fastout(){_head=0;} }fout;inline void P_INIT(){ #ifdef D_STDOUT_UNBUFFERED setbuf(stdout,NULL),setbuf(stdin,NULL); #endif }}using namespace P_TEMPLATE; // ---------------------------- // #define int ll // using namespace std; const int maxn=500004,maxm=27; const int mod=1000000007,inf=1201201201; char s[maxn],s2[maxn]; int n; bool ans[maxn],book=1; void work() { srand(time(0)); int len=0,mod1=inf+rand()%1201201,mod2=mod+rand()%1201; ll mul1=1,mul2=1,p1a=0,p2a=0,p1b=0,p2b=0; for(rgi i=5,p=0;i&lt;=n;) { while((book||p*3&lt;=i||(p1a*(mul1+1)%mod1!=p1b)||(p2a*(mul2+1)%mod2!=p2b))&amp;&amp;p&lt;=n/2) { // 双哈希求下一个 ABAB 型的 AB 串的长度 book=0,++p; ((p1a*=27)+=s[p]-'a'+1)%=mod1; ((p2a*=27)+=s[p]-'a'+1)%=mod2; ((p1b*=27)+=s[p*2-1]-'a'+1)%=mod1; ((p2b*=27)+=s[p*2-1]-'a'+1)%=mod2; ((p1b*=27)+=s[p*2]-'a'+1)%=mod1; ((p2b*=27)+=s[p*2]-'a'+1)%=mod2; (mul1*=27)%=mod1; (mul2*=27)%=mod2; } if(p&gt;n/2) break; // p&gt;n/2 就说明再无 ABAB 式的串了 i=std::max(i,p*2+1); // A 串长度至少为1，所以上面求出的 ABAB 串后面再跟上个 A 的长度至少为 2p+1 if(s[i]==s[i-p*2]) ans[i++]=1; // 判断是否为合法的 ABABA 串 else book=1; // 不合法那么这个 ABAB 串就不可能有与它匹配合法的 ABABA 串了，所以要 ++p } } signed main() { // freopen(&quot;nico.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;nico.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%s&quot;,s2+1),n=strlen(s2+1); for(rgi i=1;i&lt;=n;++i) s[i]=s2[n-i+1]; work(); rgi q,t; fin&gt;&gt;q; while(q--) fin&gt;&gt;t,puts(ans[n-t+1]?&quot;niconiconi&quot;:&quot;no&quot;); return 0; } T3 雨中冒险 咕咕咕 ","link":"https://imzzy1201.github.io/post/2rSfiSPRw/"},{"title":"关于平衡树","content":" Never trouble trouble till trouble troubles you. 声明：跟那篇神贴没有任何关系（雾 此篇用来总结我学过的各种各样的自平衡二叉查找树。 平衡树 一般大家所说的平衡树指的一类优化的二叉查找树。一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了平衡树。平衡指所有叶子的深度趋于平衡，能在非常优的 O(log⁡n)\\mathcal{O}(\\log n)O(logn) 时间内完成对一个数列完成插入、删除、查询前驱后继和排名等操作。 狭义的平衡树指任意节点的左右子树高度差不大于 111 的二叉查找树。满足狭义平衡树性质的数据结构其实很少，基本上只有 AVL。 广义的平衡树把狭义平衡树推广为，对于一系列的操作，可以实现 严格/期望/均摊 O(log⁡n)\\mathcal{O}(\\log n)O(logn) 的优化二叉查找树。广义平衡树的种类就很多了，比如红黑树、伸展树、树堆、替罪羊树、加权平衡树等等。 此篇中以后出现的“平衡树”将均指广义平衡树。 概述 大部分平衡树是基于三类操作的： 旋转 大致来说，旋转就是指将一个节点“转”到它的父节点，而这个父节点则被贬为了它的子节点。这个操作后面会重点讲的。事实上，只有很少的个别几种平衡树不是使用旋转来保证复杂度的。 重构 重构指的就是对一个子树重新构建，使得这个子树内部平衡。 分裂、合并 致敬 fhq-treap 先简述一下将要介绍的和不准备介绍的那些平衡树的特征。 树堆 树堆（Treap）是一种基于旋转的二叉查找树。可以说它是一种支持动态插入的笛卡尔树。对于每个关键字，都会对应一个“优先级”。Treap 这个名字其实就是由 Tree 和 Heap 合成的，它通过旋转来同时维护两个性质：1. 关键字满足二叉查找树的性质；2. 优先级满足堆的性质。关键字的优先级取随机数可以使 Treap 的操作达到期望 O(log⁡n)\\mathcal{O}(\\log n)O(logn)。 Treap 的思想清晰、简单，实现与普通的二叉查找树区别较小，代码量较小（与普通二叉查找树只在插入、删除中有少量差别），而且从真实效率上来讲非常优秀。推荐初学平衡树的同学最先接触 Treap。 FHQ-Treap FHQ-Treap 是 FHQ（范浩强）神犇发明的一种基本思想与 Treap 相同的平衡树。它同样要求维护关键字的二叉查找树性质和优先级的堆性质。与普通 Treap 不同的是，它使用另一种操作——分裂、合并，来完成这个性质的维护。它的效率与 Treap 相近；因其独特的分裂、合并操作而使它实现中可以简化一些二叉查找树的基本操作，所以代码量也较小；然后另一个非常重要的地方是它能可持久化（许多基于旋转的平衡树并不易于函数式编程），大部分“可持久化平衡树”都是用它作为原型实现的。 伸展树 伸展树（Splay）也是一一种基于旋转的二叉查找树。它的基本思想是在每一次操作后将被操作的节点通过一系列的旋转转到根节点。利用势能分析可以证明其复杂度是均摊 O(log⁡n)\\mathcal{O}(\\log n)O(logn) 的（或者说能花费 O(mlog⁡n)\\mathcal{O}(m\\log n)O(mlogn) 的时间完成 mmm 次操作）。 Splay 的核心操作就是伸展（splay），它可以分为“双旋”和“单旋”，事实上“单旋”的伸展操作复杂度不能保证均摊 O(log⁡n)\\mathcal{O}(\\log n)O(logn)。 Splay 的常数会比 Treap 略大；但因其核心操作 splay 非常灵活，所以在许多地方都有无法的用处；实现也并不复杂。推荐学完 Treap 后紧接着就可以学 Splay 了。 替罪羊树 替罪羊树则是少数几个基于重构的平衡树之一。它的本质思想就是碰到非常不平衡的节点就拍扁重建。它的核心是“非常不平衡”的定义、“替罪羊节点”（即要对其子树进行重构的节点）的定义和排便重构的过程。 与 Treap 类似的，除了插入、删除，替罪羊树的操作也都与普通二叉查找树相同；从代码实现上来说会稍微复杂一点；效率还未知（待补） 朝鲜树 名字是个幌子（雾 朝鲜树完全可以看作简化+劣化的替罪羊树，其时间复杂度无法保证任何形式的 O(log⁡n)\\mathcal{O}(\\log n)O(logn)，没啥学的意义。 AVL 树 AVL 树是最先提出来的平衡树了，也是狭义平衡树的代表。它通过一系列的旋转操作保证了二叉搜索树严格平衡。它通过引入“平衡因子”（即左右子树高度差），从深到浅对平衡性不正确的节点（即平衡因子为 ∓2\\mp2∓2 的节点）执行“AVL旋转”来使它恢复平衡。 这种爷爷辈平衡树在实用中并不常见，但具有非常高的理论价值。 红黑树 大名鼎鼎的红黑树（RBT），可以算最快的一种平衡树了。简单来说，它将所有节点分为了红、黑两种，红黑两类节点间满足一些性质。通过用旋转维护这些性质，可以使红黑树的最深的叶节点和最浅的叶节点的深度比在 12∼2\\dfrac{1}{2}\\sim221​∼2 之间。对一次插入，红黑树会至多更改 O(log⁡n)\\mathcal{O}(\\log n)O(logn) 个节点的颜色和进行 222 次旋转；对一次删除，红黑树也至多更改 O(log⁡n)\\mathcal{O}(\\log n)O(logn) 个节点的颜色、进行 333 次旋转。 然而，红黑树的实现非常复杂，不适合运用在算法竞赛中。 当然，红黑树在工程里的用途还是很广泛的。比如 C++ 的 STL 中 set 和 map 就是用红黑树实现的，Linux 系统的进程管理、内存管理也用到了红黑树。同时，红黑树也经常用在函数式编程中。 AA 树 AA 树是红黑树的一个变种，其简化了红黑树的实现方法。它最鲜明的特征就是所有红节点都不是左儿子，这个性质使得它实现起来更加简便 左偏红黑树 左偏红黑树（LLRB）也是红黑树的一个变种，它也是对红点的位置做了一些限制，使其较普通红黑树而言更容易实现。 加权平衡树 加权平衡树（Weight-Balanced Binary Trees, WBTs）通过与 AVL 树类似的操作维护使得所有节点的左右子树节点数的比值不超过一个常数 α (α&lt;1−12)\\alpha\\ (\\alpha&lt;1-\\dfrac{1}{\\sqrt{2}})α (α&lt;1−2​1​) B 树 B 树本来是平衡的多叉树，但也可以以二叉查找树的形式出现。其应用大多在数据库和文件系统上。 2-3 树，2-3-4 树 都是特例化的 B 树。 节点大小平衡树 就是神贴里争论的是否属于平衡树的那个可怜的数据结构（雾 节点大小平衡树（SBT）用旋转维护“节点大小”平衡，被其发明人陈启峰称为“目前为止速度最快的高级二叉搜索树”，但真实性存疑，并且可能退化。 平衡树基础 二叉查找树 这算是前置知识了，这里不再详述。大部分平衡树的操作还是跟普通二叉查找树紧密结合的，少部分因其独特的操作和性质，所以也可以将二叉查找树的基本操作简化一些。 这里先给出几个二叉查找树重要的操作定义以便讲解后面平衡树的几个基本定义和操作。 节点： 我们一般将节点定义在结构体中，最常规的二叉查找树将维护以下几个值： father 指向父节点 child[2] 指向两个子节点，000 是左儿子 111 是右儿子（没有子节点就指向空） value 即节点的权值（即需要维护其满足二叉查找树性质的值） count 即节点的值出现的次数（比如树中插入了 222 次 666 那么 value 值为 666 的节点 count 就应该是 222） size 即节点的子树中所有值出现次数的和（或者说子树中所有节点的 count 和） 子节点方向 我也不知道怎么描述，意思就是 son(p) 返回的是 ppp 是其父节点的哪个儿子，000 是左儿子 111 是右儿子。 新节点： newnode(f,v) 指构造一个新的节点，其父节点为 fff，值为 vvv。 连接： connect(p,f,d) 值将节点 ppp 设为节点 fff 的 child[d]。 更新节点信息 pushup(p) 指通过 ppp 的两个子节点来更新 ppp 的 size。 上面几个定义、操作都很简单，不作解释了，直接给出代码 int root,sum; // root 记根，sum 记已经用过的节点个数 struct NODE{int val,cnt,siz,fa,ch[2];}t[maxn]; // 节点的父子指针用数组模拟了 inline int newnode(int f,int v) { t[++sum].fa=f,t[sum].ch[0]=t[sum].ch[1]=0; t[sum].cnt=t[sum].siz=1,t[sum].val=v; return sum; // 返回的是新节点的编号 } inline int son(int p) {return t[t[p].fa].ch[1]==p;} inline void connect(int p,int f,int d) {t[p].fa=f,t[f].ch[d]=p;} inline void pushup(int p) {t[p].siz=t[t[p].ch[0]].siz+t[t[p].ch[1]].siz+t[p].cnt;} 旋转 太多平衡树基于旋转了，旋转是这些平衡树最基础也是最重要的操作之一，所以这里先把它提出来单独讲。 定义 我们先看旋转的定义。许多文献里将旋转分为左旋（zig）、右旋（zag），其实这样分是没有必要的，这里将全部归为一种 rotate(p)，表示的是将 ppp 转至其父节点的位置。 我们先看图： 图中 A,B,CA,B,CA,B,C 所在的位置代表几个不知名的分别以 A,B,CA,B,CA,B,C 为根子树，旋转的过程并不会改变他们内部结构。rotate(p) 时，我们将 ppp 转到了原本 fff 所在的位置，而 fff 则代替 BBB 作为 ppp 的一个子节点，而 BBB 则代替 ppp 作为 fff 的一个子节点。 这样的旋转有两个重要的特征：一是仍然满足二叉查找树的性质，因为破坏二叉查找树的性质的方法是绝对不可取的，所以这一点异常重要；二是它会使得一些节点的深度增加，另一些节点深度减小，这个特征则保证了这个操作可以对树的平衡性作出贡献。 实现 再来看实现： 我们发现在 rotate 的过程中，有这三条边被砍断了： 砍断后成了这样： 取而代之的，是新连接的三条边 g→p, p→f, f→Bg\\to p,\\ p\\to f,\\ f\\to Bg→p, p→f, f→B： 在程序中，我们不需要体现“砍断”这个操作，因为“连接”的操作相当于已经先将原本的边砍断了。 所以我们先要这执行三次 connect，具体来说是若设旋转前的时候 s1=son(p),s2=son(f)，则我们需要执行 connect(B,f,s1),connect(f,p,s1^1),connect(p,g,s2)（其中 ^ 代表异或） 同时我们发现旋转之后 ppp 和 fff 的 size 会发生改变，所以要执行 pushup(f),pushup(p)（注意这里顺序不能颠倒） 给出 rotate 代码： inline void rotate(int p) { int f=t[p].fa,g=t[f].fa,s1=son(p),s2=son(f); connect(t[p].ch[s1^1],f,s1),connect(f,p,s1^1),connect(p,g,s2); pushup(f),pushup(p); if(root==f) root=p; } Treap 思想 Treap 是由 Raimund G. Seidel 和 Cecilia Rodriguez Aragon 于 1989 年在他们的论文 &quot;Randomized Search Trees&quot; 中最先提出的。其命名旨在“Tree+Heap”（这也充分体现了 Treap 的性质）。他们在这篇论文中对 Treap 的理论和实现有详尽的说明，对其复杂度也有严格证明。 Treap 的精髓在于多维护的一个值——优先级 （pri）。Treap 要求节点优先级满足堆的性质，正式是基于随机化的优先级，Treap 才有了期望 O(log⁡n)\\mathcal{O}(\\log n)O(logn) 的良好时间复杂度。 举个例子，下面的图里节点中黑色的数表示权值 value，旁边蓝色的数表示优先级 pri。其中只有第一棵树满足 Treap 的性质。 可以观察到 对于每个新插入的节点，Treap 都将赋予它一个随机优先级，Treap 先按照二叉查找树的正常方式插入这个节点，再通过一系列旋转操作来恢复 Treap 中优先级的堆性质。 虽说 Treap 是有可能退化为所有操作线性时间的，但因为随机化的保障，这的可能性微乎其微，而在大部分情况下 Treap 不仅能保证复杂度，而且常数还较小。 实现 说说 Treap 的核心思想“通过一系列旋转操作来恢复 Treap 中优先级的堆性质”（这里将直接称其为“treap 操作”）。 其实 treap 操作很简单，假设我们插入到的这个节点为 ppp，Treap 对优先级 证明 ","link":"https://imzzy1201.github.io/post/CtWUUv1It/"},{"title":"20200717 校内测试订正","content":" The worst nightmare is that you achieve nothing in your life and manage to believe it's a blessing to be common. 1. 概况 屑题，全是屑题 2. 题解 测试资源链接（校内题库，不公开密码） T1 滞空 题面（暂无） 思路 不会，不做了。 我讨厌把物理题强套一个空壳然后就当信息竞赛题来出❌ Code 就放 std 在这了。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long LL; const LL mod = 998244353; inline void rd(LL &amp;x) { x=0;int f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-') f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} x=x*f; } LL n,m,x[2],y[2],g,ans; LL qpow(LL a) { LL res=1,k=mod-2; a%=mod; while(k) { if(k&amp;1)res=res*a%mod; // assert(res&gt;=0); a=a*a%mod; k&gt;&gt;=1; } return res; } LL _2 = qpow(2); void down(LL x,LL h){ x%=mod;h%=mod; // assert(x*x%mod&gt;=0); assert(x*x%mod*m%mod&gt;=0);assert((x*x%mod*m%mod)*qpow(4*h));assert(qpow(4*h)&gt;=0); ans += (x*x%mod*m%mod)*qpow(4*h); ans%=mod; } void up(LL x,LL h) { x%=mod;h%=mod; // assert(m*h%mod&gt;=0); assert(x*x%mod*m%mod&gt;=0); assert((x*x%mod*m%mod)*qpow(4*h));assert(qpow(4*h)&gt;=0); assert((m*h%mod) + ( (x*x%mod*m%mod) *qpow(4*h) )%mod&gt;=0); ans += (m*h%mod) + ( (x*x%mod*m%mod) *qpow(4*h) )%mod; ans%=mod; } void pi_4(LL x){ x%=mod; // assert(m*x%mod&gt;=0); ans += (m*x%mod)*_2; ans%=mod; } void solve() { scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;g); rd(x[1]); rd(y[1]); for(int i=2;i&lt;=n;i++) { rd(x[i&amp;1]); rd(y[i&amp;1]); if(y[i&amp;1]&gt;y[!(i&amp;1)]) up(x[i&amp;1]-x[!(i&amp;1)],y[i&amp;1]-y[!(i&amp;1)]); if(y[i&amp;1]&lt;y[!(i&amp;1)]) down(x[i&amp;1]-x[!(i&amp;1)],y[!(i&amp;1)]-y[i&amp;1]); if(y[i&amp;1]==y[!(i&amp;1)]) pi_4(x[i&amp;1]-x[!(i&amp;1)]); } printf(&quot;%lldJ&quot;,ans*g%mod); } int main() { // freopen(&quot;jump.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;jump.out&quot;,&quot;w&quot;,stdout); solve(); fclose(stdin); fclose(stdout); return 0; } T2 放爆竹 题面（暂无） by the way，题面描述是有误的。如果有两串雷完全相同那这整个题都 GG 了。 思路 大概就是求两两间最大的 LCP。 首先，可以看到答案一定是不大于 2m2m2m 的。证明大概就是如果两个串长度分别为 a,b (a&gt;b)a,b\\ (a&gt;b)a,b (a&gt;b)，如果它们循环后的 LCP 大于 2a2a2a 的话，那两串都必定有周期 gcd⁡(a,b)\\gcd(a,b)gcd(a,b)。 因此我们可以将所有串循环至其长度为 1000，然后插入 Trie 中。答案即为 Trie 中最深的有 2 个 子节点的节点的深度。 Code #include&lt;bits/stdc++.h&gt; namespace imzzy{ #define endl '\\n' #define ccf std::cout&lt;&lt;&quot;f**k&quot;&lt;&lt;endl #define rgi register int #define ll long long class fastin{private:int _ch,_f; public:inline fastin&amp;operator&gt;&gt;(char&amp;c){c=getchar();return*this;} template&lt;typename _Tp&gt;inline fastin&amp;operator&gt;&gt;(_Tp&amp;_x){ _x=0;while(!isdigit(_ch))_f|=(_ch==45),_ch=getchar(); while(isdigit(_ch))_x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0);return*this;}fastin(){_ch=_f=0;} }fin;class fastout{private:int _num[32],_head; public:inline fastout&amp;operator&lt;&lt;(char c){putchar(c);return*this;} template&lt;typename _Tp&gt; inline fastout&amp;operator&lt;&lt;(_Tp _x){ _Tp _k;if(_x==0){putchar('0');return *this;}if(_x&lt;0)putchar('-'),_x=-_x; while(_x&gt;0)_k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0)putchar(_num[_head]),--_head;return*this;}fastout(){_head=0;} }fout;inline void P_INIT(){ #ifdef D_STDOUT_UNBUFFERED setbuf(stdout,NULL); #endif }}using namespace imzzy; // ---------------------------- // #define int ll // using namespace std; const int maxn=20004,maxm=1001; const int mod=239999999,inf=239999999; char s[maxn][maxm]; int len[maxn]; class TRIE{ // 最常规的 Trie public: int ch[2][maxn*maxm],cnt,res; inline void insert(const char *str) { int now=0; for(rgi i=0;i&lt;maxm;++i) { if(!ch[str[i]-'0'][now]) ch[str[i]-'0'][now]=++cnt,res=std::max(res,(ch['1'-str[i]][now])?i:0); now=ch[str[i]-'0'][now]; } } inline int query() {return res;} TRIE() {res=0,ch[0][0]=ch[1][0]=0;} }trie; signed main() {P_INIT(); // freopen(&quot;bomb.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;bomb.out&quot;,&quot;w&quot;,stdout); int n; fin&gt;&gt;n; for(rgi i=1;i&lt;=n;++i) { scanf(&quot;%s&quot;,s[i]),len[i]=strlen(s[i]); for(rgi j=0;j&lt;maxm;++j) s[i][j]=s[i][j%len[i]]; // 重复到长度为 1000 trie.insert(s[i]); } fout&lt;&lt;trie.query(); return 0; } // ---------------------------- // by imzzy T3 pyy整队 题面（暂无） by the way，题面描述还是有误的。“询问学生”本意指的“向 pyy 询问的学生”，而非“pyy 给出的答案对应的学生”，如此一说那岂不是输出 -1 就代表问 pyy 的不是个学生喽？（队首学生被剥夺学籍.jpg） 思路 用线段树维护区间最小值、平衡树（map）维护每个人站的位置（即对应下标）；从 111 到询问位置 −1-1−1 的位置之间年级排名最小的即为询问的答案。 第二问求至少移动多少位同学，使得队伍整齐，其实也就是所有连续 nnn 个位置中空缺最少的地方，然后枚举即可。 Code #include&lt;bits/stdc++.h&gt; namespace imzzy{ #define endl '\\n' #define ccf std::cout&lt;&lt;&quot;f**k&quot;&lt;&lt;endl #define rgi register int #define ll long long class fastin{private:int _ch,_f; public:inline fastin&amp;operator&gt;&gt;(char&amp;c){c=getchar();return*this;} template&lt;typename _Tp&gt;inline fastin&amp;operator&gt;&gt;(_Tp&amp;_x){ _x=0;while(!isdigit(_ch))_f|=(_ch==45),_ch=getchar(); while(isdigit(_ch))_x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0);return*this;}fastin(){_ch=_f=0;} }fin;class fastout{private:int _num[32],_head; public:inline fastout&amp;operator&lt;&lt;(char c){putchar(c);return*this;} template&lt;typename _Tp&gt; inline fastout&amp;operator&lt;&lt;(_Tp _x){ _Tp _k;if(_x==0){putchar('0');return *this;}if(_x&lt;0)putchar('-'),_x=-_x; while(_x&gt;0)_k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0)putchar(_num[_head]),--_head;return*this;}fastout(){_head=0;} }fout;inline void P_INIT(){ #ifdef D_STDOUT_UNBUFFERED setbuf(stdout,NULL); #endif }}using namespace imzzy; // ---------------------------- // #define int ll // using namespace std; const int maxn=200004; const int mod=1000000007,inf=1201201201; int a[maxn]; class segment_tree{ #define mid ((l+r)&gt;&gt;1) private: std::map&lt;int,int&gt; pos; int size,qp,qv,*A,val[maxn&lt;&lt;2],indx; inline void pushup(int p) {val[p]=std::min(val[p&lt;&lt;1],val[p&lt;&lt;1|1]);} void build(int p,int l,int r) { if(l==r) return val[p]=A[l],void(); build(p&lt;&lt;1,l,mid),build(p&lt;&lt;1|1,mid+1,r),pushup(p); } inline void modify(int p,int l,int r) { // 单点修改 qp 位置的值为 qv if(l==r) return val[p]=qv,void(); if(qp&lt;=mid) modify(p&lt;&lt;1,l,mid); else modify(p&lt;&lt;1|1,mid+1,r); pushup(p); } inline int query(int p,int l,int r) { // 区间查询 1~qp 的最小值 if(r&lt;=qp) return val[p]; if(qp&lt;=mid) return query(p&lt;&lt;1,l,mid); else return std::min(query(p&lt;&lt;1,l,mid),query(p&lt;&lt;1|1,mid+1,r)); } public: inline void build(int siz,int *k) { indx=size=siz,A=k,build(1,1,maxn-2); for(rgi i=1;i&lt;=size;++i) pos[A[i]]=i; } inline void update(int v) { qp=pos[v],qv=inf,modify(1,1,maxn-2); qp=++indx,qv=v,modify(1,1,maxn-2); pos[v]=qp; } inline int query(int v) { if(!pos.count(v)||pos[v]==1) return -1; qp=pos[v]-1; int res=query(1,1,maxn-2); return res&lt;inf?res:-1; } inline int query(int *tmp) { // tmp 只是个辅助数组（托） for(rgi i=1;i&lt;=indx;++i) tmp[i]=0; for(std::map&lt;int,int&gt;::iterator it=pos.begin();it!=pos.end();++it) tmp[(*it).second]=1; int now=0,res=inf; for(rgi i=1;i&lt;size;++i) now+=tmp[i]; for(rgi i=size;i&lt;=indx;++i) now+=tmp[i]-tmp[i-size],res=std::min(res,size-now); return res; } #undef mid }sgt; signed main() {P_INIT(); // freopen(&quot;queue.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;queue.out&quot;,&quot;w&quot;,stdout); rgi n,m,t; fin&gt;&gt;n&gt;&gt;m; for(rgi i=1;i&lt;=n;++i) fin&gt;&gt;a[i]; sgt.build(n,a); while(m--) { char c=' '; while(!isalpha(c)) c=getchar(); fin&gt;&gt;t; if(c=='A') fout&lt;&lt;sgt.query(t)&lt;&lt;endl; else sgt.update(t); } fout&lt;&lt;sgt.query(a); return 0; } // ---------------------------- // by imzzy 3. 总结 我觉得这不是我的问题，是题目的问题。 真心厌恶今天这样的题目❌ ","link":"https://imzzy1201.github.io/post/SJg1NdVND/"},{"title":"20200715 校内测试订正","content":" Some people seem to have everything. In fact, they do have everything. 1. 概况 T1 53pts 我 sb 了。 T2 44pts 我 sb 了。 T3 0pts 完全不会。🙃 总分连三位数都没有，sb 实锤。 2. 题解 测试资源链接（校内题库，不公开密码） T1 简单棋盘问题 题面（暂无） 思路 考虑到其相当于求所有国王到目标位置的切比雪夫距离，而我们知道切比雪夫距离是可以转化为曼哈顿距离的。 举个例子下面坐标系中有 A,BA,BA,B 两点： 那么他们的切比雪夫距离就是 max⁡(∣xA−xB∣,∣yA−yB∣)=max⁡(∣1−5∣,∣4−2∣)=4\\max(|x_A-x_B|,|y_A-y_B|)=\\max(|1-5|,|4-2|)=4max(∣xA​−xB​∣,∣yA​−yB​∣)=max(∣1−5∣,∣4−2∣)=4（即红橙两段中较长的橙线段的长度） 它们的曼哈顿距离则为 ∣xA−xB∣+∣yA−yB∣=∣1−5∣+∣4−2∣=6|x_A-x_B|+|y_A-y_B|=|1-5|+|4-2|=6∣xA​−xB​∣+∣yA​−yB​∣=∣1−5∣+∣4−2∣=6（即红橙两线段长度和 这两种距离看起来没啥关系，其实却有很大的联系。 考虑旋转坐标轴，逆时针饶原点旋转 45°，也就是转到了这里： 在新的坐标轴上我们对两点求曼哈顿距离（即紫色折线的总的长度） 我们发现此时的曼哈顿距离 424\\sqrt{2}42​ 正好是原来的切比雪夫距离 444 的 2\\sqrt{2}2​ 倍。 多试几个点可以发现，这个结论是恒成立的。这个结论也不难证明，带入坐标推式子即可说明正确性。下面主要说的是实现方法。 实现的时候，可以直接将所有点（包括询问的点）的坐标 (x,y)(x,y)(x,y) 改成 (x+y,x−y)(x+y,x-y)(x+y,x−y)，然后求曼哈顿距离和即可。注意最终答案是这个距离和的一半。 关于求法的话，可以离散化后用树状数组对横纵坐标各维护两个值：区间内的点数和区间坐标和。统计答案时分别求大于和小于当前询问坐标的答案即可。代码应该很好懂： Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=1000004; const int mod=998244353,inf=1000000007; struct POINT{int x,y;}p[maxn]; int val0[maxn],cnt0,val1[maxn],cnt1; // 离散化用的数组 class BIT{ // 树状数组 private: ll size,val[maxn]; public: inline int lowbit(int x) {return x&amp;-x;} inline void update(int p,ll x) {while(p&lt;=size) val[p]+=x,p+=lowbit(p);} inline ll query(int p) {ll res=0; while(p&gt;0) res+=val[p],p-=lowbit(p); return res;} inline ll query(int l,int r) {return query(r)-query(l-1);} inline void build(int s) {size=s; memset(val,0,sizeof(ll)*(size+2));} }B[2],C[2]; // B 记录坐标和，C 点的个数 // 上面那些变量 0 指横坐标，1 指纵坐标 signed main() { // freopen(&quot;chess.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;chess.out&quot;,&quot;w&quot;,stdout); int n,x,y,qx,qy; ll ans=0; rgi T,q; fin&gt;&gt;T; while(T--) { cnt0=cnt1=0,fin&gt;&gt;n&gt;&gt;q; for(rgi i=1;i&lt;=n;++i) fin&gt;&gt;p[i].x&gt;&gt;p[i].y,val0[++cnt0]=p[i].x+p[i].y,val1[++cnt1]=p[i].x-p[i].y; std::sort(val0+1,val0+1+cnt0),cnt0=std::unique(val0+1,val0+1+cnt0)-val0-1; std::sort(val1+1,val1+1+cnt1),cnt1=std::unique(val1+1,val1+1+cnt1)-val1-1; B[0].build(cnt0),C[0].build(cnt0); B[1].build(cnt1),C[1].build(cnt1); // 上为离散化 for(rgi i=1,t3,t4;i&lt;=n;++i) { t3=std::lower_bound(val0+1,val0+1+cnt0,p[i].x+p[i].y)-val0; t4=std::lower_bound(val1+1,val1+1+cnt1,p[i].x-p[i].y)-val1; B[0].update(t3,p[i].x+p[i].y),C[0].update(t3,1); B[1].update(t4,p[i].x-p[i].y),C[1].update(t4,1); } // 插入树状数组 while(q--) { fin&gt;&gt;x&gt;&gt;y,ans=0; qx=std::lower_bound(val0+1,val0+1+cnt0,x+y)-val0; qy=std::lower_bound(val1+1,val1+1+cnt1,x-y)-val1; ans+=C[0].query(qx-1)*(x+y)-B[0].query(qx-1); ans+=B[0].query(qx,cnt0)-C[0].query(qx,cnt0)*(x+y); // 统计横坐标 ans+=C[1].query(qy-1)*(x-y)-B[1].query(qy-1); ans+=B[1].query(qy,cnt1)-C[1].query(qy,cnt1)*(x-y); // 统计纵坐标 fout&lt;&lt;ans/2&lt;&lt;endl; } } return 0; } // ---------------------------- // by imzzy T2 简单数据结构 题面（暂无） 思路 菜到连线段树都写挂（雾 考虑用线段树暴力维护区间最小值，然后查询的时候每次取出区间里的最小值，放入答案队列，然后删掉这个位置的值（即赋值为 inf⁡\\infinf）如果取到某个时候发现取出来的数比 xxx 还大了就说明此次询问无解。 复杂度应该是 [m+∑K]log⁡n[m+\\sum K]\\log n[m+∑K]logn，大概是 10810^8108 级别的，卡卡常就能过。 也是可以的，我一共过了两个测试点，其中一个就是大样例（雾 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll using namespace std; const int maxn=500004; const int mod=998244353,inf=2000000007; class segment_tree{ #define mid ((l+r)&gt;&gt;1) private: int size,ql,qr,qv,*A,fill[maxn&lt;&lt;2],cnt; // fill 打的是取 max 标记 pair&lt;int,int&gt; minv[maxn&lt;&lt;2],changed[maxn]; // first 维护最小值，second 维护最小值对应的下标 inline void pushup(int p) {minv[p]=min(minv[p&lt;&lt;1],minv[p&lt;&lt;1|1]);} inline void pushdown(int p,int l,int r) { if(!fill[p]) return; fill[p&lt;&lt;1]=max(fill[p],fill[p&lt;&lt;1]),fill[p&lt;&lt;1|1]=max(fill[p],fill[p&lt;&lt;1|1]); minv[p&lt;&lt;1]=max(minv[p&lt;&lt;1],make_pair(fill[p],minv[p&lt;&lt;1].second)); minv[p&lt;&lt;1|1]=max(minv[p&lt;&lt;1|1],make_pair(fill[p],minv[p&lt;&lt;1|1].second)); fill[p]=0; } void build(int p,int l,int r) { fill[p]=0; if(l==r) return minv[p]=make_pair(A[l],l),void(); build(p&lt;&lt;1,l,mid),build(p&lt;&lt;1|1,mid+1,r),pushup(p); } void modify(int p,int l,int r) { // 修改单点的值 if(l==r) return fill[p]=qv,minv[p]=make_pair(qv,l),void(); pushdown(p,l,r); if(ql&lt;=mid) modify(p&lt;&lt;1,l,mid); else modify(p&lt;&lt;1|1,mid+1,r); pushup(p); } void update_(int p,int l,int r) { // 区间取 max if(l&gt;=ql&amp;&amp;r&lt;=qr) return minv[p]=max(minv[p],make_pair(qv,minv[p].second)),fill[p]=max(fill[p],qv),void(); pushdown(p,l,r); if(ql&lt;=mid) update_(p&lt;&lt;1,l,mid); if(qr&gt;mid) update_(p&lt;&lt;1|1,mid+1,r); pushup(p); } pair&lt;int,int&gt; query(int p,int l,int r) { // 查询区间最小值 if(l&gt;=ql&amp;&amp;r&lt;=qr) return minv[p]; pushdown(p,l,r); if(qr&lt;=mid) return query(p&lt;&lt;1,l,mid); if(ql&gt;mid) return query(p&lt;&lt;1|1,mid+1,r); return min(query(p&lt;&lt;1,l,mid),query(p&lt;&lt;1|1,mid+1,r)); } public: inline void build(int siz,int *k) {A=k,size=siz,cnt=0,build(1,1,size);} inline void update(int l,int r,int v) {ql=l,qr=r,qv=v,update_(1,1,size);} inline bool query(int l,int r,int x,int k,int *ans) { bool flag=1; for(rgi i=1;i&lt;=k&amp;&amp;flag;++i) { ql=l,qr=r,changed[++cnt]=query(1,1,size); // 改成 inf 时要加入队列因为最后要还原的 ql=changed[cnt].second,qv=inf,modify(1,1,size); if(changed[cnt].first&lt;x) ans[i]=changed[cnt].first; else flag=0; } while(cnt) ql=changed[cnt].second,qv=changed[cnt--].first,modify(1,1,size); return flag; } #undef mid }sgt; int a[maxn]; signed main() { // freopen(&quot;segtree.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;segtree.out&quot;,&quot;w&quot;,stdout); int n,m,op,l,r,x,k; fin&gt;&gt;n; for(rgi i=1;i&lt;=n;++i) fin&gt;&gt;a[i]; sgt.build(n,a); for(fin&gt;&gt;m;m;--m) { fin&gt;&gt;op; if(op==1) fin&gt;&gt;l&gt;&gt;r&gt;&gt;x,sgt.update(l,r,x); else{ fin&gt;&gt;l&gt;&gt;r&gt;&gt;x&gt;&gt;k,op=sgt.query(l,r,x,k,a); if(op) {for(rgi i=1;i&lt;=k;++i) fout&lt;&lt;a[i]&lt;&lt;' '; fout&lt;&lt;endl;} else fout&lt;&lt;-1&lt;&lt;endl; } } return 0; } // ---------------------------- // by imzzy T3 简单树上路径 题面（暂无） 思路 神仙题 这题要把它转化为二分图匹配的模型。 首先倍增求出这几个点的 LCA（即他们集合的点），然后同样用 bitset 倍增求出每个人能拿到的特产。 考虑如何验证每个人买 xxx 个特产是否有方案。可以建立二分图，左边 c×xc\\times xc×x 个节点，右边 mmm 个节点。左边的 c×xc\\times xc×x 个节点代表共 ccc 个人，每个人有 xxx 个节点，即要选 xxx 种特产；右边 mmm 个节点代表 mmm 种特产。每个的拥有的节点都与它能拿到的特产连边，然后跑二分图匹配。如果最大匹配刚好是 c×xc\\times xc×x 就说明每个人都能选出 xxx 个特产且互不相同，即有解，否则无解。 根据 Hall 定理，记这 ccc 个人构成的集合为 SSS，则有 xmax⁡=min⁡(f(S′)/∣S′∣) (S′∈S)x_{\\max}=\\min(f(S&#x27;)/|S&#x27;|)\\ (S&#x27;\\in S)xmax​=min(f(S′)/∣S′∣) (S′∈S)，其中 f(S′)f(S&#x27;)f(S′) 代表 S′S&#x27;S′ 中所有人能拿到的特产的总种数。 最后注意到题目中毒瘤的 256M256M256M 空间限制，直接开 20×30000020\\times 30000020×300000 个 bitset 倍增会挂空间，所以要询问离线，然后一层一层计算倍增 2i2^i2i 次，并同时计算这一层倍增对每次询问的每个人的贡献。 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=300004,maxq=50004,maxm=1004; const int mod=998244353,inf=1000000007; int anc[20][maxn],dep[maxn],c[maxq],v[6][maxq]; std::bitset&lt;maxm&gt; f[maxn],g[maxn],p[6][maxq],tmp; // f 记录第 i 次倍增的结果，g 则是第 i-1 次 inline int LCA(int p,int q) { if(dep[p]&lt;dep[q]) std::swap(p,q); for(rgi i=19;i&gt;=0;--i) if(dep[q]&lt;=dep[p]-(1&lt;&lt;i)) p=anc[i][p]; if(p==q) return p; for(rgi i=19;i&gt;=0;--i) if(anc[i][p]!=anc[i][q]) p=anc[i][p],q=anc[i][q]; return anc[0][p]; } signed main() { // freopen(&quot;travel.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;travel.out&quot;,&quot;w&quot;,stdout); int n,m,q,t,ans; fin&gt;&gt;n&gt;&gt;m&gt;&gt;q; anc[0][1]=dep[1]=1; for(rgi i=2;i&lt;=n;++i) fin&gt;&gt;anc[0][i],dep[i]=dep[anc[0][i]]+1; for(rgi i=1;i&lt;=n;++i) fin&gt;&gt;t,g[i][t]=1; for(rgi i=1;i&lt;=n;++i) f[i]=g[anc[0][i]]; // 先初始化好第 0 层倍增的结果 for(rgi j=1;j&lt;20;++j) for(rgi i=1;i&lt;=n;++i) anc[j][i]=anc[j-1][anc[j-1][i]]; for(rgi i=1;i&lt;=q;++i) {fin&gt;&gt;c[i]; for(rgi j=1;j&lt;=c[i];++j) fin&gt;&gt;v[j][i],p[j][i]=g[v[j][i]]; v[0][i]=v[1][i]; for(rgi j=2;j&lt;=c[i];++j) v[0][i]=LCA(v[j][i],v[0][i]); } for(rgi k=0;k&lt;20;++k) { for(rgi i=1;i&lt;=q;++i) for(rgi j=1;j&lt;=c[i];++j) if((dep[v[j][i]]-dep[v[0][i]])&amp;(1&lt;&lt;k)) // 二进制分解当前节点到目标节点的深度差，即可判断是否用到了这一层倍增 p[j][i]|=f[v[j][i]],v[j][i]=anc[k][v[j][i]]; memcpy(g,f,sizeof(f)); for(rgi i=1;i&lt;=n;++i) f[i]=g[i]|g[anc[k][i]]; } for(rgi k=1;k&lt;=q;++k) { ans=inf; for(rgi i=1;i&lt;1&lt;&lt;c[k];++i) {tmp=0; for(rgi j=1;j&lt;=c[k];++j) if(i&amp;(1&lt;&lt;(j-1))) tmp|=p[j][k]; ans=std::min(ans,(int)tmp.count()/__builtin_popcount(i)); } fout&lt;&lt;(ans*c[k])&lt;&lt;endl; } return 0; } // ---------------------------- // by imzzy 3. 总结 实力是硬伤。😟 依然是前两题都想到了，都码挂了，最后一题压根不会。 继续努力吧。 ","link":"https://imzzy1201.github.io/post/1iyhTQXar/"},{"title":"20200713 校内测试订正","content":" I may not be able to change the past, but I can learn from it. 1. 概况 T1 100pts 挺简单没啥问题。 T2 90pts 码错了好几个地方竟然还能这么高？？？ T3 0pts 差一行就切了。🙃 T4 0pts 不会。 总分 190pts，差。 2. 题解 测试资源链接（校内题库，不公开密码） T1 变换序列 题面（luogu） 前置知识 二分图匹配（匈牙利和网络瘤都可以） 思路 先考虑数 iii 能放的位置，其下标（从 000 开始）只可能为 (i+Di) mod N(i+D_i)\\bmod N(i+Di​)modN 和 (i−Di) mod N(i-D_i)\\bmod N(i−Di​)modN，每个数只能放一个位置，而每个位置也只能放一个数。所以可以规约成完美匹配问题，即用下标与数字匹配，数字 iii 向下标 (i±Di) mod N(i\\pm D_i)\\bmod N(i±Di​)modN 连边，跑二分图匹配，如果没有完美匹配就相当于无解。 另一个问题是要求输出字典序最小的一组解，考虑到匹配过程是每次尝试增广。因为我们希望越小的数字越往前放，所以我们希望它靠后开始增广。这一点不难理解。同时，在一次增广中，也应该先尝试从下标较小的位置开始。可以用反证法证明这个策略的正确性 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long // ---------------------------- // #define int ll using namespace std; const int maxn=10004; const int mod=998244353,inf=1000000007; inline int read() { int x=0,f=0,ch=0; while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); return f?-x:x; } vector&lt;int&gt; mp[maxn]; int match[maxn]; bool vis[maxn]; bool dfs(int p) // 匈牙利算法 { for(unsigned rgi i=0,v;i&lt;mp[p].size();++i) { v=mp[p][i]; if(vis[v]) continue; vis[v]=1; if(match[v]==-1||dfs(match[v])) return match[v]=p,1; } return 0; } int a[maxn],ans[maxn]; signed main() { // freopen(&quot;transform.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;transform.out&quot;,&quot;w&quot;,stdout); int n=read(); for(rgi i=0;i&lt;n;++i) { a[i]=read(); mp[i].push_back((i+a[i])%n); mp[i].push_back((i-a[i]+n)%n); sort(mp[i].begin(),mp[i].end()); } memset(match,-1,sizeof(match)); for(rgi i=n-1;i&gt;=0;--i) { memset(vis,0,sizeof(vis)); if(!dfs(i)) {puts(&quot;No Answer&quot;); return 0;} // 无法增广即说明无解 } for(rgi i=0;i&lt;n;++i) ans[match[i]]=i; // 注意答案不直接为这个匹配，这个匹配是数与下标的对应而非下标与数的对应，所以要反过来一下 for(rgi i=0;i&lt;n;++i) printf(&quot;%d &quot;,ans[i]); return 0; } // ---------------------------- // by imzzy T2 最大子图 题面（luogu） 前置知识 缩点（tarjan 算法） 拓扑排序 DAG 上 DP 思路 题目要求“最大半连通导出子图的节点数”及“并列最大半连通导出子图的个数”。先观察半连通图的性质，我们发现一个图是半连通图当且仅当图中存在一条路径能经过所有节点。这个结论也比较显而易见。 然后，继续结合强连通分量的很好的性质：强连通分量内任意两点 u,vu,vu,v 间存在至少一条有向路径。也就是说一条路径只要进了强连通分量就可以走完这个分量里的所有点，再从任何一点出去。所以可以缩点，并记录编号为 iii 的强连通分量里的节点数 siz[i]siz[i]siz[i]，路径进了分量 iii 就相当于能走 siz[i]siz[i]siz[i] 个节点。 缩点之后图成了 DAG，根据套路我们将其拓扑排序并 DP。拓扑排序后，考虑按逆拓扑序动态规划以分量 iii 为起点的“最大半连通导出子图节点数”和“这样的导出子图的个数”，即可。 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long // ---------------------------- // #define int ll using namespace std; const int maxn=200004; const int mod=998244353,inf=1000000007; inline int read() { int x=0,f=0,ch=0; while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); return f?-x:x; } int n,m,p,u,v; vector&lt;int&gt; to[maxn],to2[maxn]; // to 存原图，to2 存缩点后的辅助图（用于拓扑排序和 DP） int col[maxn],siz[maxn]; // col[i] 表示 i 所在的强连通分量编号，siz[i] 表示编号为 i 的强连通分量节点数 bool vis[maxn]; int dfn[maxn],low[maxn],stk[maxn]; int dfsclock,indxs,cnt; void tarjan(int p) // 缩点 { vis[stk[++indxs]=p]=1; low[p]=dfn[p]=++dfsclock; for(rgi i=0;i&lt;to[p].size();++i) if(!dfn[to[p][i]]) tarjan(to[p][i]),low[p]=min(low[p],low[to[p][i]]); else if(vis[to[p][i]]) low[p]=min(low[p],dfn[to[p][i]]); if(low[p]==dfn[p]) { vis[p]=0,siz[col[p]=++cnt]=1; while(p!=stk[indxs]) vis[stk[indxs]]=0,++siz[cnt],col[stk[indxs--]]=cnt; --indxs; } } int ccf[maxn],topo[maxn],ip; queue&lt;int&gt; q; inline void topsort() // 拓扑排序 { for(rgi i=1;i&lt;=n;++i) for(rgi j=0;j&lt;to[i].size();++j) if(col[i]!=col[to[i][j]]) to2[col[i]].push_back(col[to[i][j]]),++ccf[col[to[i][j]]]; for(rgi i=1;i&lt;=cnt;++i) if(ccf[i]==0) q.push(i),topo[++ip]=i; int u,v; while(!q.empty()) { u=q.front(),q.pop(); for(rgi i=0;i&lt;to2[u].size();++i) if((--ccf[to2[u][i]])==0) q.push(to2[u][i]),topo[++ip]=to2[u][i]; } } pair&lt;ll,ll&gt; f[maxn]; // f[i].first 为“…的节点数”，f[i].second 为“…的个数”，其中 i 为分量编号 inline void insert(pair&lt;ll,ll&gt; &amp;a,pair&lt;ll,ll&gt; b) {if(b.first==a.first) (a.second+=b.second)%=p; if(b.first&gt;a.first) a=b;} // insert 是用 b 来更新 a set&lt;pair&lt;int,int&gt; &gt; s; inline pair&lt;ll,ll&gt; calc() { for(rgi i=1;i&lt;=cnt;++i) to2[i].clear(),f[i].second=1; // 这里要反向建图，所以清空了重来 for(rgi i=1;i&lt;=n;++i) for(rgi j=0;j&lt;to[i].size();++j) if(col[i]!=col[to[i][j]]&amp;&amp;!s.count(make_pair(col[i],col[to[i][j]]))) to2[col[to[i][j]]].push_back(col[i]),s.insert(make_pair(col[i],col[to[i][j]])); // 注意连接两分量的同一条边不能加多次，否则会多次更新 pair&lt;ll,ll&gt; res=make_pair(0,0); for(rgi i=cnt,u;i&gt;0;--i) { u=topo[i],f[u].first+=siz[u],insert(res,f[u]); for(rgi j=0;j&lt;to2[u].size();++j) insert(f[to2[u][j]],f[u]); } return res; } signed main() { // freopen(&quot;graph.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;graph.out&quot;,&quot;w&quot;,stdout); n=read(),m=read(),p=read(); for(rgi i=1;i&lt;=m;++i) u=read(),v=read(),to[u].push_back(v); for(rgi i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i); topsort(); pair&lt;ll,ll&gt; ans=calc(); printf(&quot;%lld\\n%lld&quot;,ans.first,ans.second); return 0; } // ---------------------------- // by imzzy T3 最短路 题面（DARKBZOJ） 前置知识 最短路算法（Dijkstra） 思路 先考虑连上所有存在的边（即每两个点间连两条，分别为横纵坐标的差），然后再考虑删掉无用边。分方向讨论，先看横向边，如果 iii 在 jjj 的左侧，jjj 在 kkk 的左侧，那么很明显 iii 至 kkk 的横向边是毫无意义的（因为这条边完全可以被 i→j→ki\\to j\\to ki→j→k 这条路径替代），也就是说按照横坐标排序后，横向边只用连接相邻两点即可。纵坐标同理。这样连边后边数就已经是 O(n)\\mathcal{O}(n)O(n) 级别的了，剩下就是正常求最短路即可 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long // ---------------------------- // #define int ll using namespace std; const int maxn=200004; const int mod=998244353,inf=1000000007; inline int read() { int x=0,f=0,ch=0; while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); return f?-x:x; } int n; struct EDGE{int v,nxt; ll w;}e[maxn&lt;&lt;2]; int first[maxn],cnte; inline void addedge(int p,int q,ll w) { e[++cnte].v=q,e[cnte].w=w, e[cnte].nxt=first[p],first[p]=cnte; } inline void addedge2(int p,int q,ll w) {addedge(p,q,w),addedge(q,p,w);} struct NODE{ int v; ll w; inline bool operator&lt;(const NODE &amp;a) const {return w&gt;a.w;}; NODE(int a,int b) {v=a,w=b;} }; ll dis[maxn]; bool vis[maxn]; priority_queue&lt;NODE&gt; q; ll Dij() // Dijkstra { memset(dis,0x3f,sizeof(dis)); int u,v; q.push(NODE(1,0)),dis[1]=0; while(!q.empty()) { u=q.top().v,q.pop(); if(vis[u]) continue; vis[u]=1; for(rgi i=first[u];i;i=e[i].nxt) { v=e[i].v; if(dis[v]&gt;dis[u]+e[i].w) dis[v]=dis[u]+e[i].w,q.push(NODE(v,dis[v])); } } return dis[n]; } struct POINT{int x,y,k;}p[maxn]; inline bool cmp1(POINT a,POINT b) {return a.x&lt;b.x;} inline bool cmp2(POINT a,POINT b) {return a.y&lt;b.y;} signed main() { // freopen(&quot;dist.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;dist.out&quot;,&quot;w&quot;,stdout); n=read(); for(rgi i=1;i&lt;=n;++i) p[i].x=read(),p[i].y=read(),p[i].k=i; sort(p+1,p+1+n,cmp1); for(rgi i=1;i&lt;n;++i) addedge2(p[i].k,p[i+1].k,p[i+1].x-p[i].x); sort(p+1,p+1+n,cmp2); for(rgi i=1;i&lt;n;++i) addedge2(p[i].k,p[i+1].k,p[i+1].y-p[i].y); // 分别按横纵坐标排序后加边 printf(&quot;%lld&quot;,Dij()); return 0; } // ---------------------------- // by imzzy T4 平面图判定 题面（luogu） 前置知识 并查集 思路 首先，我们知道平面图节点数 nnn 和边数 mmm 总有 m≤3n−6m\\le3n-6m≤3n−6，因此如果给的 m&gt;3n−6m&gt;3n-6m&gt;3n−6 就可以直接断言其非平面图了。因此可以将图的边数降至 O(n)\\mathcal{O}(n)O(n) 级别。 既然题目给的是个哈密顿图，还给出了哈密顿回路，那么我们就先画出这个回路，形成一个大圈。很明显，这个图里的所有边，要么在圈内，要么在圈外，要么在圈上 （废话）。 在圈上的边不用考虑，因为说“要么在圈内，要么在圈外，要么在圈上”时已经确定了没有边穿过圈，即圈上所有边不跟其它边相交。而对于其它边，如果记 st[i]st[i]st[i] 为边 iii 在圈内的断言，st′[i]st&#x27;[i]st′[i] 为边 iii 在圈外的断言，那么如果边 i,ji,ji,j 在圈内会相交，则始终有 st[i]⇔st′[j],st[j]⇔st′[i]st[i]\\Leftrightarrow st&#x27;[j],st[j]\\Leftrightarrow st&#x27;[i]st[i]⇔st′[j],st[j]⇔st′[i] 成立。 因此我们只用将所有此类条件整合，并检查是否有矛盾即可。矛盾的形式也很容易看出来，只用判断有没有 st[i]∧st′[i]st[i]\\wedge st&#x27;[i]st[i]∧st′[i] 为真的情况，如果没有就是平面图，有则不是 至于维护这些关系，我们可以用并查集维护一些等价类。比如 st[i]⇔st′[j]st[i]\\Leftrightarrow st&#x27;[j]st[i]⇔st′[j] 就相当于 st[i]st[i]st[i] 和 st′[j]st&#x27;[j]st′[j] 在同一等价类中，即对这两个状态原处的等价类进行合并；最后对于每个 iii 再检查 st[i]st[i]st[i] 和 st′[i]st&#x27;[i]st′[i] 是否在同一等价类即可。 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long // ---------------------------- // #define int ll using namespace std; const int maxn=204,maxm=100004; const int mod=998244353,inf=1000000007; inline int read() { int x=0,f=0,ch=0; while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); return f?-x:x; } int n,m; int u[maxm],v[maxm],a[maxn],pos[maxn]; class DSU{ // 并查集 private: int fa[maxm]; public: inline void build(int siz) {for(rgi i=1;i&lt;=siz;++i) fa[i]=i;} inline int find(int p) {while(fa[p]!=p) p=fa[p]=fa[fa[p]]; return p;} inline void merge(int p,int q) {fa[find(p)]=find(q);} inline bool query(int p,int q) {return find(p)==find(q);} }dsu; signed main() { // freopen(&quot;planar.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;planar.out&quot;,&quot;w&quot;,stdout); rgi T=read(); while(T--) { n=read(),m=read(); for(rgi i=1;i&lt;=m;++i) u[i]=read(),v[i]=read(); for(rgi i=1;i&lt;=n;++i) a[i]=read(),pos[a[i]]=i; // pos[i] 为节点 i 在圈上的编号 if(m&gt;n*3-6) {puts(&quot;NO&quot;); continue;} for(rgi i=1;i&lt;=m;++i) { u[i]=pos[u[i]],v[i]=pos[v[i]]; // 改一下节点编号，方便后面判圈内两边是否交叉 if(u[i]&gt;v[i]) swap(u[i],v[i]); // 免于分类讨论 } dsu.build(m*2+1); for(rgi i=1;i&lt;=m;++i) for(rgi j=i+1;j&lt;=m;++j) { if(u[i]==u[j]||v[i]==v[j]||u[j]==v[i]||u[i]==v[j]) continue; // 有相同节点即可跳过 int a=i,b=j; if(u[a]&gt;u[b]) swap(a,b); // 免于分类讨论 if(u[b]&lt;v[a]&amp;&amp;v[a]&lt;v[b]) dsu.merge(a,b+m),dsu.merge(b,a+m); } bool flag=1; for(rgi i=1;i&lt;=m&amp;&amp;flag;++i) if(dsu.query(i,i+m)) flag=0; puts(flag?&quot;YES&quot;:&quot;NO&quot;); } return 0; } // ---------------------------- // by imzzy 3. 总结 emmmm…… 前三题都还是想到了的，但时间分配不当、实现上也有些问题，所以丢了不少分。最后一题 2-SAT 或者 DSU，这个套路没怎么做过，不太会用，平面图的性质也不知道，没想出来也算正常（?） ","link":"https://imzzy1201.github.io/post/LQUS5KCXn/"},{"title":"杂题 - CF1375F Integer Game","content":" Whatever you do, you hold on to that foolishly hopeful smile. 题面 题意简述： Anton 有 3 堆石头，分别有 a,b,ca,b,ca,b,c 个。每次操作 Harris 扔给 Anton yyy 个石头，Anton 要选择一堆扔进去，相邻两次操作 Anton 不能扔进同一堆。如果 3 堆中任意两堆的石头个数一样，Anton 输；如果 1000 轮操作 Anton 还没输，Harris 就输。 给你 a,b,ca,b,ca,b,c，让你选个人只会他赢。 前置知识 顺序结构程序设计（ ? ? ? ） 思路 我们先考虑什么时候 Anton 会挂。现在我们先假设 a&lt;b&lt;ca&lt;b&lt;ca&lt;b&lt;c，其分别对应的石子堆记为 A,B,CA,B,CA,B,C（注意 A,B,CA,B,CA,B,C 在不同轮代表的石堆也不同）下面分类讨论： Anton 上一轮没扔进 CCC 很明显他这轮选 CCC 的堆往里面扔，一定死不了。 Anton 上一轮扔进了 CCC 我们假设 c−b≠b−ac-b\\neq b-ac−b​=b−a，那么如果 k=c−bk=c-bk=c−b 就往 AAA 里扔，如果 k=b−ak=b-ak=b−a 就往 BBB 里扔，否则随便扔。 假设 c−b=b−ac-b=b-ac−b=b−a，那么只要扔给他 b−ab-ab−a 个石头 Anton 就必死无疑了 那么也就是说，只有 Anton 上一轮扔进了 CCC，并且 c−b=b−ac-b=b-ac−b=b−a，Harris 才必胜。 再往前推一步，怎么让 Anton 只能选扔进 CCC，并且 c−b=b−ac-b=b-ac−b=b−a 呢？ 一个巧妙的构造方法是，假设当前三堆石头个数分别为 a0,b0,c0 (a0&lt;b0&lt;c0)a_0,b_0,c_0\\ (a_0&lt;b_0&lt;c_0)a0​,b0​,c0​ (a0​&lt;b0​&lt;c0​)，并且上一轮 Anton 扔到了 CCC 里。如果叫 Harris 扔给 Anton 2c0−a0−b02c_0-a_0-b_02c0​−a0​−b0​ 个石头，我们发现： 如果 Anton 放进了 AAA，则新的石头个数为 b0,c0,2c0−b0b_0,c_0,2c_0-b_0b0​,c0​,2c0​−b0​，则有 c−b=b−a=c0−b0c-b=b-a=c_0-b_0c−b=b−a=c0​−b0​ 如果 Anton 放进了 BBB，则新的石头个数为 a0,c0,2c0−a0a_0,c_0,2c_0-a_0a0​,c0​,2c0​−a0​，则有 c−b=b−a=c0−a0c-b=b-a=c_0-a_0c−b=b−a=c0​−a0​ 那么这样操作就逼死 Anton 了。 最后有一个小问题，就是上面的方法中要求 Anton 前一轮扔到了 CCC 里。这也很好解决，叫 Harris 一开始就扔给 Anton 一个嘿大的数，不管怎样 Anton 扔到的堆都会成为新一轮的 CCC。 Code ll a[4]; signed main() { fin&gt;&gt;a[1]&gt;&gt;a[2]&gt;&gt;a[3]; puts(&quot;First&quot;),fflush(stdout); puts(&quot;100000000000&quot;),fflush(stdout); int t,x; fin&gt;&gt;t,a[t]+=100000000000ll; fout&lt;&lt;(3ll*a[t]-a[1]-a[2]-a[3])&lt;&lt;endl,fflush(stdout); fin&gt;&gt;x; fout&lt;&lt;a[t]-a[6-x-t]&lt;&lt;endl,fflush(stdout); fin&gt;&gt;x; return 0; } ","link":"https://imzzy1201.github.io/post/1Qf-3P6_-/"},{"title":"游记 - HBOI2020","content":" You have to work very hard to believe that you are really powerless. Day -?? 沉迷于 whk，码了几个小 DS，然后开始重写各种各样的【模板】。 Day -? 发现自己连 kmp 都忘了，然后开始恶补字符串。（虽然最后根本没考串串） 考了套模拟赛，做得还不错。 Day 0 whk 考试去了，最后晚上陪 xiong_6\\textsf{\\color{black}x\\color{red}iong\\_6}xiong_6 码了个线段树 1（听说能增加 rp ？？？）然后就睡了。 Day 1 题目还好，拿到之后扫一遍题面觉得 T1 可做，T2 说不准，T3 完全不可做。 仔细想了想 T1，想法是值域树状数组上二分，log⁡2\\log^2log2 的，但自以为常数很小能过，于是没有继续想一个 log⁡\\loglog 的解法了。 然后开始肝 T2，发现大概在寒假的时候我问过 xiong_6 差不多的题？？？然而遗憾的是那时候没做出来。于是开始尝试找规律。大概就是给定 n,kn,kn,k，尝试把 ∑i=0nikxi(ni)\\sum_{i=0}^n i^kx^i\\binom{n}{i} i=0∑n​ikxi(in​) 表示成 ∑i=n−knfixn−i∑j=0ixj(ij)\\sum_{i=n-k}^nf_ix^{n-i}\\sum_{j=0}^{i}x^j\\binom{i}{j} i=n−k∑n​fi​xn−ij=0∑i​xj(ji​) 即 ∑i=n−knfixn−i(x+1)i\\sum_{i=n-k}^nf_ix^{n-i}(x+1)^i i=n−k∑n​fi​xn−i(x+1)i 然后就开始对 {f}\\{f\\}{f} 找规律。 配合着暴力程序，估摸着找了 2h，找到了个奇奇怪怪的规律，然后码出来就过了大样例。 回头来码 T1 了，码了一半才发现常数巨大。。。但时间已经不多了，所以决定先码完 T1 log⁡2\\log^2log2 和 T3 大暴力再回头想。 于是就调了半天 T3 。。。 最后慌慌张张自己造了几个小数据拍了下 T1 T2，检查了 freopen，就考试结束了。然后发现好多人都没做出来 T2 ？？ 然后估分 Day 1 60+100+15=17560+100+15=17560+100+15=175，感觉良好 回家也没干啥主要就是补觉，然后听说 FZzzz\\textsf{\\color{black}F\\color{red}Zzzz}FZzzz T1 一个 log⁡\\loglog 跑 10s+ ？？？于是开始怀疑自己 606060 都拿不到了（ Day 2 一拿到卷子就毫无头绪（预示着要爆零？） 冷静想了想……依然毫无头绪…… T1 准备先写个暴力找找规律，然后发现找不到规律。然后尝试贪心，发现贪心是错的。考虑 DP 但不会 DP。决定先放着暴力看后面的题去。 然后是 T2，DS 题，看起来要支持区间加一、插入值、查询区间异或和。尝试线段树，failed；尝试值域树状数组，failed；尝试 01trie，发现自己根本没做过 01trie 的题，果断 failed。于是只得调头拿傻瓜分，并期望着出题人拿脚造数据。 看 T3 去了，求生成树个数 ？又推了半天式子然而毫无进展，于是又去码暴力了。 然后就开始狂想 T1 T3 的其它部分分，但依然不会。 最后除了暴力分啥也没拿到…… 估分 Day 2 30+10+30=7030+10+30=7030+10+30=70，爬了 回家才知道 T2 是原题 Day 3 到咕上测了两天的 T1 T2，D1 T1 606060 T2 100100100，D2 T1 挂了 T2 808080 (?) 然后发现 D1 T1 真的好卡常啊 Day 4 这，就出成绩了？ 于是 D2 T2 依然只有 101010 分，D2 T3 还 WA 了 555 分 End 总分：240240240（HB rk9） 加权分：240×70%+241×30%=240.3240\\times70\\%+241\\times30\\%=240.3240×70%+241×30%=240.3（HB rk13） E 队差一点 省选考得还好，但去年 CSP-S 太菜了，整个队线里 CSP 成绩倒数第二的比我高 50 😵 问题主要在会的知识点太少了，然后有些知识点会但练得不够，还有不会卡常 今年省选的题也是垃圾，5/6 原题 然后弱省终究是弱省，线不到 200 怕不是码全暴力 = 进队 ","link":"https://imzzy1201.github.io/post/akubgc5lY/"},{"title":"笔记 - 后缀数据结构","content":" Everythings comes full circle. 后缀数据结构是解决字符串相关问题的利器，其具有代码短、板子好记、时间复杂度低、应用广泛的优点。 此介绍 2 种常用结构：后缀树、后缀数组 前置约定 ϵ\\epsilonϵ 为空串 SSS 为原串，其下标从 111 开始 n=∣S∣n=|S|n=∣S∣ 为 SSS 的长度，代码中其最大值用 maxn 表示 S[i]S[i]S[i] 为 SSS 的第 iii 个字符 S[l..r]S[l..r]S[l..r] 为 SSS 中第 lll 个字符到第 rrr 个字符顺序连接形成的子串 SiS^iSi 为 SSS 的以第 iii 个字符为起始的后缀，即 S[i..n]S[i..n]S[i..n] SiS_iSi​ 为 SSS 的以第 iii 个字符为末尾的前缀，即 S[1..i]S[1..i]S[1..i] S1S2‾\\overline{S_1S_2}S1​S2​​ 表示 S1S_1S1​ 和 S2S_2S2​ 串连得到的字符串 Σ\\SigmaΣ 为 SSS 的字符集 ∣Σ∣|\\Sigma|∣Σ∣ 为 SSS 的字符集的元素个数，代码中其最大值用 maxm 表示 后缀树 前置知识 字符串和树的定义与基础知识 字典树（Trie） 定义 为了方便描述，我们先作出如下几个特殊定义： 边的标记串：边上的字符串 路径的标记串：AAA 和 BBB 两节点（约定 AAA 是 BBB 的祖先）间的路径标记为，从浅到深，串连从 AAA 到 BBB 的唯一路径经过的所有边的标记串，所得到的新串 节点对应的串：AAA 节点对应的串即为从根节点到 AAA 的路径标记串 一个串在后缀树中：即其可被表示为某个节点对应串的前缀 一个串在节点 AAA 上：即 AAA 的对应串就是这个串 后缀树（Suffix Tree, SFT）可以看作是压缩后的后缀字典树。具体来说，对于一个串 SSS，其后缀树可以认为是，将其所有后缀插入一个字典树中，然后去掉所有子节点个数为 111 的非根节点，并合并其父边和其唯一的子边（合并后的边标记串即为从被删去的节点的父节点到子节点的路径标记串）。 举个例子，下图是串 S=bananaS=\\mathtt{banana}S=banana 的后缀字典树： 下图是其后缀树： 但我们发现，并不是 SSS 的所有后缀都在某个节点上，比如 banana\\mathtt{banana}banana 的后缀树中 na\\mathtt{na}na 就不在任何一个节点上。这个问题在应用中会造成很多不便之处，所以一般而言说 SSS 的后缀树指的是在末尾加一个结束符 $\\mathtt{\\$}$ 后得到的串的后缀树，即 S $‾\\overline{S\\;\\mathtt{\\$}}S$​ 的后缀树： 这样就不存在这个问题了。 性质 后缀树的性质比较显然，但无论在构造中还是在解题中都非常重要，下面给出几个常用的： 所有非根节点的子节点个数都不为 111 原串的所有连续子串在后缀树中 所有不是原串连续子串的字符串都不在后缀树中 若原串包含结束符，那么原串的所有后缀串都在某个节点上 注：后文讲简称这些性质为“性质 1 ”“性质 3 ”等（后文方案、情况等同此表达） 表示方式 注意到所有边的标记串都是原串的连续子串，所以我们一般不会直接记录标记串，而是对其标记一个有序数对 (pos, len)(pos,\\,len)(pos,len)，表示其对应原串连续子串的起始位置和长度。特别的，如果标记串为原串的后缀，为了方便后续操作我们将其长度 lenlenlen 记为 inf⁡\\infinf。比如上图中标记为 banana$\\mathtt{banana\\$}banana$ 的边我们记为 (1, inf⁡)(1,\\,\\inf)(1,inf)，标记为 aaa 的边我们记为 (2,1)(2,1)(2,1)。边我们记录在节点的结构体中（即记录为父边） 其它的东西跟 Trie 的记录方式相同。 下面给出一个参考的节点结构体： struct NODE{ std::pair&lt;int,int&gt; fa; // 即父边 int ch[maxm]; // ch[i] 表示以 i 为始的子边连接的子节点编号 } 构建 朴素构建方式 根据定义，我们可以得到一个朴素构建方法。我们新建一个 Trie，将所有后缀顺序插入，然后根据后缀树的压缩要求压缩 Trie，得到结果。 很容易分析出，这个方法的时间和空间复杂度均为 O(n2)\\mathcal{O}(n^2)O(n2)，是很慢的。我们考虑优化，发现这个方法根本不好优化。 于是乎另一个构建的思想应运而生。 隐式树构建 名字是个幌子 所谓隐式树构建其实就是从小到大递推构建 SSS 的前缀串的后缀树，或者说维护后缀树每次往原串追加一个字符（以后称此为一轮插入），最终构建出整个包括结束符的串的后缀树。这个方法看似比朴素构建方式还慢，但优化后它可以达到线性时间。下面我们从暴力开始，一步一步优化，再得到它的线性构造方法。 暴力 首先要发现这个方法的一个算的上很优的性质，就是若 l&lt;rl&lt;rl&lt;r，则 SrS_rSr​ 的后缀树必定包含 SlS_lSl​ 的后缀树。也就是在上面说的插入一个字符后，后缀树只可能发生的一系列变化只可能有三种：一种是从某个节点伸出一条边指向一个新的节点；一种是将一条边切断为上下两部分，中间新建一个节点连接（后文称其为分裂）；另一种是往一条边的标记串追加一个字符。 现在我们来讨论在插入 S[i..j]S[i..j]S[i..j]，即构建 SjS_jSj​ 的后缀树时插入 (Sj)i(S_j)^i(Sj​)i 出现的情况 如果 S[i..j]S[i..j]S[i..j] 已经在后缀树里了，那显然可以不用管它，下面讨论如果 S[i..j]S[i..j]S[i..j] 不在后缀树里该如何操作。 首先，根据 性质 2，我们知道原树中必定有 S[i..j−1]S[i..j-1]S[i..j−1]，但它既可能正好是某个节点的对应串，也可能不是。那么我们先假设它是 AAA 的对应串的前缀（为了保证唯一性，我们令 AAA 为所有满足条件的节点中深度最小的一个） 如果 S[i..j−1]S[i..j-1]S[i..j−1] 正好在节点 AAA 上，那很好办了： 如果 AAA 是叶子节点，我们直接在 AAA 的父边标记串最后追加一个 S[j]S[j]S[j] 就好了。又因为 AAA 的对应串正好也是 Sj−1S_{j-1}Sj−1​ 的后缀，而追加后 AAA 的父边又成了 SjS_jSj​ 的后缀，所以追加前后 AAA 的父边的 lenlenlen 一直都是 inf⁡\\infinf，即不用改变其边的标记。或者简单来说，我们就跳过它！再如果 AAA 不是叶子节点，也很好办，我们从 AAA 伸出一条边，对应串为 S[j]S[j]S[j] 的边（标记为 (j, inf⁡)(j,\\,\\inf)(j,inf)），指向一个新的节点就好。注意这里的叶子节点不能包括根节点，因为根节点没有父边。 稍加思考就能发现上面两个操作方法符合后缀树的构造要求。 然而另一种情况就稍微麻烦一点了，如果 S[i..j−1]S[i..j-1]S[i..j−1] 是 AAA 对应串的真前缀（即与 AAA 的对应串不同但为其前缀），又该怎么办呢？我们先记 AAA 的对应串为 S′S&#x27;S′，假设 S[i..j−1]=Sk′S[i..j-1]=S&#x27;_kS[i..j−1]=Sk′​。根据后缀树由后缀 Trie 压缩得到的定义，我们知道本来应该从后缀 Trie 上对应串为 Sk′S&#x27;_kSk′​ 的节点 KKK 处伸出一条对应串为 S[j]S[j]S[j] 的边。然而这个 KKK 却不在后缀树上，因为它在原来的后缀树压缩的时候被扔了。这时，我们就应该把它捡回来，或者说在这里分裂出一个对应串为 Sk′S&#x27;_kSk′​ 的节点 KKK，然后像 Trie 上插入一样从这个节点上伸出一条对应串为 S[j]S[j]S[j] 的边（标记为 (j, inf⁡)(j,\\,\\inf)(j,inf)）。 总结来说，分 三种方案 ： 如果 S[i..j]S[i..j]S[i..j] 在后缀树中或 S[i..j−1]S[i..j-1]S[i..j−1] 是某个非根的叶节点 AAA 的对应串 不管它 如果 S[i..j]S[i..j]S[i..j] 在不后缀树中且 S[i..j−1]S[i..j-1]S[i..j−1] 与根节点或某个非叶子节点 AAA 的对应串相同 从 AAA 伸出一条标记为 (j, inf⁡)(j,\\,\\inf)(j,inf) 的边 其它情况 分裂出一个对应串为 S[i..j−1]S[i..j-1]S[i..j−1] 的节点，从其伸出一条标记为 (j, inf⁡)(j,\\,\\inf)(j,inf) 的边 我们按照上述方案从长到短插入即可。 没有什么比举例子更好说明的方法了，下面我们举例构造 cacfccf$\\mathtt{cacfccf\\$}cacfccf$ 的后缀树（图中红色的边即为此次插入时修改过的边）： 首先我们有个根节点 0 c\\mathtt{c}c 来了，插入串 c\\mathtt{c}c。我们发现上文提到的 S[i..j−1]S[i..j-1]S[i..j−1] 即 S[1..0]S[1..0]S[1..0] 即空串，在节点 0 上，而 0 是根节点。所以根据 方案 2 ，我们伸出一条标记为 (1, inf⁡)(1,\\,\\inf)(1,inf) 的边 然后 a\\mathtt{a}a 来了，于是我们插入串 {a,ca}\\{\\mathtt{a},\\mathtt{ca}\\}{a,ca}。对于 ca\\mathtt{ca}ca 观察到串 c\\mathtt{c}c 在节点 1 上，而 1 是叶节点，所以套用 方案 1 ；对于 a\\mathtt{a}a 观察到空串在节点 0 上，而 0 是根节点，所以套用 方案 2 又来了个 c\\mathtt{c}c，我们要插入串 {c,ac,cac}\\{\\mathtt{c},\\mathtt{ac},\\mathtt{cac}\\}{c,ac,cac}。cac\\mathtt{cac}cac 和 ac\\mathtt{ac}ac 都因为“S[i..j−1]S[i..j-1]S[i..j−1] 在某个非根的叶节点 AAA 上”而套用 方案 1 ，c\\mathtt{c}c 则因本身就在后缀树中而也套用了 方案 1 . f\\mathtt{f}f 来了，插入串 {f,cf,acf,cacf}\\{\\mathtt{f},\\mathtt{cf},\\mathtt{acf},\\mathtt{cacf}\\}{f,cf,acf,cacf}。插入 cacf\\mathtt{cacf}cacf 和 acf\\mathtt{acf}acf 时都套用 方案 1 。而当插入 cf\\mathtt{cf}cf 时，我们发现 c\\mathtt{c}c 在原树中不在任何节点上，这时我们就得用 方案 3 了， 分裂出节点 3 对应串 c\\mathtt{c}c，再从 3 伸出标记为 (4, inf⁡)(4,\\,\\inf)(4,inf) 的边指向新节点 4。最后插入 f\\mathtt{f}f 套用了 方案 2 。 剩下的几轮操作也相似，这里给出图，不再作详细说明了。 可以发现，一轮要插入 n+1n+1n+1 个字符，插入第 iii 个字符时要执行 iii 次方案，每次执行方案前都还要在后缀树中定位串的位置，所以总复杂度为 O(n3)\\mathcal{O}(n^3)O(n3)，甚至比朴素构建方法还慢……所以我们有了优化 优化 仔细看上面的图，我们会发现其中执行了很多次 方案 1 ，而 方案 1 事实上根本没有改变原树。因此我们尝试预判插入串时哪些将要执行 方案 1 ，并跳过它，或者说尽量避开 方案 1 。 假定现在插入的串是 S[i..j]S[i..j]S[i..j]，我们现在再把 方案 1 细分成 两个情况 ： S[i..j]S[i..j]S[i..j] 已经在后缀树中了 S[i..j−1]S[i..j-1]S[i..j−1] 是非根叶节点 AAA 的对应串 下面就推导几个与优化相关的重要 新性质 ： 仔细观察，我们可以发现，根据后缀树的 性质 2,3 ，如果后缀树里有串 S′S&#x27;S′ 那么 S′S&#x27;S′ 必定是原串的连续子串，而且 S′S&#x27;S′ 的所有连续子串也在后缀树中。那么，既然 S[i..j]S[i..j]S[i..j] 已经在树中了，所以 S[i+1..j], S[i+2..j],⋯ , S[j..j]S_[i+1..j],\\,S[i+2..j],\\cdots,\\,S[j..j]S[​i+1..j],S[i+2..j],⋯,S[j..j] 也都在后缀树中。因此显然，所有此轮需要插入的比 S[i..j]S[i..j]S[i..j] 短的所有串，都在树中。也就是说，当插入时遇到了 情况 1 ，我们就可以结束此轮插入。 再看到如果 S[i..j]S[i..j]S[i..j] 满足 情况 2 ，那么 S[i−1..j], S[i−2..j],⋯ , S[1..j]S[i-1..j],\\,S[i-2..j],\\cdots,\\,S[1..j]S[i−1..j],S[i−2..j],⋯,S[1..j] 也肯定满足 情况 2 。下面给出一个简单的证明： 反证法，假设 S[i−k,j−1] (0&lt;k&lt;i)S[i-k,j-1]\\ (0&lt;k&lt;i)S[i−k,j−1] (0&lt;k&lt;i) 不在非根叶节点上，那么根据 性质 2,3 ，我们可以得到必定存在一个非空串串 S′S&#x27;S′ 使得 S[i−k..j−1]S′‾\\overline{S[i-k..j-1]S&#x27;}S[i−k..j−1]S′​ 也在后缀树中（否则 S[i−k..j−1]S[i-k..j-1]S[i−k..j−1] 就在叶节点上了），再用一遍 性质 2 我们就得到 S[i,j−1]S′‾\\overline{S[i,j-1]S&#x27;}S[i,j−1]S′​ 也在树中（因为其是 S[i−k..j−1]S′‾\\overline{S[i-k..j-1]S&#x27;}S[i−k..j−1]S′​ 的后缀），所以 S[i..j−1]S[i..j-1]S[i..j−1] 也不在叶节点上，与题设矛盾！ 刚刚上面的那个新性质似乎直接不太好用，需要配合另一个性质才好。如果 S[i..j]S[i..j]S[i..j] 满足 情况 2 ，那么 S[i..j+1]S[i..j+1]S[i..j+1] 也满足 情况 2 。这个很好证，可以自行证明或感性理解一下就好了。 重要的是，根据刚刚讲的两个新性质，我们又得到了一个很棒的优化：若插入 SjS_jSj​ 这轮操作中，S[i..j]S_[i..j]S[​i..j] 满足了 情况 2 ，那么以后插入 S[k] (k&gt;j)S[k]\\ (k&gt;j)S[k] (k&gt;j) 的操作中可以直接从 S[i+1..k]S[i+1..k]S[i+1..k] 开始 总结来说现在有了两个 优化 ： 当插入时遇到了 情况 1 ，结束此轮插入 若插入 SjS_jSj​ 这轮操作中，S[i..j]S[i..j]S[i..j] 满足了 情况 2 ，那么以后插入 S[k] (k&gt;j)S[k]\\ (k&gt;j)S[k] (k&gt;j) 的操作中可以直接从 S[i+1..k]S[i+1..k]S[i+1..k] 开始 我们还是举个例子来说明： 这是优化后构造 S=acamsam$S=\\mathtt{acamsam\\$}S=acamsam$ 的步骤，每幅图中都标注了尝试插入了哪些串，灰色是已经被跳过的串，红色是上述 情况 1 ，橙色是 情况 2 ，蓝色是正常插入（ 方案 2,3 ） 这个优化看起来不大，但却为线性时间做了很大的贡献。我们可以发现，优化后插入的串的个数一定是线性的： 满足 情况 1 的插入是 O(n)\\mathcal{O}(n)O(n) 的 因为每轮插入一但碰到 情况 1 就结束了，所以每轮最多 111 次 满足 情况 2 的插入是 O(n)\\mathcal{O}(n)O(n) 的 因为这个情况当且仅当在叶节点上插入才会出现，叶节点一共有 n+1n+1n+1 个，而根据 优化 2 每个叶节点也都只会被访问 111 次 不满足 情况 1,2（即不是 方案 1 ）的插入是 O(n)\\mathcal{O}(n)O(n) 的 可以看到既然不是 方案 1 ，那么这次插入必然会增加至少 111 个节点，而根据后缀树 性质 1 可以得到其至多有 2n2n2n 个节点，所以这类插入不超过 2n2n2n 次 这是一个很大的进步，但我们发现每次插入时依然得重新在后缀树中给串串定位，而这就是 O(n)\\mathcal{O}(n)O(n) 的了，所以总时间复杂度依然 O(n2)\\mathcal{O}(n^2)O(n2)……因此又有了二次优化。 二次优化 观察到一次优化后最耗时间的是每次在后缀树中定位串串，我们考虑如何降低这个的复杂度。这里，我们每轮插入时假设最后还插入了一个空串（后文将体现其用处）。 现在引入两个新概念 后缀链 对于一个节点 AAA，若其对应串为 S[l..r]S[l..r]S[l..r]，那么它的 后缀链 link[A]link[A]link[A] 指向对应串为 S[l+1..r]S[l+1..r]S[l+1..r] 的节点（如果不存在这样的节点则指向根节点）。 活动点 即当前正在插入的后缀在原树（还未插入此串时的后缀树）中的位置，这个后缀我们称为 活动串 。 活动点 我们用一个三元组 (now, rem, char)(now,\\,rem,\\,char)(now,rem,char) 来记录，nownownow 表示活动点位于哪个节点的子边上（或正好在节点上），remremrem 表示活动点在子边上的长度（即节点对应串连上子边标记串的前 remremrem 个字符就是活动串），charcharchar 表示这个子边的起始字符。 记录这两个东西有什么用呢？我们下面就来说。 考虑这个 活动点 的含义，我们发现，一轮插入后，比结束插入时的 活动串 长的所有后缀，一定都在后缀树的某个非根叶节点上（这个不太好解释，可以照着后面的例子理解一下）。那么也就是说，在进行下一轮操作时，我们可以直接从上轮插入遗留下的 活动串 加上新插入的字符这里开始插入，再简洁一点，进行下一轮操作时，我们只用将老 活动点 的 rem+1rem+1rem+1 就能得到现需的 活动点 。 比如如果上一轮插入的原串是 abab\\mathtt{abab}abab，结束上轮插入时 活动串 是 ab\\mathtt{ab}ab，此轮插入要追加字符 c\\mathtt{c}c，那么此轮就可以直接从 abc\\mathtt{abc}abc 开始插入；如果上一轮插入的原串是 abc\\mathtt{abc}abc，结束上轮插入时 活动串 是空串，此轮插入要追加字符 d\\mathtt{d}d，那么此轮就可以直接从 d\\mathtt{d}d 开始插入。 再考虑 后缀链 的性质，我们发现插入一个串后，我们发现，如果 nownownow 不为根节点，将 nownownow 更改为 link[now]link[now]link[now]；如果 nownownow 是根节点，则将 rem−1rem-1rem−1。这样，组成的新三元组就是新的 活动点 。 现在再来考虑如何维护上面两个概念。事实上在上述对其作用的讲解中， 活动点 已经被维护了。而对于 后缀链 ，我们可以在一轮操作中，插入的第一个串 后缀链 指向根节点；其余每次插入新串，那么它的 后缀链 一定指向上一次插入的串所在的节点。 注意前面对活动点的维护还有一个遗漏，就是在几次更新后可能 remremrem 比 nownownow 的首字母为 charcharchar 的子边还长，这时我们应该顺着子边跳到它的子节点，并更新 remremrem 和 charcharchar。 上面几个地方其实不太好讲也不太好理解，需要揣摩一下，可以对照一些例子帮助理解（比如可以试试 S=noinonoipnoiS=\\mathtt{noinonoipnoi}S=noinonoipnoi） 在二次优化后得到的这个方法，正是大名鼎鼎的 Ukkonen 算法。 下面是一个 Ukkonen 算法的构造过程可视化（原址在 https://github.com/brenden/ukkonen-animation，根据需求稍有修改）。图中红色节点和边即为 活动点 ，虚线连接的节点则表示 后缀链 。 复杂度分析 第一次优化时我们已经证明了向后缀树插入串的次数是 O(n)\\mathcal{O}(n)O(n) 级别的，注意到每次插入时我们只是维护了几个值，可以对照代码看到除了 活动点 中“顺着子边跳到它的子节点”这里有循环，其它位置都必定是 O(1)\\mathcal{O}(1)O(1) 的。而我们发现活动点的 remremrem 只会在每轮插入的开始 +1+1+1，而每次“顺着子边跳到它的子节点”都会使 remremrem 减小，remremrem 又一直 &gt;0&gt;0&gt;0，所以“顺着子边跳到它的子节点”是均摊 O(1)\\mathcal{O}(1)O(1) 的。所以，我们可以知道其时间复杂度为 O(n)\\mathcal{O}(n)O(n)。 注意到最多 2n2n2n 个节点，而每个节点的 chchch 数组是 O(∣Σ∣)\\mathcal{O}(|\\Sigma|)O(∣Σ∣) 的，因此总的空间复杂度为 O(n∣Σ∣)\\mathcal{O}(n|\\Sigma|)O(n∣Σ∣) 当然，也可以用平衡树（map）维护子节点的映射，这样可以做到时空复杂度均为 O(nlog⁡∣Σ∣)\\mathcal{O}(n\\log|\\Sigma|)O(nlog∣Σ∣) Code 为了方便，在实现时记根节点为 1 号节点，而活动点的 charcharchar 则被原串和 remremrem 表示。在实现中也还有一些小技巧，可以仔细理解一下代码。 class suffix_tree{ public: int s[maxn],n,now,rem,cnt; struct NODE{int link,pos,len,ch[maxm];}t[maxn&lt;&lt;1]; // link 是后缀链，其它同上文中 NODE 的各变量 inline int newnode(int pos,int l) { NODE &amp;x=t[++cnt]; x.link=1,x.pos=pos,x.len=l; memset(x.ch,0,sizeof(x.ch)); return cnt; } inline void extend(int x) { s[++n]=x,++rem; for(rgi last=1;rem;) { while(rem&gt;t[t[now].ch[s[n-rem+1]]].len) // 即“顺着子边跳到它的子节点” rem-=t[now=t[now].ch[s[n-rem+1]]].len; // s[n-rem+1] 即为文中的 char int &amp;v=t[now].ch[s[n-rem+1]],c=s[t[v].pos+rem-1]; if(!v||c==x) { t[last].link=now,last=now; if(!v) v=newnode(n-rem+1,inf); else break; } else { int u=newnode(t[v].pos,rem-1); t[u].ch[c]=v,t[u].ch[x]=newnode(n,inf); t[v].pos+=rem-1,t[v].len-=rem-1; t[last].link=v=u,last=u; } if(now==1) --rem; else now=t[now].link; } } inline void build(const char *str) { cnt=n=rem=0,t[0].len=inf,now=newnode(0,0); // t[0].len=inf 是为了在 while(rem&gt;t[t[now].ch[s[n-rem+1]]].len) 这句话中 t[now].ch[s[n-rem+1]]（now 没有这个儿子）时及时跳出循环 for(rgi i=0,l=strlen(str);i&lt;l;++i) extend(str[i]-'a'+1); extend(0); } }sft; 应用 后缀树能解决的问题很多，下面给出几个比较常见的。 给定文本串 SSS 和多个模式串 {T}\\{T\\}{T}，查询串 TiT_iTi​ 在 SSS 中的出现次数 对 SSS 构造后缀树，对每个模式串 T′T&#x27;T′ 都先从根往下找到其在树中的位置。根据 性质 4 ，所到节点的子树中叶节点个数，也就是 SSS 的所有后缀中有前缀为 T′T&#x27;T′ 的个数，即为 SSS 中出现次数。 给定串 SSS，求 SSS 中不同子串个数 对 SSS 构造后缀树。根据 性质 2 ，SSS 的所有子串都在树中，或者说原来提到过的后缀 Trie 的节点数正是不同连续子串个数。所以其所有树边的长度和（长度即标记串长度，注意这里构造完后要把标为长 inf⁡\\infinf 的边还原成真实长度）即为不同连续子串个数。 查询串 SSS 中最长重复子串 对 SSS 构造后缀树，其最长重复子串即为出现过至少两次的最长子串，也就是最长的非叶节点对应串。 求两串 S, TS,\\,TS,T 的最长公共子序列（LCS） 对 S # T‾\\overline{S\\ \\mathtt{\\#}\\ T}S # T 建立后缀树，我们发现后缀树叶节点的父边标记串的第一个非字母的字符，要么是 #\\mathtt{\\#}#，要么是 $\\mathtt{\\$}$；如果是 #\\mathtt{\\#}# 就说明这个节点的对应串是 SSS 的后缀，否则即为 TTT 的后缀。那么，既然要求 LCS，也就是求最长的串使得 S, TS,\\,TS,T 均存在一个后缀，满足所求串是它的前缀。也就是在树中求最长的串使其对应节点的子树中有 #\\mathtt{\\#}# 和 $\\mathtt{\\$}$ 即可。 求串 SSS 的最长回文子串 首先跟求 LCS 时一样先将 S # S′‾\\overline{S\\ \\mathtt{\\#}\\ S&#x27;}S # S′（其中 S′S&#x27;S′ 为 SSS 的反串）构造后缀树，我们发现以第 iii 个字符为回文中心的最长回文串就是 SiS^iSi 和 S′n−i+1S&#x27;^{n-i+1}S′n−i+1 的最长公共前缀，对应到后缀树上就是这两个串对应节点的最近公共祖先（LCA）然后就可以求了。 求 SSS 的所有子序列中字典序第 iii 大的串 # 1 重复串算一个 建 SSS 的后缀树，对每个节点 iii 记录其子树中所有边的长度和 sum0[i]sum0[i]sum0[i]，记 iii 的对应串为 S′S&#x27;S′ 与 问题 2 类似的我们可以得到这个长度和即为有 SSS 中前缀有 S′S&#x27;S′ 的不同子串个数。所以预处理 sum0sum0sum0 后我们在树上 DFS，沿字典序枚举子节点的 sum0sum0sum0 加上子边长度，比 iii 大 iii 就减去它并继续枚举，否则 iii 减去子边长并进入此子树 # 2 重复串不算一个 注意到 问题 1 给出的结论，告诉我们一个串 TTT 在文本串 SSS 中的出现次数就是文本串的后缀树上 TTT 对应节点的子树中的叶节点数 siz[i]siz[i]siz[i]。根据这个我们可以求出 SSS 中前缀有 TTT 的子串个数 sum1[i]sum1[i]sum1[i]。剩下跟上面就一样了。 上面两个说起来都有点绕，下面给出对应代码帮助理解。 注意这份代码中已经把标为长 inf⁡\\infinf 的边还原成真实长度，即在 suffix_tree::build() 的最后一行加上 for(rgi i=1;i&lt;=cnt;++i) if(t[i].len&gt;n&lt;&lt;1) t[i].len=n-t[i].p; char str[maxn]; int n; int siz[maxn&lt;&lt;1],sum[2][maxn&lt;&lt;1]; void getsum(int x) { if(sft.t[x].p+sft.t[x].len&gt;n) return siz[x]=1,void(); for(rgi i=0,v;i&lt;=26;++i) if(sft.t[x].ch[i]) { getsum(v=sft.t[x].ch[i]); sum[0][x]+=sum[0][v]+sft.t[v].len; sum[1][x]+=sum[1][v]+sft.t[v].len*siz[v]; siz[x]+=siz[v]; } } char ans[maxn]; int indx; bool dfs(int t,int x,int p) // 返回值为 1 则找不到第 p 大的串 { for(rgi i=0,v,tmp;i&lt;=26;++i) if(sft.t[x].ch[i]) { v=sft.t[x].ch[i],tmp=sft.t[v].len*(t?siz[v]:1); if(p&gt;sum[t][v]+tmp) p-=sum[t][v]+tmp; else { for(rgi i=0;i&lt;sft.t[x].len;++i) ans[indx++]=str[sft.t[x].p+i-1]; if(p&lt;=tmp) for(rgi i=0;i&lt;(p-1)/(t?siz[v]:1)+1;++i) ans[indx++]=str[sft.t[v].p+i-1]; else dfs(t,v,p-tmp); return 0; } } return 1; } signed main() // Luogu P3975 { scanf(&quot;%s&quot;,str),n=strlen(str); sft.build(str),getsum(1); int t,k; fin&gt;&gt;t&gt;&gt;k; // t=0 求 #1，t=1 求 #2 if(dfs(t,1,k)) puts(&quot;-1&quot;); else ans[indx++]='\\0',printf(&quot;%s&quot;,ans); return 0; } 后缀数组 前置知识 字符串和树的定义与基础知识 字典树（Trie） 排序 最好对基数排序有一定的了解，不列为前置知识是因为文中会有详细介绍。 定义 后缀数组（Suffix Array, SA）就是 SSS 的所有后缀按字典序排序后的排名数组，即有 ∀i&lt;j, SSA[i]&lt;SSA[j]\\forall i&lt;j,\\ S^{SA[i]}&lt;S^{SA[j]} ∀i&lt;j, SSA[i]&lt;SSA[j] 举个例子，S=fzfzzfzzzzS=\\texttt{fzfzzfzzzz}S=fzfzzfzzzz 的后缀数组是 {1,3,6,10,2,5,9,4,8,7}\\{1,3,6,10,2,5,9,4,8,7\\}{1,3,6,10,2,5,9,4,8,7} 后缀数组也可以理解为后缀树的 DFS 序中各叶节点的出现顺序： 构建 朴素构建方式 我们根据后缀数组的定义来构造，也就是先列出所有的后缀，然后对其进行排序。 可以发现，排序需要比较 nlog⁡nn\\log nnlogn 次两串，而比较两串则是 (n)\\mathcal(n)(n) 的，因此总时间复杂度是 O(n2log⁡n)\\mathcal{O}(n^2\\log n)O(n2logn)，相较于最低的时空复杂度均 O(n)\\mathcal{O}(n)O(n) 差距还很大。 通过后缀树构建 也就是先构建出后缀树，然后在树上 DFS 出后缀数组。 跟直接用后缀树比没有任何优势，时空复杂度也与直接构建后缀树相同。 倍增法 倍增法是竞赛中最常用的 SA 构建方法，其具有占用空间低、思路清晰易懂、代码短、时间复杂度较优的优点。 为了说明倍增法的思想，我们依然从基本思想开始说起。考虑这样进行排序：第 iii 轮排序对于每个 jjj 的 S[j..min⁡(j+2i−1,n)]S[j..\\min(j+2^i-1,n)]S[j..min(j+2i−1,n)]，直到 2i≥n2^i\\ge n2i≥n（即第 iii 轮排序长度为 2i2^i2i 的子串）。举个例子我们还是排序串 S=fzfzzfzzzzS=\\mathtt{fzfzzfzzzz}S=fzfzzfzzzz，下面列举了每轮排序的待排序串： 第 0 轮 第 1 轮 第 2 轮 第 3 轮 第 4 轮 f z f z z f z z z z\\begin{aligned}\\\\\\mathtt{f\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{z\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{f\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{z\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{z\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{f\\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{z\\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{z\\ \\ \\ \\ }&amp;\\\\\\mathtt{z\\ \\ }&amp;\\\\\\mathtt{z}\\end{aligned}f z f z z f z z z z​​ fz zf fz zz zf fz zz zz zzz\\begin{aligned}\\\\\\mathtt{fz\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zf\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{fz\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zz\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zf\\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{fz\\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zz\\ \\ \\ \\ }&amp;\\\\\\mathtt{zz\\ \\ }&amp;\\\\\\mathtt{zz}&amp;\\\\\\mathtt{z}\\end{aligned}fz zf fz zz zf fz zz zz zzz​​ fzfz zfzz fzzf zzfz zfzz fzzz zzzzzzzzzz\\begin{aligned}\\\\\\mathtt{fzfz\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zfzz\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{fzzf\\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zzfz\\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zfzz\\ \\ \\ \\ }&amp;\\\\\\mathtt{fzzz\\ \\ }&amp;\\\\\\mathtt{zzzz}&amp;\\\\\\mathtt{zzz}&amp;\\\\\\mathtt{zz}&amp;\\\\\\mathtt{z}\\end{aligned}fzfz zfzz fzzf zzfz zfzz fzzz zzzzzzzzzz​​ fzfzzfzz zfzzfzzz fzzfzzzzzzfzzzzzfzzzzfzzzzzzzzzzzzzz\\begin{aligned}\\\\\\mathtt{fzfzzfzz\\ \\ \\ \\ }&amp;\\\\\\mathtt{zfzzfzzz\\ \\ }&amp;\\\\\\mathtt{fzzfzzzz}&amp;\\\\\\mathtt{zzfzzzz}&amp;\\\\\\mathtt{zfzzzz}&amp;\\\\\\mathtt{fzzzz}&amp;\\\\\\mathtt{zzzz}&amp;\\\\\\mathtt{zzz}&amp;\\\\\\mathtt{zz}&amp;\\\\\\mathtt{z}\\end{aligned}fzfzzfzz zfzzfzzz fzzfzzzzzzfzzzzzfzzzzfzzzzzzzzzzzzzz​​ fzfzzfzzzzzfzzfzzzzfzzfzzzzzzfzzzzzfzzzzfzzzzzzzzzzzzzz\\begin{aligned}\\\\\\mathtt{fzfzzfzzzz}&amp;\\\\\\mathtt{zfzzfzzzz}&amp;\\\\\\mathtt{fzzfzzzz}&amp;\\\\\\mathtt{zzfzzzz}&amp;\\\\\\mathtt{zfzzzz}&amp;\\\\\\mathtt{fzzzz}&amp;\\\\\\mathtt{zzzz}&amp;\\\\\\mathtt{zzz}&amp;\\\\\\mathtt{zz}&amp;\\\\\\mathtt{z}\\end{aligned}fzfzzfzzzzzfzzfzzzzfzzfzzzzzzfzzzzzfzzzzfzzzzzzzzzzzzzz​​ 定义 Si,j=S[j..min⁡(j+2i−1,n)]S_{i,j}=S[j..\\min(j+2^i-1,n)]Si,j​=S[j..min(j+2i−1,n)]（即如上表中的第 iii 轮第 jjj 行，若 j&gt;nj&gt;nj&gt;n 则令其为 ϵ\\epsilonϵ） 那么很明显，有 Si+1,j=Si,j Si,j+2i‾S_{i+1,j}=\\overline{S_{i,j}\\ S_{i,j+2^i}}Si+1,j​=Si,j​ Si,j+2i​​ 再定义 fi,jf_{i,j}fi,j​ 代表 Si,jS_{i,j}Si,j​ 在 Si,k (1≤k≤n)S_{i,k}\\ (1\\le k\\le n)Si,k​ (1≤k≤n) 中的排名。比如上述第 1 轮对应的 f1={1,3,1,4,3,1,4,4,4,2}f_1=\\{1,3,1,4,3,1,4,4,4,2\\}f1​={1,3,1,4,3,1,4,4,4,2}，第 2 轮对应的 f2={1,5,2,7,5,3,9,8,6,4}f_2=\\{1,5,2,7,5,3,9,8,6,4\\}f2​={1,5,2,7,5,3,9,8,6,4} 我们可以得到一个明显却不太明显的结论： 基于同一个 iii，如果我们对于所有 jjj 将 (fi,j, fi,j+2i)(f_{i,j},\\,f_{i,j+2^i})(fi,j​,fi,j+2i​) 排序去重，则 fi+1,j=(fi,j, fi,j+2i)f_{i+1,j}=(f_{i,j},\\,f_{i,j+2^i})fi+1,j​=(fi,j​,fi,j+2i​)排序后的序号。比如还是举 i=1i=1i=1 的例子，用来排序的数对是： {(1,1),(3,4),(1,3),(4,1),(3,4),(1,4),(4,4),(4,2),(4,0),(2,0)}\\{(1,1),(3,4),(1,3),(4,1),(3,4),(1,4),(4,4),(4,2),(4,0),(2,0)\\} {(1,1),(3,4),(1,3),(4,1),(3,4),(1,4),(4,4),(4,2),(4,0),(2,0)} 第 xxx 个数对里的第一个数叫“第 iii 轮中后缀 xxx 的第一关键字”，第二个数叫“第 iii 轮中后缀 xxx 的第二关键字”，后文就直接这样称呼了 排序去重后的数对是： {(1,1),(1,3),(1,4),(2,0),(3,4),(4,0),(4,1),(4,2),(4,4)}\\{(1,1),(1,3),(1,4),(2,0),(3,4),(4,0),(4,1),(4,2),(4,4)\\} {(1,1),(1,3),(1,4),(2,0),(3,4),(4,0),(4,1),(4,2),(4,4)} 所以排序后的序号为 {1,5,2,7,5,3,9,8,6,4}\\{1,5,2,7,5,3,9,8,6,4\\}{1,5,2,7,5,3,9,8,6,4}，也就是 f2f_2f2​ 的值。 根据这个结论，我们就可以在 ⌈log⁡n⌉\\lceil\\log n\\rceil⌈logn⌉ 次排序以内求出 f⌈log⁡n⌉f_{\\lceil\\log n\\rceil}f⌈logn⌉​ 以及 SASASA（SA[i]SA[i]SA[i] 可以理解为 iii 在 f⌈log⁡n⌉f_{\\lceil\\log n\\rceil}f⌈logn⌉​ 中对应的下标） 如果用普通的排序方式，我们就得到了一个 nlog⁡2nn\\log^2nnlog2n 的求法了。 观察到需要排序的对象是一些有序数对，而有序数对中每个数都不超过 nnn，所以我们引入另一种排序方式使得一次排序只用花费 O(n)\\mathcal{O}(n)O(n) 的时间和空间：基数排序。 简单来讲，基数排序就是先按第二关键字桶排序一遍，再按第一关键字桶排序一遍。 SASASA 的代码是精髓，具体实现方法，先上 code，再一点一点讲 Code int n,m; int SA[maxn],c[maxn],t1[maxn],t2[maxn]; inline void getSA() { int *x=t1,*y=t2; for(rgi i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(rgi i=n;i&gt;=1;--i) SA[c[x[i]]--]=i; for(rgi k=1,p;k&lt;=n;k&lt;&lt;=1) {p=0; for(rgi i=n-k+1;i&lt;=n;++i) y[++p]=i; for(rgi i=1;i&lt;=n;++i) if(SA[i]&gt;k) y[++p]=SA[i]-k; for(rgi i=1;i&lt;=m;++i) c[i]=0; for(rgi i=1;i&lt;=n;++i) ++c[x[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(rgi i=n;i&gt;=1;--i) SA[c[x[y[i]]]--]=y[i],y[i]=0; std::swap(x,y),x[SA[1]]=p=1; for(rgi i=2;i&lt;=n;++i) x[SA[i]]=(y[SA[i]]==y[SA[i-1]]&amp;&amp;y[SA[i]+k]==y[SA[i-1]+k])?p:++p; if(n==(m=p)) break; } } 看起来是不是很玄学？ emmmm……一点一点说吧 int n,m; int SA[maxn],c[maxn],t1[maxn],t2[maxn]; 这里的 nnn 是待求 SASASA 的串的长度即 ∣S∣|S|∣S∣；mmm 开始时可以说是字符集的大小即 ∣Σ∣|\\Sigma|∣Σ∣，后面则成为排名的值域（也就是这轮排序了多少种不同的串），这个意义最后会体现的。 SASASA 就是 SASASA（注意每轮排序的串长度是不同的，所以每轮的后缀排序也是不同的），ccc 是用于桶排序串辅助数组，t1,t2t1,t2t1,t2 是另外两个神神奇奇的辅助数组，后面会讲它的作用。 int *x=t1,*y=t2; 这两个东西在不同的地方有不同的意义 for(rgi i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(rgi i=n;i&gt;=1;--i) SA[c[x[i]]--]=i; 首先预处理第 0 轮排序，即对单个字符排序。这三行是正常的桶排序。 第一行先将所有元素放入桶；第二行对桶做前缀和，方便计算排名；第三行将排名放进 SASASA 数组（再说一遍 SA[i]SA[i]SA[i] 表示排名第 iii 的后缀，为了不重复让排名并列的后缀放进同一个位置所以下标要是 c[x[i]]--） for(rgi k=1,p;k&lt;=n;k&lt;&lt;=1) {p=0; 准备基数排序了。注意，kkk 不是本轮排序的串的长度，而是它的一半！然后 ppp 是个辅助变量，可以说是用来记下标的 现在，先理解一个地方，每轮开始时上一轮已经处理好了这一轮的第一关键字，这里就是 xxx，这个在第 1 轮排序时是显然的（第 0 轮里的 xxx 当然可以作为第 1 轮的第一关键字），而在每轮的末尾也都有这个处理过程，具体后面再讲。现在可以这样记着：第 iii 轮开始时 xxx 就是上文中的 fi−1f_{i-1}fi−1​。 举个例子还是 fzfzzfzzzz\\texttt{fzfzzfzzzz}fzfzzfzzzz，第 2 轮排序开始时，xxx 的值就是 {1,3,1,4,3,1,4,4,4,2}\\{1,3,1,4,3,1,4,4,4,2\\}{1,3,1,4,3,1,4,4,4,2}。 那么既然第一关键字已经准备好了，现在就该处理第二关键字了 来到第一个神奇的位置了，马上要现身的 y[i]y[i]y[i] 在这里指第二关键字排名为 iii 的后缀，它原来所处的位置的下标（大雾）。什么意思呢？依然用 fz 的例子来解释： 如果我们现在正在排序第 2 轮（即长度为 444 的串），那么…… 第二关键字：{1,4,3,1,4,4,4,2,0,0}\\{1,4,3,1,4,4,4,2,0,0\\}{1,4,3,1,4,4,4,2,0,0} 第二关键字排序后应该长这样：{0,0,1,1,2,3,4,4,4,4}\\{0,0,1,1,2,3,4,4,4,4\\}{0,0,1,1,2,3,4,4,4,4} 我们看每个数它原来在哪（即原位置的下标）：前两个 000 分别在 9,109,109,10 号位置，111 在 1,41,41,4，222 只在下标为 888 的位置出现过，333 正好在 333 号位，444 则坐落于 2,5,6,72,5,6,72,5,6,7 这几个下标。 所以 yyy 应该为：{9,10,1,4,8,3,2,5,6,7}\\{9,10,1,4,8,3,2,5,6,7\\}{9,10,1,4,8,3,2,5,6,7} 再换句话说 ∀i&lt;j\\forall i&lt;j∀i&lt;j，后缀 y[i]y[i]y[i] 的第二关键字小于等于后缀 y[j]y[j]y[j] 的第二关键字。 好了差不多就这样了，下面看怎么求 yyy： for(rgi i=n-k+1;i&lt;=n;++i) y[++p]=i; 首先可以看到最后 kkk 个后缀在这一轮排序中是没有第二关键字的（或者说第二关键字为 000），所以它们肯定排在最前面。 for(rgi i=1;i&lt;=n;++i) if(SA[i]&gt;k) y[++p]=SA[i]-k; 注意到这里 SA[i]SA[i]SA[i] 相当于上一轮后缀的排序，也就是相当于 xxx 的排序，或者说现在有 ∀i&lt;j,x[SA[i]]≤x[SA[j]]\\forall i&lt;j,x[SA[i]]\\le x[SA[j]]∀i&lt;j,x[SA[i]]≤x[SA[j]]。又观察到 1∼n−k1\\sim n-k1∼n−k 这些后缀在这轮的第二关键字正好是 k+1∼nk+1\\sim nk+1∼n 的第一关键字。所以呢……根据 yyy 的定义，有 ∀i&lt;j,x[y[i]+k]≤x[y[j]+k]\\forall i&lt;j,x[y[i]+k]\\le x[y[j]+k]∀i&lt;j,x[y[i]+k]≤x[y[j]+k] ，发现这不跟 SASASA 有异曲同工之妙吗！于是乎就有了上面的这行码。注意如果 SA[i]≤kSA[i]\\le kSA[i]≤k，那 x[SA[i]]x[SA[i]]x[SA[i]] 显然不在第二关键字里，所以要跳过。 for(rgi i=1;i&lt;=m;++i) c[i]=0; for(rgi i=1;i&lt;=n;++i) ++c[x[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; 再对第一关键字桶排序一遍，跟前面说的差不多。这里是先扔进桶里并跟第 0 轮时一样求个前缀和。 for(rgi i=n;i&gt;=1;--i) SA[c[x[y[i]]]--]=y[i],y[i]=0; 然后要从桶里取出来算这一轮的 SASASA 了。这里套了大概 444 层方括号令人有点非常眼瞎……所以我们从内往外一层一层看： y[i]y[i]y[i]：第二关键字排名为 iii 的后缀的下标（前面说过了） x[y[i]]x[y[i]]x[y[i]]：第二关键字排名为 iii 的后缀的第一关键字 c[x[y[i]]]c[x[y[i]]]c[x[y[i]]]：“第二关键字排名为 iii 的后缀的第一关键字”在桶里的排名（-- 跟之前说的一样是为了保证不重复） SA[c[x[y[i]]]−−]SA[c[x[y[i]]]--]SA[c[x[y[i]]]−−]：SASASA 数组中，下标为上面的“……的排名”的位置 这个怎么理解呢？可以回头对着第 000 轮的那句话 for(rgi i=n;i&gt;=1;--i) SA[c[x[i]]--]=i; 看。它无非就是把下标里的 iii 改成了 y[i]y[i]y[i]，或者说就是换了个访问顺序。正是因为换成了这个 y[i]y[i]y[i] 才使得在第一关键字有序的情况下，第二关键字有序 这个地方仔细模拟一下这个过程，就能理解了。 最后那个 y[i]=0y[i]=0y[i]=0 没别的意思，就只是清空 yyy。 记得前面提到过的“每轮开始时上一轮已经处理好了这一轮的第一关键字”吗？现在就要“履行这个诺言”了。由于下一轮的第一关键字就是这一轮排序后每个后缀的排名，所以直接求这个排名就好 std::swap(x,y),x[SA[1]]=p=1; 这里的交换纯粹是为了方便写，x[SA[1]]=p=1 也挺显然的，第一名的后缀当然排名第 111 啦。 for(rgi i=2;i&lt;=n;++i) x[SA[i]]=(y[SA[i]]==y[SA[i-1]]&amp;&amp;y[SA[i]+k]==y[SA[i-1]+k])?p:++p; 这句话呢……挺长……但其实意思挺简单。y[SA[i]]==y[SA[i-1]]&amp;&amp;y[SA[i]+k]==y[SA[i-1]+k] 就是判定的这个后缀和上个后缀是不是俩关键字都相同，如果是的话那肯定排名跟上一个也一样即 ppp，否则就要 +1+1+1。 if(n==(m=p)) break; 最后一句，也不难理解了。 首先，最后的 ppp 值也就是这轮排序出现的不同排名的个数，所以 mmm 要被赋值为 ppp 啦。 然后如果 n=mn=mn=m，就说明排名已经两两不同了，也就是已经完全有序了，所以就不用再继续排下去了呗。 那么到这里，倍增法总算是讲完了。。。 如果还是有问题，可以输出一下 SA,x,ySA,x,ySA,x,y 这三个数组对着看看，比如像下面这样： int n,m,SA[maxn],c[maxn],t1[maxn],t2[maxn]; inline void DEBUG(int time,const char *v,int *x,int *y) { printf(&quot;\\n------ DEBUG:%3d, %s ------\\n&quot;,time,v); printf(&quot; SA: &quot;); for(rgi i=1;i&lt;=n;++i) std::cout&lt;&lt;SA[i]&lt;&lt;' '; std::cout&lt;&lt;'\\n'; printf(&quot; x: &quot;); for(rgi i=1;i&lt;=n;++i) std::cout&lt;&lt;x[i]&lt;&lt;' '; std::cout&lt;&lt;'\\n'; printf(&quot; y: &quot;); for(rgi i=1;i&lt;=n;++i) std::cout&lt;&lt;y[i]&lt;&lt;' '; std::cout&lt;&lt;'\\n'; std::cout&lt;&lt;'\\n'; } inline void getSA() { int *x=t1,*y=t2; DEBUG(1,&quot;No.0&quot;,x,y); for(rgi i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(rgi i=1;i&lt;=n;++i) SA[c[x[i]]--]=i; DEBUG(1,&quot;No.1&quot;,x,y); for(rgi k=1,p;k&lt;=n;k&lt;&lt;=1) {p=0; DEBUG(k&lt;&lt;1,&quot;No.0&quot;,x,y); for(rgi i=n-k+1;i&lt;=n;++i) y[++p]=i; for(rgi i=1;i&lt;=n;++i) if(SA[i]&gt;k) y[++p]=SA[i]-k; DEBUG(k&lt;&lt;1,&quot;No.1&quot;,x,y); for(rgi i=1;i&lt;=m;++i) c[i]=0; for(rgi i=1;i&lt;=n;++i) ++c[x[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(rgi i=n;i&gt;=1;--i) SA[c[x[y[i]]]--]=y[i],y[i]=0; DEBUG(k&lt;&lt;1,&quot;No.2&quot;,x,y); std::swap(x,y),x[SA[1]]=p=1; for(rgi i=2;i&lt;=n;++i) x[SA[i]]=(y[SA[i]]==y[SA[i-1]]&amp;&amp;y[SA[i]+k]==y[SA[i-1]+k])?p:++p; if(n==(m=p)) break; } } DC3/DC 算法 不会，有时间学了就写 SA-IS 算法 也不会，估计会先学这再学 DC3/DC 辅助工具 单单有个后缀数组其实解决不了什么问题，因此我们要引入另外两个辅助数组：rankrankrank 和 heightheightheight。 rank[i]rank[i]rank[i] 顾名思义就是后缀 SiS^iSi 的排名，即 SA[rank[i]]=iSA[rank[i]]=iSA[rank[i]]=i； height[i]height[i]height[i] 指 SSA[i]S^{SA[i]}SSA[i] 和 SSA[i−1]S^{SA[i-1]}SSA[i−1] 的最长公共前缀（LCP），即有 (SSA[i])height[i]=(SSA[i−1])height[i](S^{SA[i]})_{height[i]}=(S^{SA[i-1]})_{height[i]}(SSA[i])height[i]​=(SSA[i−1])height[i]​ 且 (SSA[i])[height[i]+1]≠(SSA[i−1])[height[i]+1](S^{SA[i]})[height[i]+1]\\neq(S^{SA[i-1]})[height[i]+1](SSA[i])[height[i]+1]​=(SSA[i−1])[height[i]+1] 给个图这俩东西就很清晰了： 闲扯一句，heightheightheight 数组也可以认为代表了后缀树中相邻两个叶节点的 LCALCALCA 的映射。 这两个的求法呢，也不难。 rankrankrank 其实就一行，遍历一次 SASASA 数组就好了 int rank[maxn]; for(rgi i=1;i&lt;=n;++i) rank[SA[i]]=i; 如果求 SASASA 时用的是倍增法，甚至可以直接定义全局变量 int *rank; 然后在 getSA 函数的最外层循环之后加上一句 rank=x; 即可 LCP 与 heightheightheight 我们注意到一个性质，height[rank[i]]≥height[rank[i−1]]−1height[rank[i]]\\ge height[rank[i-1]]-1height[rank[i]]≥height[rank[i−1]]−1。这个性质形式化的证明长得比较丑，这里举个例子说明原因。 看到 i=4i=4i=4 的时候，首先，rank[i−1]=2rank[i-1]=2rank[i−1]=2，后缀 i−1i-1i−1 为 fzzfzzzz\\texttt{fzzfzzzz}fzzfzzzz，排名仅高于它的后缀则是 fzfzzfzzzz\\mathtt{fzfzzfzzzz}fzfzzfzzzz，也就是求的这两行的 LCS： 如果我们将这两个串去掉首字母再在里面定位： 可以发现 zzfzzzz\\texttt{zzfzzzz}zzfzzzz 也就是后缀 iii，而 zfzzfzzzz\\mathtt{zfzzfzzzz}zfzzfzzzz 肯定排在 zzfzzzz\\texttt{zzfzzzz}zzfzzzz 之前。既然排在它之前，所以它俩之间的串 肯定排名在它俩之间。 进一步推断，这一堆的所有串的 LCS 必定就是 height[rank[i−1]]−1height[rank[i-1]]-1height[rank[i−1]]−1： 所以就能得到 height[rank[i]]≥height[rank[i−1]]−1height[rank[i]]\\ge height[rank[i-1]]-1height[rank[i]]≥height[rank[i−1]]−1： 有了这个性质，就很容易线性求 heightheightheight 数组了，下面是代码供参考 inline void getheight() { for(rgi i=1,j,k=0;i&lt;=n;++i) { if(k) --k; j=SA[rank[i]-1]; while(s[i+k]==s[j+k]) ++k; height[rank[i]]=k; } } 然后我们再看到，如何求任意两个后缀的 LCP，也很容易发现后缀 i,j (rank[i]&lt;rank[j])i,j\\ (rank[i]&lt;rank[j])i,j (rank[i]&lt;rank[j]) 的 LCP 是 min⁡(height[rank[i]+1],height[rank[i]+2],⋯ ,height[rank[k]])\\min(height[rank[i]+1],height[rank[i]+2],\\cdots,height[rank[k]])min(height[rank[i]+1],height[rank[i]+2],⋯,height[rank[k]])。给个图就很容易理解了： 这相当于对 heightheightheight 数组求区间最小值（RMQ），可以用 ST 表实现，也可以用其它奇奇怪怪的数据结构实现。 应用 后缀数组能解决的问题还是没后缀树多，多数应用是依赖其优秀的线性空间。 给定文本串 SSS，求 SSS 的最长重复子串 # 1 重复的两子串可以重叠 就是求 heightheightheight 的最大值啦。 # 2 重复的两子串不能重叠 考虑二分答案。对于二分的答案 kkk，先挑出所有 heightheightheight 比 kkk 大的位置，把连续的一些满足这个条件的位置合并为一组。然后对于每个组内查看的 SASASA 值中最大的与最小的之差是否大于等于 kkk（存在任意一组大于等于 kkk 则可行）。这里的大于等于 kkk 其实就是避免重叠。 给定文本串 SSS，求 SSS 的最长重复 kkk 次的子串（可重叠） 像 1.2 一样先二分答案并分好组，任何一个组内的后缀个数大于等于 kkk 则此答案成立。 求 SSS 中不同连续子串个数 不同连续子串个数就是不同“后缀的前缀”的个数，考虑到后缀 SA[i]SA[i]SA[i] 贡献了 n−SA[i]+1n-SA[i]+1n−SA[i]+1 个前缀，然而有 height[i]height[i]height[i] 个前缀跟后缀 SA[i−1]SA[i-1]SA[i−1] 的前缀重复，所以对答案的总贡献是 n−SA[i]+1−height[i]n-SA[i]+1-height[i]n−SA[i]+1−height[i]，对于所有的 iii 求此值的和即为答案 ","link":"https://imzzy1201.github.io/post/tbrptnzGB/"},{"title":"笔记 - Lucas 定理","content":" Never put off the work till tomorrow, you can put off today. Lucas 定理用于求 (nm)mod p\\dbinom{n}{m}\\mod p(mn​)modp（ppp 为质数） 一般多用于 n,m&gt;pn,m&gt;pn,m&gt;p，即无法使用阶乘取模法的情况。 形式 下面给出两种 Lucas 定理的形式，一般代码用形式 1 写。 形式 1 令 n=sp+q, m=tp+r, q,r≤pn=sp+q,\\ m=tp+r,\\ q,r\\le pn=sp+q, m=tp+r, q,r≤p 则有 (nm)≡(st)(qr)(modp)\\binom{n}{m}\\equiv\\binom s t \\binom q r \\pmod p (mn​)≡(ts​)(rq​)(modp) 形式 2 若将 nnn 写成 ppp 进制的 aq⋯a2a1a0‾\\overline{a_q\\cdots a_2a_1a_0}aq​⋯a2​a1​a0​​，mmm 写成 ppp 进制的 bq⋯b2b1b0‾\\overline{b_q\\cdots b_2b_1b_0}bq​⋯b2​b1​b0​​ 那么 (nm)≡∏i=0q(aibi)(modp)\\binom{n}{m}\\equiv\\prod_{i=0}^q\\binom{a_i}{b_i}\\pmod p (mn​)≡i=0∏q​(bi​ai​​)(modp) 值得注意的是，若 nnn 与 mmm 的 ppp 进制数位数不同，那么 (nm)≡0(modp)\\dbinom{n}{m}\\equiv0\\pmod p(mn​)≡0(modp) 证明 下面是形式 111 推导过程 令 0&lt;f&lt;p0&lt;f&lt;p0&lt;f&lt;p 则 (pf)≡pf(p−1f−1)≡0(modp)\\dbinom{p}{f}\\equiv\\dfrac{p}{f}\\dbinom{p-1}{f-1}\\equiv 0 \\pmod p(fp​)≡fp​(f−1p−1​)≡0(modp) 所以有 (1+x)n≡(1+x)sp+q≡(1+x)sp⋅(1+x)q≡((1+x)p)s⋅(1+x)q≡(∑i=0p(pi)xi(pn−i))s⋅(1+x)q≡(1+xp)s⋅(1+x)q≡∑i=0s(si)xip⋅∑j=0q(qj)xj(modp)\\begin{aligned}\\\\ &amp;(1+x)^n\\\\ \\equiv&amp;(1+x)^{sp+q}\\\\ \\equiv&amp;(1+x)^{sp}\\cdot(1+x)^q\\\\ \\equiv&amp;((1+x)^p)^s\\cdot(1+x)^q\\\\ \\equiv&amp;\\left(\\sum_{i=0}^p\\binom p i x^i \\binom p {n-i}\\right)^s\\cdot(1+x)^q\\\\ \\equiv&amp;(1+x^p)^s\\cdot(1+x)^q\\\\ \\equiv&amp;\\sum_{i=0}^s\\binom s i x^{ip}\\cdot\\sum_{j=0}^q\\binom{q}{j}x^j \\pmod p\\\\ \\end{aligned} ≡≡≡≡≡≡​(1+x)n(1+x)sp+q(1+x)sp⋅(1+x)q((1+x)p)s⋅(1+x)q(i=0∑p​(ip​)xi(n−ip​))s⋅(1+x)q(1+xp)s⋅(1+x)qi=0∑s​(is​)xip⋅j=0∑q​(jq​)xj(modp)​ 即有 (1+x)n≡∑i=0s∑j=0q(si)(qj)xip+j(modp)(1+x)^n\\equiv\\sum_{i=0}^s\\sum_{j=0}^q\\binom{s}{i}\\binom{q}{j}x^{ip+j}\\pmod p (1+x)n≡i=0∑s​j=0∑q​(is​)(jq​)xip+j(modp) 又因为 (1+x)n=∑i=0n(ni)xi(1+x)^n=\\sum_{i=0}^{n}\\binom{n}{i}x^i (1+x)n=i=0∑n​(in​)xi 所以 xmx^mxm 项系数为 (nm)\\dbinom{n}{m}(mn​) 又 (1+x)n≡∑i=0s∑j=0q(si)(qj)xip+j(modp), m=tp+r(1+x)^n\\equiv\\sum_{i=0}^s\\sum_{j=0}^q\\binom{s}{i}\\binom{q}{j}x^{ip+j}\\pmod p,\\ m=tp+r (1+x)n≡i=0∑s​j=0∑q​(is​)(jq​)xip+j(modp), m=tp+r 所以 xmx^mxm 项系数亦为 (st)(qr)\\dbinom{s}{t}\\dbinom{q}{r}(ts​)(rq​) 即 (nm)≡(st)(qr)(modp)\\dbinom{n}{m}\\equiv\\dbinom s t \\dbinom q r \\pmod p(mn​)≡(ts​)(rq​)(modp) 形式 222 与形式 111 本质相同，只不过把 n=sp+q,m=tp+rn=sp+q,m=tp+rn=sp+q,m=tp+r 简化为 n,mn,mn,m 在 ppp 进制下的每一位 Code 依然是一行 ll Lucas(ll n,ll m,ll p) {return m&lt;=0?1LL:(C(n%p,m%p)*Lucas(n/p,m/p)%p);} 扩展定理 扩展 Lucas 定理（exLucas），用于解决 ppp 不是质数的情况 思路大概是这样的，首先分解 ppp 的质因子 p=p1α1p2α2p3α3⋯pkαk=∏i=1kpiαip=p_1^{\\alpha_1}p_2^{\\alpha_2}p_3^{\\alpha_3}\\cdots p_k^{\\alpha_k}=\\prod_{i=1}^kp_i^{\\alpha_i} p=p1α1​​p2α2​​p3α3​​⋯pkαk​​=i=1∏k​piαi​​ 分别求出 {(nm) mod p1α1(nm) mod p2α2⋯(nm) mod pkαk\\left\\{ \\begin{aligned}\\\\ \\binom{n}{m}&amp;\\bmod p_1^{\\alpha_1}\\\\ \\binom{n}{m}&amp;\\bmod p_2^{\\alpha_2}\\\\ &amp;\\cdots\\\\ \\binom{n}{m}&amp;\\bmod p_k^{\\alpha_k} \\end{aligned} \\right. ⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​(mn​)(mn​)(mn​)​modp1α1​​modp2α2​​⋯modpkαk​​​ 然后根据中国剩余定理求解 现在考虑求 (nm) mod qr (q∈prime)\\binom{n}{m}\\bmod q^r\\ (q\\in \\text{prime}) (mn​)modqr (q∈prime) 考虑到 (nm)≡n!m!(n−m)!≡n!qxm!qy⋅(n−m)!qz⋅qx−y−z(modqr), (q∈prime)\\binom{n}{m}\\equiv\\frac{n!}{m!(n-m)!}\\equiv\\frac{\\frac{n!}{q^x}}{\\frac{m!}{q^y}\\cdot\\frac{(n-m)!}{q^z}}\\cdot q^{x-y-z} \\pmod{q^r},\\ (q\\in \\text{prime}) (mn​)≡m!(n−m)!n!​≡qym!​⋅qz(n−m)!​qxn!​​⋅qx−y−z(modqr), (q∈prime) 若 xxx 取满足 qx∣n!q^x|n!qx∣n! 的最大非负整数（y,zy,zy,z 同理），那么我们就可以用逆元求解了 设 g(t)=xmax⁡ (qx∣t!), f(t)=t!qg(t) mod qrg(t)=x_{\\max}\\,(q^x|t!),\\ f(t)=\\frac{t!}{q^{g(t)}}\\bmod q^r g(t)=xmax​(qx∣t!), f(t)=qg(t)t!​modqr 则 g(t)=⌊tq⌋+g(⌊tq⌋)f(t)=f(⌊tq⌋)⋅(∏i=1, i≡0(modq)qri)⌊tqr⌋⋅(∏i=qr⌊tqr⌋+1, i≡0(modq)ti) mod qr\\begin{aligned}\\\\ g(t)&amp;=\\left\\lfloor\\frac{t}{q}\\right\\rfloor+g\\left(\\left\\lfloor\\frac{t}{q}\\right\\rfloor\\right)\\\\ f(t)&amp;=f\\left(\\left\\lfloor\\frac{t}{q}\\right\\rfloor\\right)\\cdot \\left(\\prod_{i=1,\\,i\\not\\equiv0\\pmod q}^{q^r}i\\right)^{\\left\\lfloor\\frac{t}{q^r}\\right\\rfloor} \\cdot\\left(\\prod_{i=q^r\\left\\lfloor\\frac{t}{q^r}\\right\\rfloor+1,\\,i\\not\\equiv0\\pmod q}^{t}i\\right) \\bmod{q^r} \\end{aligned} g(t)f(t)​=⌊qt​⌋+g(⌊qt​⌋)=f(⌊qt​⌋)⋅⎝⎛​i=1,i​≡0(modq)∏qr​i⎠⎞​⌊qrt​⌋⋅⎝⎜⎛​i=qr⌊qrt​⌋+1,i​≡0(modq)∏t​i⎠⎟⎞​modqr​ 这个东西严格证明过程比较繁琐，感性理解一下就好 举两个例子 当 q=3, r=5q=3,\\,r=5q=3,r=5 则 g(9)=⌊93⌋+g(⌊93⌋)=3+g(3)=3+1=4f(9)=f(⌊93⌋)⋅(∏i=1, i≡0(mod3)35i)⌊935⌋⋅(∏i=35⌊935⌋+1, i≡0(mod3)9i) mod 35=f(3)×1×(1×2×4×5×7×8) mod 243=2×1×2240 mod 243=4480 mod 243=34\\begin{aligned}\\\\ g(9)&amp;=\\left\\lfloor\\frac{9}{3}\\right\\rfloor+g\\left(\\left\\lfloor\\frac{9}{3}\\right\\rfloor\\right)=3+g(3)=3+1=4\\\\ f(9)&amp;=f\\left(\\left\\lfloor\\frac{9}{3}\\right\\rfloor\\right)\\cdot \\left(\\prod_{i=1,\\,i\\not\\equiv0\\pmod 3}^{3^5}i\\right)^{\\left\\lfloor\\frac{9}{3^5}\\right\\rfloor} \\cdot\\left(\\prod_{i=3^5\\left\\lfloor\\frac{9}{3^5}\\right\\rfloor+1,\\,i\\not\\equiv0\\pmod 3}^{9}i\\right) \\bmod{3^5}\\\\ &amp;=f(3)\\times1\\times(1\\times2\\times4\\times5\\times7\\times8) \\bmod{243}\\\\ &amp;=2\\times1\\times2240\\bmod{243}\\\\ &amp;=4480\\bmod{243}\\\\ &amp;=34 \\end{aligned} g(9)f(9)​=⌊39​⌋+g(⌊39​⌋)=3+g(3)=3+1=4=f(⌊39​⌋)⋅⎝⎛​i=1,i​≡0(mod3)∏35​i⎠⎞​⌊359​⌋⋅⎝⎜⎛​i=35⌊359​⌋+1,i​≡0(mod3)∏9​i⎠⎟⎞​mod35=f(3)×1×(1×2×4×5×7×8)mod243=2×1×2240mod243=4480mod243=34​ 当 q=2, r=3q=2,\\,r=3q=2,r=3 则 g(15)=⌊152⌋+g(⌊152⌋)=7+g(7)=7+4=11f(15)=f(⌊152⌋)⋅(∏i=1, i≡0(mod2)23i)⌊1523⌋⋅(∏i=23⌊1523⌋+1, i≡0(mod2)15i) mod 23=f(7)×(1×3×5×7)1×(9×11×13×15) mod 8=3×105×19305 mod 8=6081075 mod 8=3\\begin{aligned}\\\\ g(15)&amp;=\\left\\lfloor\\frac{15}{2}\\right\\rfloor+g\\left(\\left\\lfloor\\frac{15}{2}\\right\\rfloor\\right)=7+g(7)=7+4=11\\\\ f(15)&amp;=f\\left(\\left\\lfloor\\frac{15}{2}\\right\\rfloor\\right)\\cdot \\left(\\prod_{i=1,\\,i\\not\\equiv0\\pmod 2}^{2^3}i\\right)^{\\left\\lfloor\\frac{15}{2^3}\\right\\rfloor} \\cdot\\left(\\prod_{i=2^3\\left\\lfloor\\frac{15}{2^3}\\right\\rfloor+1,\\,i\\not\\equiv0\\pmod 2}^{15}i\\right) \\bmod{2^3}\\\\ &amp;=f(7)\\times(1\\times3\\times5\\times7)^1\\times(9\\times11\\times13\\times15) \\bmod{8}\\\\ &amp;=3\\times105\\times19305\\bmod{8}\\\\ &amp;=6081075\\bmod{8}\\\\ &amp;=3 \\end{aligned} g(15)f(15)​=⌊215​⌋+g(⌊215​⌋)=7+g(7)=7+4=11=f(⌊215​⌋)⋅⎝⎛​i=1,i​≡0(mod2)∏23​i⎠⎞​⌊2315​⌋⋅⎝⎜⎛​i=23⌊2315​⌋+1,i​≡0(mod2)∏15​i⎠⎟⎞​mod23=f(7)×(1×3×5×7)1×(9×11×13×15)mod8=3×105×19305mod8=6081075mod8=3​ 很容易看出，上面的 ggg 函数求值的时间复杂度为 Θ(log⁡qt)\\Theta(\\log_qt)Θ(logq​t)，fff 则为 O(qrlog⁡qt)\\text{O}(q^r\\log_qt)O(qrlogq​t) 所以，我们得到 (nm)≡n!qxm!qy⋅(n−m)!qz⋅qx−y−z≡f(n)f(m)⋅f(n−m)⋅qg(n)−g(m)−g(n−m)(modqr), (q∈prime)\\binom{n}{m}\\equiv\\frac{\\frac{n!}{q^x}}{\\frac{m!}{q^y}\\cdot\\frac{(n-m)!}{q^z}}\\cdot q^{x-y-z}\\equiv\\frac{f(n)}{f(m)\\cdot f(n-m)}\\cdot q^{g(n)-g(m)-g(n-m)} \\pmod{q^r},\\ (q\\in \\text{prime}) (mn​)≡qym!​⋅qz(n−m)!​qxn!​​⋅qx−y−z≡f(m)⋅f(n−m)f(n)​⋅qg(n)−g(m)−g(n−m)(modqr), (q∈prime) 综上方法即为 exLucas 的全过程 exLucas Code Empty! ","link":"https://imzzy1201.github.io/post/C4R_6YYKI/"},{"title":"笔记 - Catalan 数","content":" To live is to risk it at all. Catalan 数是个奇奇怪怪的数列，它十分常见，好多东西的结论都跟它相关。 形式 我们现在用 CiC_iCi​ 代表 Catalan 数列的第 iii 项，有如下定义： 递归定义 Cn=∑i=1nCi−1Cn−iC_n=\\sum_{i=1}^n C_{i-1}C_{n-i} Cn​=i=1∑n​Ci−1​Cn−i​ 递推关系 Cn=4n−2n+1Cn−1C_n=\\frac{4n-2}{n+1}C_{n-1} Cn​=n+14n−2​Cn−1​ 通向公式 Cn=1n+1(2nn)=(2nn)−(2nn+1)C_n=\\frac{1}{n+1}\\binom{2n}{n}=\\binom{2n}{n}-\\binom{2n}{n+1} Cn​=n+11​(n2n​)=(n2n​)−(n+12n​) 其前几项为： 1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190,⋯1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, \\cdots 1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190,⋯ 证明 下面给出上述几个定义等价的证明： 1. 通项公式 (2nn)−(2nn+1)=(2n)!(n!)2−(2n)!(n−1)!(n+1)!=(n+1)(2n)!−n(2n)!n!(n+1)!=(2n)!n!(n+1)!=1n+1(2nn)\\begin{aligned} \\binom{2n}{n}-\\binom{2n}{n+1}=&amp;\\frac{(2n)!}{(n!)^2}-\\frac{(2n)!}{(n-1)!(n+1)!}\\\\ =&amp;\\frac{(n+1)(2n)!-n(2n)!}{n!(n+1)!}=\\frac{(2n)!}{n!(n+1)!}\\\\ =&amp;\\frac{1}{n+1}\\binom{2n}{n} \\end{aligned} (n2n​)−(n+12n​)===​(n!)2(2n)!​−(n−1)!(n+1)!(2n)!​n!(n+1)!(n+1)(2n)!−n(2n)!​=n!(n+1)!(2n)!​n+11​(n2n​)​ 2. 通项公式与递推关系 Cn=1n+1(2nn)=(2n)!n!(n+1)!=(2n)(2n−1)(n)(n+1)⋅(2n−2)!(n−1)!n!=4n−2n+1Cn−1C_n=\\frac{1}{n+1}\\binom{2n}{n}=\\frac{(2n)!}{n!(n+1)!}=\\frac{(2n)(2n-1)}{(n)(n+1)}\\cdot\\frac{(2n-2)!}{(n-1)!n!}=\\frac{4n-2}{n+1}C_{n-1} Cn​=n+11​(n2n​)=n!(n+1)!(2n)!​=(n)(n+1)(2n)(2n−1)​⋅(n−1)!n!(2n−2)!​=n+14n−2​Cn−1​ 3. 通项公式与递归定义 下面证明充分条件（必要条件证法类似）： C0=1,Cn+1=∑i=0nCiCn−i⇒Cn=1n+1(2nn)C_0=1,C_{n+1}=\\sum_{i=0}^nC_iC_{n-i}\\Rightarrow C_n=\\frac{1}{n+1}\\binom{2n}{n} C0​=1,Cn+1​=i=0∑n​Ci​Cn−i​⇒Cn​=n+11​(n2n​) 证明： 令 xxx 为充分小的正实数，设数列 {Cn}\\{C_n\\}{Cn​} 的母函数 G(x)=∑i=0∞xiCiG(x)=\\sum_{i=0}^\\infin x^iC_i G(x)=i=0∑∞​xiCi​ 则有 G2(x)=(∑i=0∞xiCi)2=∑i=0nxiCi∑j=0∞xjCj=∑i=0∞∑j=0∞xi+jCiCj=∑i=0∞∑k=i∞xkCiCk−i=∑k=0∞xk∑i=0kCiCk−i=∑k=0∞xkCk+1G2(x)x=x∑k=0∞xkCk+1=∑k=0∞xk+1Ck+1=∑k=1∞xkCkG2(x)x+1=∑k=1∞xkCk+1=∑k=1∞xkCk+x0C0=∑k=0∞xkCk=G(x)\\begin{aligned} G^2(x)&amp;=\\left(\\sum_{i=0}^\\infin x^iC_i\\right)^2=\\sum_{i=0}^n x^iC_i\\sum_{j=0}^\\infin x^jC_j=\\sum_{i=0}^\\infin\\sum_{j=0}^\\infin x^{i+j}C_iC_j\\\\ &amp;=\\sum_{i=0}^\\infin\\sum_{k=i}^\\infin x^kC_iC_{k-i}=\\sum_{k=0}^\\infin x^k\\sum_{i=0}^kC_iC_{k-i}\\\\ &amp;=\\sum_{k=0}^\\infin x^kC_{k+1}\\\\ G^2(x)x&amp;=x\\sum_{k=0}^\\infin x^kC_{k+1}=\\sum_{k=0}^\\infin x^{k+1}C_{k+1}=\\sum_{k=1}^\\infin x^kC_k\\\\ G^2(x)x+1&amp;=\\sum_{k=1}^\\infin x^kC_k+1=\\sum_{k=1}^\\infin x^kC_k+x^0C_0=\\sum_{k=0}^\\infin x^kC_k=G(x) \\end{aligned} G2(x)G2(x)xG2(x)x+1​=(i=0∑∞​xiCi​)2=i=0∑n​xiCi​j=0∑∞​xjCj​=i=0∑∞​j=0∑∞​xi+jCi​Cj​=i=0∑∞​k=i∑∞​xkCi​Ck−i​=k=0∑∞​xki=0∑k​Ci​Ck−i​=k=0∑∞​xkCk+1​=xk=0∑∞​xkCk+1​=k=0∑∞​xk+1Ck+1​=k=1∑∞​xkCk​=k=1∑∞​xkCk​+1=k=1∑∞​xkCk​+x0C0​=k=0∑∞​xkCk​=G(x)​ 则 G(x)=G2(x)x+1G(x)=G^2(x)x+1\\\\ G(x)=G2(x)x+1 解得 G(x)=1±1−4x2xG(x)=\\frac{1\\pm\\sqrt{1-4x}}{2x} G(x)=2x1±1−4x​​ 那么现在我们讨论 G1(x)=1−1−4x2xG_1(x)=\\dfrac{1-\\sqrt{1-4x}}{2x}G1​(x)=2x1−1−4x​​ 和 G2(x)=1+1−4x2xG_2(x)=\\dfrac{1+\\sqrt{1-4x}}{2x}G2​(x)=2x1+1−4x​​： #1. G(x)=1−1−4x2xG(x)=\\dfrac{1-\\sqrt{1-4x}}{2x}G(x)=2x1−1−4x​​ 引入广义二项式定理 (1+x)α=∑k=0∞(αk)xk(1+x)^\\alpha=\\sum_{k=0}^\\infin\\binom{\\alpha}{k}x^k (1+x)α=k=0∑∞​(kα​)xk 其中 (αk)=∏i=1kα−i+1i\\binom{\\alpha}{k}=\\prod_{i=1}^k\\frac{\\alpha-i+1}{i}\\\\ (kα​)=i=1∏k​iα−i+1​ 则 G(x)=1−∑k=0∞(12k)(−4x)k2x=1−1−∑k=1∞(12k)(−4x)k2x=−12∑k=1∞(12k)(−4)kxk−1=−12∑k=0∞(12k+1)(−4)k+1xk=2∑k=0∞(12k+1)(−4x)kCn=2(12n+1)(−4)n=2∏i=1n+112−i−1i(−4)n=2∏i=0n(12−i)(n+1)!(−1)n22n=∏i=0n(1−2i)(n+1)!(−1)n2n=∏i=1n(−1)(1−2i)(n+1)!2n=∏i=1n(2i−1)(n+1)!2n=(2n−1)!!(n+1)!2n\\begin{aligned} G(x)&amp;=\\frac{1-\\sum_{k=0}^\\infin\\binom{\\frac12}{k}(-4x)^k}{2x}=\\frac{1-1-\\sum_{k=1}^\\infin\\binom{\\frac12}{k}(-4x)^k}{2x}\\\\ &amp;=-\\frac{1}{2}\\sum_{k=1}^\\infin\\binom{\\frac12}{k}(-4)^kx^{k-1}=-\\frac{1}{2}\\sum_{k=0}^\\infin\\binom{\\frac12}{k+1}(-4)^{k+1}x^k\\\\ &amp;=2\\sum_{k=0}^\\infin\\binom{\\frac12}{k+1}(-4x)^k\\\\ C_n&amp;=2\\binom{\\frac12}{n+1}(-4)^n=2\\prod_{i=1}^{n+1}\\frac{\\frac12-i-1}{i}(-4)^n=2\\frac{\\prod_{i=0}^{n}(\\frac{1}{2}-i)}{(n+1)!}(-1)^n2^{2n}\\\\ &amp;=\\frac{\\prod_{i=0}^{n}(1-2i)}{(n+1)!}(-1)^n2^n=\\frac{\\prod_{i=1}^{n}(-1)(1-2i)}{(n+1)!}2^n=\\frac{\\prod_{i=1}^{n}(2i-1)}{(n+1)!}2^n\\\\ &amp;=\\frac{(2n-1)!!}{(n+1)!}2^n \\end{aligned}\\\\ G(x)Cn​​=2x1−∑k=0∞​(k21​​)(−4x)k​=2x1−1−∑k=1∞​(k21​​)(−4x)k​=−21​k=1∑∞​(k21​​)(−4)kxk−1=−21​k=0∑∞​(k+121​​)(−4)k+1xk=2k=0∑∞​(k+121​​)(−4x)k=2(n+121​​)(−4)n=2i=1∏n+1​i21​−i−1​(−4)n=2(n+1)!∏i=0n​(21​−i)​(−1)n22n=(n+1)!∏i=0n​(1−2i)​(−1)n2n=(n+1)!∏i=1n​(−1)(1−2i)​2n=(n+1)!∏i=1n​(2i−1)​2n=(n+1)!(2n−1)!!​2n​ 又 (2n)!=(2n)!!×(2n−1)!!=(2n−1)!!×2nn!(2n)!=(2n)!!\\times(2n-1)!!=(2n-1)!!\\times2^nn! (2n)!=(2n)!!×(2n−1)!!=(2n−1)!!×2nn! 所以 Cn=(2n−1)!!2n(n+1)!=(2n)!n!(n+1)!=1n+1(2n)!(n!)2=1n+1(2nn)\\begin{aligned} C_n&amp;=\\frac{(2n-1)!!2^n}{(n+1)!}=\\frac{(2n)!}{n!(n+1)!}=\\frac{1}{n+1}\\frac{(2n)!}{(n!)^2}=\\frac{1}{n+1}\\binom{2n}{n} \\end{aligned}\\\\ Cn​​=(n+1)!(2n−1)!!2n​=n!(n+1)!(2n)!​=n+11​(n!)2(2n)!​=n+11​(n2n​)​ #2. G(x)=1−1−4x2xG(x)=\\dfrac{1-\\sqrt{1-4x}}{2x}G(x)=2x1−1−4x​​ 同 #1 可得 G(x)=1+∑k=0∞(12k)(−4x)k2x=1x−2∑k=0∞(12k+1)(−4x)kG(x)=\\frac{1+\\sum_{k=0}^\\infin\\binom{\\frac12}{k}(-4x)^k}{2x}=\\frac{1}{x}-2\\sum_{k=0}^\\infin\\binom{\\frac12}{k+1}(-4x)^k G(x)=2x1+∑k=0∞​(k21​​)(−4x)k​=x1​−2k=0∑∞​(k+121​​)(−4x)k 然而，很明显母函数 G(x)G(x)G(x) 没有 x−1x^{-1}x−1 项，所以此情况不成立（舍） 综上，#1 得到 Cn=1n+1(2nn)C_n=\\dfrac{1}{n+1}\\dbinom{2n}{n}Cn​=n+11​(n2n​)，#2 舍去，即命题成立 证毕. 参考文献：Catalan numbers Code 一行 inline ll catalan(int n) {return (C(2*n,n)+mod-C(2*n,n+1))%mod;} 应用 其实许多其应用都能很清晰得说明 通项公式与递归定义 之间的等价关系，下面在 #1 举个例，往后类似 1. 括号匹配问题 nnn 对括号能组成多少个合法括号串？ 合法括号串的定义： 空串是合法括号串 若 AAA 是合法括号串，那么 (A)(A)(A) 也是合法括号串，称这里的左右两括号匹配 若 A,BA,BA,B 均为合法括号串，那么 ABABAB 也是合法括号串 其余串均不为合法括号串 n=3n=3n=3 时的所有合法括号串如下： 1.((())) 2.(()()) 3.(())() 4.()(()) 5.()()() 设答案为 F(n)F(n)F(n)，考虑下面两种方法说明 F(n)=CnF(n)=C_nF(n)=Cn​ #1. 递归定义法 采用第二数学归纳法证明： 当 n=0n=0n=0 时，F(n)=Cn=1F(n)=C_n=1F(n)=Cn​=1，即命题成立 假设当 n≤k (k∈N+)n\\le k\\ (k\\in N_+)n≤k (k∈N+​) 时，命题成立 下面证明 n=k+1n=k+1n=k+1 时命题成立： 考虑一个合法括号串 SSS，令 SiS_iSi​ 表示 SSS 的第 iii 项： 因为 k&gt;1k&gt;1k&gt;1，所以 SSS 不为空串 考虑 S1S_1S1​ 的值，因为所有合法括号串都不可能以 ) 开头，所以 S1=S_1=S1​= ( 枚举 S1S_1S1​ 的匹配括号，设 S1S_1S1​ 与 SiS_iSi​ 匹配，因为合法括号串必定有偶数个字符，所以我们设 i=2k+1i=2k+1i=2k+1，则 S1S_1S1​ 与 SiS_iSi​ 间的 2k2k2k 个字符必定构成合法括号串，而 SiS_iSi​ 往后的 2(n−k−1)2(n-k-1)2(n−k−1) 也必定构成合法括号串。即若 S1S_1S1​ 与 SiS_iSi​ 匹配，则共 F(k)F(n−k−1)=CkCn−k−1F(k)F(n-k-1)=C_kC_{n-k-1}F(k)F(n−k−1)=Ck​Cn−k−1​ 种构造方法 再考虑两个合法括号串 S1,S2S1,S2S1,S2，若 S11S1_1S11​ 的匹配括号为 S1iS1_iS1i​，S21S2_1S21​ 的匹配括号为 S2jS2_jS2j​，且 i≠ji\\neq ji​=j，易得 S1≠S2S1\\neq S2S1​=S2 因此，F(n)=∑k=0n−1CkCn−k−1=CnF(n)=\\sum\\limits_{k=0}^{n-1}C_kC_{n-k-1}=C_nF(n)=k=0∑n−1​Ck​Cn−k−1​=Cn​ 证毕. #2. 通项公式法 考虑用 111 表示左括号，−1-1−1 表示右括号，我们可以将问题归约为： 串 SSS 满足 ∀i≤2n,(∑k=1iSk)≥0\\forall i\\le2n,\\left(\\sum\\limits_{k=1}^i S_k\\right)\\ge0 ∀i≤2n,(k=1∑i​Sk​)≥0 考虑共 2n2n2n 个位置，我们选出其中 nnn 个位置放 111，剩下放 −1-1−1，即 (2nn)\\dbinom{2n}{n}(n2n​) 种放法 现在我们去掉不合法的情况（下面讨论的所有“不合法情况”默认串中有各 nnn 个 111 和 −1-1−1） 若其不合法，则必定存在最小的 ppp，使得 (∑k=1pSk)=−1\\left(\\sum\\limits_{k=1}^p S_k\\right)=-1 (k=1∑p​Sk​)=−1 即串 S1∼(p−1)S_{1\\sim (p-1)}S1∼(p−1)​ 合法，而 Sp=−1S_{p}=-1Sp​=−1 那么若我们将 S(p+1)∼2nS_{(p+1)\\sim 2n}S(p+1)∼2n​ 的所有数取负，得到一个新的生成串 S′S&#x27;S′，可以发现每个 S′S&#x27;S′ 中都含有 n+1n+1n+1 个 −1-1−1 和 n−1n-1n−1 个 111。 若我们枚举每个含有 n+1n+1n+1 个 −1-1−1 和 n−1n-1n−1 个 111 的生成串 S′S&#x27;S′，则可以得到一个神奇的结论：每个 S′S&#x27;S′ 必定对应唯一一个不合法的 SSS 考虑证明： 存在性 因为 S′S&#x27;S′ 有 n+1n+1n+1 个 −1-1−1 和 n−1n-1n−1 个 111，所以必定存在一个最小的 ppp，使得(∑k=1pSk′)=−1\\left(\\sum\\limits_{k=1}^p S&#x27;_k\\right)=-1 (k=1∑p​Sk′​)=−1 我们再对生成串 S(p+1)∼2n′S&#x27;_{(p+1)\\sim 2n}S(p+1)∼2n′​ 的所有数取负，则得到原串 SSS 刚好各 nnn 个 111 和 −1-1−1，且 SSS 必定是一个不合法串，因为(∑k=1pSk)=−1\\left(\\sum\\limits_{k=1}^p S_k\\right)=-1 (k=1∑p​Sk​)=−1 唯一性 因为每个原不合法串 SSS 生成其对应 S′S&#x27;S′ 串的方法唯一，所以不存在两个生成串对应同一个原串 至此，我们证明了每个含有 n+1n+1n+1 个 −1-1−1 和 n−1n-1n−1 个 111 的生成串 S′S&#x27;S′ 必定对应唯一一个不合法的 SSS 因为我们要在 2n2n2n 个位置中选 n+1n+1n+1 个位置放 −1-1−1，其余放 111，所以得到共 (2nn+1)\\dbinom{2n}{n+1}(n+12n​) 种生成串，即共 (2nn+1)\\dbinom{2n}{n+1}(n+12n​) 种不合法串 那么合法串的数量应等于总数量 −-− 不合法数量，即 F(n)=(2nn)−(2nn+1)=CnF(n)=\\binom{2n}{n}-\\binom{2n}{n+1}=C_n F(n)=(n2n​)−(n+12n​)=Cn​ 证毕. 2. 进出栈问题 一个无穷大的栈，进栈队列为 1,2,3,⋯ ,n1,2,3,\\cdots,n1,2,3,⋯,n，问有多少种不同的出栈序列 关于栈的定义可尝试 搜索引擎 这里我们归约为括号匹配问题： 每个括号串表示一条指令，( 表示队首元素入栈，) 表示栈顶元素出栈 可以发现，每个合法括号串都对应唯一一种进出栈策略，并且这个进出栈策略必定合法 唯一性很显然，合法性下面给出证明： 考虑不合法的情况无非 222 种，一种是所有元素进栈后还在发出“进栈”指令，另一种是栈中没有元素了还发出“出栈”指令 对于情况一，因为合法括号串只有 nnn 个 (，所以只进栈 nnn 次，不可能出现此情况 对于情况二，考虑到每个 ) 之前都与一个 ( 相匹配，即每次出栈指令都有一个进栈指令与其匹配，所以也不可能出现此情况 综上，我们将进出栈问题规约为了括号匹配问题 3. 二叉树种类问题 nnn 个无序节点构成的二叉树共多少种 我们设 nnn 个无序节点构成的二叉树共 F(n)F(n)F(n) 种，下面证明 F(n)=CnF(n)=C_nF(n)=Cn​ 再次考虑第二数学归纳法证明： 当 n=0n=0n=0 时，只有一种情况即空二叉树，所以 F(n)=Cn=1F(n)=C_n=1F(n)=Cn​=1，即命题成立 假设当 n≤k (k∈N+)n\\le k\\ (k\\in N_+)n≤k (k∈N+​) 时，命题成立 下面证明 n=k+1n=k+1n=k+1 时命题成立： 我们先按中序遍历的顺序给每个节点编号 考虑枚举树根为 1∼n1\\sim n1∼n 的情况，若树根为 iii，则 1∼(i−1)1\\sim (i-1)1∼(i−1) 这 i−1i-1i−1 个节点为 iii 的左子树，而 (i+1)∼n(i+1)\\sim n(i+1)∼n 这 n−in-in−i 个节点为 iii 的右子树，即以 iii 为根的二叉树共 F(i−1)F(n−i)=Ci−1Cn−iF(i-1)F(n-i)=C_{i-1}C_{n-i}F(i−1)F(n−i)=Ci−1​Cn−i​ 种情况 因此，我们得到F(n)=∑i=1nCi−1Cn−i=CnF(n)=\\sum_{i=1}^nC_{i-1}C_{n-i}=C_n F(n)=i=1∑n​Ci−1​Cn−i​=Cn​ 即命题成立 证毕. 附： 中序遍历（LDR）是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。如下图二叉树中序遍历顺序为 4 2 8 5 9 1 6 3 7 10 4. 网格路径问题 对于一个 n×nn\\times nn×n 的正方形网格，每次我们能沿着网格向右或者向上移动一格，那么从左下角到右上角的所有在对角线下方的路径总数为多少？ 举个例子，下图列举了所有 n=4n=4n=4 时的情况： 继续考虑规约，我们将归约为进出栈问题，进栈为向右走，出栈为向上走，下面证明每种进出栈策略与网格路径一一对应： 唯一性也很显然，合法性下面给出证明： 考虑网格路径问题也可以理解为每一步走完后保证竖向路径个数小于等于横向路径个数（即在对角线下方），且走到右上角时竖向路径与横向路径均为 nnn 条（在网格上走） 而每种进出栈策略也满足每一步栈中元素个数大于等于 000，即进栈数大于等于出栈数；一共 nnn 个元素进出栈各 111 次，即进出栈数均为 nnn 所以我们发现进出栈策略的条件与网格路径的条件是一致的，所以每种进出栈策略对应的网格路径均合法 5. 凸多边形分割问题 求一个凸 nnn 边形区域划分成三角形区域的方法数 举个例子，下图列举了 n=6n=6n=6 时的所有方案： 设凸 n (n≥2)n\\ (n\\ge2)n (n≥2) 边形的划分方法共 F(n)F(n)F(n) 种，下面证明 F(n)=Cn−2F(n)=C_{n-2}F(n)=Cn−2​ 同样考虑第二数学归纳法证明： 当 n=2n=2n=2 时，不存在这样的凸 nnn 边形，所以有唯一一种情况就是不分，F(n)=Cn−2=1F(n)=C_{n-2}=1F(n)=Cn−2​=1，即命题成立 假设当 n≤k (k&gt;2)n\\le k\\ (k&gt;2)n≤k (k&gt;2) 时，命题成立 下面证明 n=k+1n=k+1n=k+1 时命题成立： 我们先顺时针给这个凸 nnn 边形的顶点编号 选取一条边 1−21-21−2，显然这条边必定在唯一一个三角形中（也很明显，若两种方案中 1−21-21−2 所在的三角形不同则两方案也不同，即枚举其所在三角形可以保证不重复不遗漏） 这个三角形的其中两个顶点就是 111 和 222，所以我们枚举第三个顶点 设第三个顶点为 iii，则我们发现如果把这个三角形切掉之后会剩下两个凸多边形，一个为 i−1i-1i−1 边形（顶点分别为 2,3,⋯ ,i2,3,\\cdots,i2,3,⋯,i），另一个为 n−i+2n-i+2n−i+2 边形（顶点分别为 i,i+1,⋯ ,n,1i,i+1,\\cdots,n,1i,i+1,⋯,n,1） 所以可得F(n)=∑i=3nF(i−1)F(n−i+2)=∑i=3nCi−3Cn−i=∑i=0n−3CiC(n−3)−i=Cn−2F(n)=\\sum_{i=3}^nF(i-1)F(n-i+2)=\\sum_{i=3}^nC_{i-3}C_{n-i}=\\sum_{i=0}^{n-3}C_iC_{(n-3)-i}=C_{n-2} F(n)=i=3∑n​F(i−1)F(n−i+2)=i=3∑n​Ci−3​Cn−i​=i=0∑n−3​Ci​C(n−3)−i​=Cn−2​ 证毕. 附图： 6. 连线不相交问题 在圆上选择 2n2n2n 个点，这些点两两连接使得所得到的 nnn 条线段不相交，求方案数 举个例子，下图列举了 n=4n=4n=4 的所有方案： 设圆上 2n2n2n 个点两两连线不相交方案数为 F(n)F(n)F(n)，下面证明 F(n)=CnF(n)=C_nF(n)=Cn​ 依然是第二数学归纳法： 当 n=0n=0n=0 时，圆上没有点，所以有唯一一种情况就是不连线，即 F(n)=Cn=1F(n)=C_n=1F(n)=Cn​=1，命题成立 假设当 n≤k (k∈N+)n\\le k\\ (k\\in N_+)n≤k (k∈N+​) 时，命题成立 下面证明 n=k+1n=k+1n=k+1 时命题成立： 我们先顺时针给这 nnn 个点编号，我们讨论与 111 相连的点 iii 首先 iii 必定为偶数。因为 iii 若为奇数，则 111 至 iii 有奇数个点，这些点的连线不能跨越 1−i1-i1−i 这条线，而奇数个点又是不可能两两连接的，所以不成立 那么设 i=2j+1i=2j+1i=2j+1，则 1−i1-i1−i 的左边有 2j2j2j 个点，右边有 2(n−j−1)2(n-j-1)2(n−j−1) 个点，即共 F(j)F(2(n−j−1)F(j)F(2(n-j-1)F(j)F(2(n−j−1) 种方案 所以有F(n)=∑j=0n−1F(j)F(n−j−1)=∑j=0n−1CjCn−j−1=CnF(n)=\\sum_{j=0}^{n-1}F(j)F(n-j-1)=\\sum_{j=0}^{n-1}C_jC_{n-j-1}=C_n F(n)=j=0∑n−1​F(j)F(n−j−1)=j=0∑n−1​Cj​Cn−j−1​=Cn​ 证毕. 附图： 7. 阶梯切割问题 求 nnn 个矩形填充一个高度为 nnn 的阶梯状图形的方案数 举个例子，下图列举了 n=4n=4n=4 的所有方案 设 nnn 阶阶梯共 F(n)F(n)F(n) 种方案，下面证明 F(n)=CnF(n)=C_nF(n)=Cn​ 第 二 数 学 归 纳 法 当 n=0n=0n=0 时，没有阶梯，所以有唯一一种情况就是不填矩形，即 F(n)=Cn=1F(n)=C_n=1F(n)=Cn​=1，命题成立 假设当 n≤k (k∈N+)n\\le k\\ (k\\in N_+)n≤k (k∈N+​) 时，命题成立 下面证明 n=k+1n=k+1n=k+1 时命题成立： 考虑如下图中灰色的 nnn 个阶梯顶端的格子 它们一定互不在一个矩形内，因为这之中任意两个如果在一个矩形内那那个矩形必定从阶梯的右上方超出阶梯 我们再枚举阶梯左下角的格子（如图中绿格）所在的矩形。若它包含从上往下数第 iii 个灰格子，那么它上面就隔离出了一个 i−1i-1i−1 阶的阶梯，右边隔离出了一个 n−in-in−i 阶的阶梯，即共 F(i−1)F(n−i)F(i-1)F(n-i)F(i−1)F(n−i) 种方案 所以有F(n)=∑i=1nF(i−1)F(n−i)=∑i=1nCi−1Cn−i=CnF(n)=\\sum_{i=1}^nF(i-1)F(n-i)=\\sum_{i=1}^nC_{i-1}C_{n-i}=C_n F(n)=i=1∑n​F(i−1)F(n−i)=i=1∑n​Ci−1​Cn−i​=Cn​ 证毕. 8. 格子填数问题 在一个 2×n2\\times n2×n 的格子中填入 111 到 2n2n2n 这些数，求使得每个格子内的数值都比其左上方的所有数值小的情况数 举个例子，下表列举了所有 n=4n=4n=4 的情况 1 2 3 4 1 2 3 5 1 2 3 6 1 2 3 7 1 2 4 5 1 2 4 6 1 2 4 7 5 6 7 8 4 6 7 8 4 5 7 8 4 5 6 8 3 6 7 8 3 5 7 8 3 5 6 8 1 2 5 6 1 2 5 7 1 3 4 5 1 3 4 6 1 3 4 7 1 3 5 6 1 3 5 7 3 4 7 8 3 4 6 8 2 6 7 8 2 5 7 8 2 5 6 8 2 4 7 8 2 4 6 8 考虑规约至括号匹配问题，我们枚举每个长度为 2n2n2n 的合法括号串 SSS，其对应的填数方案：若 SiS_iSi​ 为 ( 则 iii 格子放第一行，为 ) 则放第二行（因为格子里的每行都是有序的，所以我们顺着放就好） 比如串 ()(()()) 对应的填数方案为： 1 3 4 6 2 5 7 8 我们证明合法括号串和填数策略可如上一一对应： 唯一性亦很容易证明，我们主要看合法性的证明 首先，可以肯定此合法括号串有各 nnn 个 ( 和 )，即其对应的填数策略填满了两行 然后我们发现对于每个位置 k≤2nk\\le2nk≤2n 合法括号串必然满足 ∑i=1k[Si=( ] ≥ ∑i=1k[Si=) ]\\sum_{i=1}^k[S_i=\\texttt{\\color{brown}(}\\ ]\\ \\ge\\ \\sum_{i=1}^k[S_i=\\texttt{\\color{brown})}\\ ] i=1∑k​[Si​=( ] ≥ i=1∑k​[Si​=) ] 即前 kkk 个字符中 ( 的个数大于等于 ) 的个数，放在格子填数的方案里对应的就是小于等于 kkk 的数至少一半在第一行 所以对于每一个在第二行数都有至少一半小于等于它的数在第一行所以它的左上方的所有数都比它小，满足其要求 综上，我们已将格子填数问题规约至括号匹配问题 证毕. ","link":"https://imzzy1201.github.io/post/QhLY5-IRd/"},{"title":"杂题 - BZOJ2839 集合计数","content":" S={x:x∉x}S=\\{x:x\\notin x\\}S={x:x∈/​x} 🤔 题面（黑暗爆炸OJ） 前置知识 集合相关内容 二项式反演 思路 考虑转换为计算“钦定”的值：先求 fif_ifi​ 表示钦定交集有 iii 个元素，即选出的子集的交集包含选定 iii 个元素的方案数。 首先，nnn 个元素中选出 iii 个元素，即有 CniC_n^iCni​ 种选法。然后，我们固定每个选取的子集都包含这 iii 个元素，剩下的可选可不选。对于其中一个子集，因为剩下共 n−in-in−i 个元素，每个元素都可以选或不选，所以共 2n−i2^{n-i}2n−i 种子集可供选择。而这 2n−i2^{n-i}2n−i 种子集中每个子集又都可以选取或不选取，所以共 22n−12^{2^{n-1}}22n−1 种选取方案，排除什么都不选的一种情况，即共 22n−1−12^{2^{n-1}}-122n−1−1 种情况。 至此，我们得到： fi=(ni)(22n−1−1)f_i=\\dbinom{n}{i}\\left(2^{2^{n-1}}-1\\right) fi​=(in​)(22n−1−1) 再回头来，若定义 gig_igi​ 为交集元素刚好 iii 个的取法，即题目所求，因为每种交集元素个数为 jjj 的方案都被重复计算 CjiC_j^iCji​ 次，所以： fi=∑j=in(ji)gjf_i=\\sum\\limits_{j=i}^n\\dbinom{j}{i}g_j fi​=j=i∑n​(ij​)gj​ 套用二项式反演的公式，得到： gk=∑i=kn(−1)i−k(ik)fi=∑i=kn(−1)i−k(ik)(ni)(22n−i−1)\\begin{aligned}\\\\ g_k&amp;=\\sum\\limits_{i=k}^n(-1)^{i-k}\\dbinom{i}{k}f_i\\\\ &amp;=\\sum\\limits_{i=k}^n(-1)^{i-k}\\dbinom{i}{k}\\dbinom{n}{i}\\left(2^{2^{n-i}}-1\\right) \\end{aligned} gk​​=i=k∑n​(−1)i−k(ki​)fi​=i=k∑n​(−1)i−k(ki​)(in​)(22n−i−1)​ 注意：这里的 22n−i2^{2^{n-i}}22n−i 不建议快速幂，可以倒序递推：22x+1=(22x)22^{2^{x+1}}=(2^{2^x})^222x+1=(22x)2 Code #include&lt;bits/stdc++.h&gt; #define ll long long #define rgi register int #define rgl register ll #define mian main struct fastin{ int _ch,_f; inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; struct fastout{ #define endl '\\n' int _num[32],_head; inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=1000004,maxm=1000004; const int mod=1000000007,inf=1000000007; const int debug=0; inline ll powmod(ll a,ll b) { ll res=1; while(b) { if(b&amp;1) (res*=a)%=mod; (a*=a)%=mod,b&gt;&gt;=1; } return res; } inline ll inv(ll a) {return powmod(a,mod-2);} ll fact[maxn],invfact[maxn]; inline void init() { fact[0]=invfact[0]=1; for(rgi i=1;i&lt;maxn;++i) fact[i]=fact[i-1]*i%mod,invfact[i]=inv(fact[i]); } inline ll C(ll n,ll m) {return fact[n]*invfact[m]%mod*invfact[n-m]%mod;} signed main() { int n,k; fin&gt;&gt;n&gt;&gt;k; ll ans=0,tmp=2; init(); for(rgi i=n;i&gt;=k;--i) ans+=((i-k)&amp;1?(mod-1LL):1LL)*C(i,k)%mod*C(n,i)%mod*(tmp-1)%mod, (tmp*=tmp)%=mod,ans%=mod; fout&lt;&lt;ans; return 0; } // ---------------------------- // by imzzy ","link":"https://imzzy1201.github.io/post/qUuCFD8g0/"},{"title":"笔记 - 二项式反演","content":" You aren't fully capable of deciding your own destiny. 二项式反演，即式项二 算是反演系列知识点中最简单最好背的之一 码量小，证明简单，还很好理解 形式 先给出来式子： 从 000 到 nnn ： ①fn=∑i=0n(−1)i(ni)gi⇔gn=∑i=0n(−1)i(ni)fi\\tag*{①} \\large \\begin{aligned}\\\\ f_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_i\\\\ \\end{aligned} fn​=i=0∑n​(−1)i(in​)gi​​⇔gn​=i=0∑n​(−1)i(in​)fi​​① ②亦作 fn=∑i=0n(ni)gi⇔gn=∑i=0n(−1)n−i(ni)fi\\tag*{②} \\normalsize\\textsf{亦作}\\ \\large \\begin{aligned}\\\\ f_n=\\sum\\limits_{i=0}^n\\dbinom{n}{i}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=0}^n (-1)^{n-i} \\dbinom{n}{i} f_i\\\\ \\end{aligned} 亦作 fn​=i=0∑n​(in​)gi​​⇔gn​=i=0∑n​(−1)n−i(in​)fi​​② 从 nnn 到 mmm ： ③fn=∑i=nm(−1)i(in)gi⇔gn=∑i=nm(−1)i(in)fi\\tag*{③} \\large \\begin{aligned}\\\\ f_n=\\sum\\limits_{i=n}^m(-1)^i\\dbinom{i}{n}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=n}^m(-1)^i\\dbinom{i}{n}f_i \\\\ \\end{aligned} fn​=i=n∑m​(−1)i(ni​)gi​​⇔gn​=i=n∑m​(−1)i(ni​)fi​​③ ④亦作 fn=∑i=nm(in)gi⇔gn=∑i=nm(−1)i−n(in)fi\\tag*{④} \\normalsize\\textsf{亦作}\\ \\large \\begin{aligned}\\\\ f_n=\\sum\\limits_{i=n}^m\\dbinom{i}{n}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=n}^m (-1)^{i-n} \\dbinom{i}{n} f_i \\\\ \\end{aligned} 亦作 fn​=i=n∑m​(ni​)gi​​⇔gn​=i=n∑m​(−1)i−n(ni​)fi​​④ 这些式子看起来又对称又妙，妙得都看不出来有啥用 好吧其实还是很有用的，具体用法参见例题 证明 现在先说它的证明 方法 1 把它想象成一个特殊的容斥 这里引用一下 GXZlegend 的博客 中的证明（稍有修改）： 既然形式和多步容斥相似，我们就从多步容斥讲起 我们都知道：∣A∪B∣=∣A∣+∣B∣−∣A∩B∣|A\\cup B|=|A|+|B|−|A\\cap B|∣A∪B∣=∣A∣+∣B∣−∣A∩B∣ ，这其实就是容斥原理 记用来容斥的 mmm 个集合为 A1,A2⋯AmA_1,A_2\\cdots A_mA1​,A2​⋯Am​ 中它的一般形式为： ∣A1∪A2∪⋯∪Am∣=∑1≤i≤m∣Ai∣−∑1≤i&lt;j≤m∣Ai∩Aj∣+∑1≤i&lt;j&lt;k≤m∣Ai∩Aj∩Ak∣−⋯+(−1)n−1×∣A1∩A2∩⋯∩Am∣|A_1\\cup A_2\\cup \\cdots \\cup A_m|=\\sum\\limits_{1\\le i\\le m} |A_i|−\\sum\\limits_{1\\le i&lt;j\\le m} |A_i\\cap A_j|+\\sum\\limits_{1\\le i&lt;j&lt;k\\le m} |A_i\\cap A_j\\cap A_k|-\\cdots+(−1)^{n−1}\\times |A_1\\cap A_2\\cap \\cdots \\cap A_m| ∣A1​∪A2​∪⋯∪Am​∣=1≤i≤m∑​∣Ai​∣−1≤i&lt;j≤m∑​∣Ai​∩Aj​∣+1≤i&lt;j&lt;k≤m∑​∣Ai​∩Aj​∩Ak​∣−⋯+(−1)n−1×∣A1​∩A2​∩⋯∩Am​∣ 或作 ∣⋃i=1mAi∣=∑k=1m(−1)k−1∑1≤i1&lt;i2&lt;⋯&lt;ik≤m∣Ai1∩Ai2∩⋯∩Aik∣\\left|\\bigcup\\limits_{i=1}^m A_i\\right|=\\sum\\limits_{k=1}^m (-1)^{k-1} \\sum\\limits_{1\\le i_1&lt;i_2&lt;\\cdots&lt;i_k\\le m}|A_{i_1}\\cap A_{i_2}\\cap\\cdots\\cap A_{i_k}| ∣∣∣∣∣​i=1⋃m​Ai​∣∣∣∣∣​=k=1∑m​(−1)k−11≤i1​&lt;i2​&lt;⋯&lt;ik​≤m∑​∣Ai1​​∩Ai2​​∩⋯∩Aik​​∣ 证明： 设某一元素被 mmm 个集合所包含，则其对左侧的贡献为 111 对右侧的贡献为 ∑i=1m(−1)i−1(mi)=−∑i=1m(−1)i(mi)=1−∑i=0m(−1)i(mi)=1−(1−1)m=1\\sum\\limits_{i=1}^m (−1)^{i−1}\\dbinom{m}{i}=−\\sum\\limits_{i=1}^m (−1)^i\\dbinom{m}{i}=1−\\sum\\limits_{i=0}^m (−1)^i \\dbinom{m}{i}=1−(1−1)^m=1i=1∑m​(−1)i−1(im​)=−i=1∑m​(−1)i(im​)=1−i=0∑m​(−1)i(im​)=1−(1−1)m=1 故左侧等于右侧 ，证毕 沿用刚刚多步容斥的公式，记 Ai‾\\overline{A_i}Ai​​ 表示 AiA_iAi​ 的补集，UUU 为全集，则将一般形式变形得： ∣A1‾∩A2‾∩⋯∩Am‾∣=∣U∣−∣A1∪A2∪⋯∪Am‾∣=∣U∣−∑1≤i≤m∣Ai∣+∑1≤i&lt;j≤m∣Ai∩Aj∣−⋯+(−1)m×∣A1∩A2∩⋯∩Am∣\\left|\\overline{A_1}\\cap \\overline{A_2} \\cap\\cdots\\cap \\overline{A_m}\\right|=|U|-\\left|\\overline{A_1\\cup A_2 \\cup\\cdots\\cup A_m}\\right|=|U|-\\sum\\limits_{1\\le i\\le m}|A_i|+\\sum\\limits_{1\\le i&lt;j\\le m}|A_i\\cap A_j|-\\cdots+(-1)^m\\times |A_1\\cap A_2\\cap\\cdots\\cap A_m| ∣∣​A1​​∩A2​​∩⋯∩Am​​∣∣​=∣U∣−∣∣​A1​∪A2​∪⋯∪Am​​∣∣​=∣U∣−1≤i≤m∑​∣Ai​∣+1≤i&lt;j≤m∑​∣Ai​∩Aj​∣−⋯+(−1)m×∣A1​∩A2​∩⋯∩Am​∣ 同时，由于补集的补集就是原集，因此又有： ∣A1∩A2∩⋯∩Am∣=∣U∣−∑1≤i≤m∣Ai‾∣+∑1≤i&lt;j≤m∣Ai‾∩Aj‾∣−⋯+(−1)m×∣A1‾∩A2‾∩⋯∩Am‾∣|A_1\\cap A_2\\cap\\cdots\\cap A_m|=|U|-\\sum\\limits_{1\\le i\\le m}\\left|\\overline{A_i}\\right|+\\sum\\limits_{1\\le i&lt;j\\le m}\\left|\\overline{A_i}\\cap\\overline{A_j}\\right|-\\cdots+(-1)^m\\times\\left|\\overline{A_1}\\cap\\overline{A_2}\\cap\\cdots\\cap\\overline{A_m}\\right| ∣A1​∩A2​∩⋯∩Am​∣=∣U∣−1≤i≤m∑​∣∣​Ai​​∣∣​+1≤i&lt;j≤m∑​∣∣​Ai​​∩Aj​​∣∣​−⋯+(−1)m×∣∣​A1​​∩A2​​∩⋯∩Am​​∣∣​ 考虑一种特殊情况：多个集合的交集大小只和集合的数目有关 记 f(n)f(n)f(n) 表示 nnn 个补集的交集的基数，g(n)g(n)g(n) 表示 nnn 个原集的交集的基数 形式化的表示： ∀1≤i1&lt;i2&lt;⋯&lt;in≤m ∣⋂j=1nAij‾∣=f(n),∣⋂j=1nAij∣=g(n)\\large \\forall _{1\\le i_1&lt;i_2&lt;\\cdots&lt;i_n\\le m}\\ \\normalsize\\left|\\bigcap\\limits_{j=1}^n \\overline{A_{i_j}}\\right|=f(n),\\left|\\bigcap\\limits_{j=1}^n A_{i_j}\\right|=g(n) ∀1≤i1​&lt;i2​&lt;⋯&lt;in​≤m​ ∣∣∣∣∣​j=1⋂n​Aij​​​∣∣∣∣∣​=f(n),∣∣∣∣∣​j=1⋂n​Aij​​∣∣∣∣∣​=g(n) 则上面两个公式可以分别表示为 f(n)=∑i=0n(−1)i(ni)g(i)g(n)=∑i=0n(−1)i(ni)f(i)f(n)=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g(i)\\\\g(n)=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f(i) f(n)=i=0∑n​(−1)i(in​)g(i)g(n)=i=0∑n​(−1)i(in​)f(i) 显然这两个公式是等价关系，更是相互推导的关系，于是我们得到了原 ①①① 式： fn=∑i=0n(−1)i(ni)gi⇔gn=∑i=0n(−1)i(ni)fif_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g_i\\Leftrightarrow g_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_i fn​=i=0∑n​(−1)i(in​)gi​⇔gn​=i=0∑n​(−1)i(in​)fi​ 方法 2 推式子！🤔 我们尝试由 fn=∑i=0n(−1)i(ni)gif_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g_ifn​=i=0∑n​(−1)i(in​)gi​ 推导至 gn=∑i=0n(−1)i(ni)fig_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_ign​=i=0∑n​(−1)i(in​)fi​（很明显这两个式子完全对称，证明了一个方向就可以证明充要性了）： ∵ fn=∑i=0n(−1)i(ni)gi∴∑i=0n(−1)i(ni)fi=∑i=0n(−1)i(ni)∑j=0i(−1)j(ij)gj=∑i=0n∑j=0i(−1)i+j(ni)(ij)gj=∑j=0ngj∑i=jn(−1)i+j(ni)(ij)=∑j=0ngj∑i=jn(−1)i+jn!i!(n−i)!×i!j!(i−j)!=∑j=0ngj∑i=jn(−1)i+jn!j!(n−j)!×(n−j)!(n−i)!(i−j)!=∑j=0ngj∑i=jn(−1)i+j(nj)(n−jn−i)=∑j=0n(nj)gj∑i=jn(−1)i+j(n−jn−i)又∵ ∀x∈Z+∑i=0x(−1)i(xi)=0∴ ∀j∈N∧j&lt;n∑i=jn(−1)i+j(n−jn−i)=0∴∑i=0n(−1)i(ni)fi=∑j=0n(nj)gj∑i=jn(−1)i+j(n−jn−i)=(nn)gn∑i=nn(−1)i+j(n−jn−i)=gn综上得到，fn=∑i=0n(−1)i(ni)gi⇔gn=∑i=0n(−1)i(ni)fi证毕.\\begin{aligned}\\\\ \\because &amp;\\ f_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g_i\\\\ \\therefore&amp;\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_i\\\\ =&amp;\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}\\sum\\limits_{j=0}^i(-1)^j\\dbinom{i}{j}g_j\\\\ =&amp;\\sum\\limits_{i=0}^n\\sum\\limits_{j=0}^i(-1)^{i+j}\\dbinom{n}{i}\\dbinom{i}{j}g_j\\\\ =&amp;\\sum\\limits_{j=0}^ng_j\\sum\\limits_{i=j}^n(-1)^{i+j}\\dbinom{n}{i}\\dbinom{i}{j}\\\\ =&amp;\\sum\\limits_{j=0}^ng_j\\sum\\limits_{i=j}^n(-1)^{i+j}\\dfrac{n!}{i!(n-i)!}\\times\\dfrac{i!}{j!(i-j)!}\\\\ =&amp;\\sum\\limits_{j=0}^ng_j\\sum\\limits_{i=j}^n(-1)^{i+j}\\dfrac{n!}{j!(n-j)!}\\times\\dfrac{(n-j)!}{(n-i)!(i-j)!}\\\\ =&amp;\\sum\\limits_{j=0}^ng_j\\sum\\limits_{i=j}^n(-1)^{i+j}\\dbinom{n}{j}\\dbinom{n-j}{n-i}\\\\ =&amp;\\sum\\limits_{j=0}^n\\dbinom{n}{j}g_j\\sum\\limits_{i=j}^n(-1)^{i+j}\\dbinom{n-j}{n-i}\\\\ 又&amp;\\because\\ \\large\\forall _{x\\in \\text{Z}^+} \\normalsize\\sum\\limits_{i=0}^{x}(-1)^i\\dbinom{x}{i}=0\\\\ \\therefore&amp;\\ \\large\\forall _{j\\in \\text{N}\\wedge j&lt;n} \\normalsize \\sum\\limits_{i=j}^n(-1)^{i+j}\\dbinom{n-j}{n-i}=0\\\\ \\therefore&amp;\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_i\\\\ =&amp;\\sum\\limits_{j=0}^n\\dbinom{n}{j}g_j\\sum\\limits_{i=j}^n(-1)^{i+j}\\dbinom{n-j}{n-i}\\\\ =&amp;\\dbinom{n}{n}g_n\\sum\\limits_{i=n}^n(-1)^{i+j}\\dbinom{n-j}{n-i}\\\\ =&amp;g_n\\\\ 综&amp;上得到，f_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g_i\\Leftrightarrow g_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_i\\\\ 证&amp;毕. \\end{aligned} ∵∴=======又∴∴===综证​ fn​=i=0∑n​(−1)i(in​)gi​i=0∑n​(−1)i(in​)fi​i=0∑n​(−1)i(in​)j=0∑i​(−1)j(ji​)gj​i=0∑n​j=0∑i​(−1)i+j(in​)(ji​)gj​j=0∑n​gj​i=j∑n​(−1)i+j(in​)(ji​)j=0∑n​gj​i=j∑n​(−1)i+ji!(n−i)!n!​×j!(i−j)!i!​j=0∑n​gj​i=j∑n​(−1)i+jj!(n−j)!n!​×(n−i)!(i−j)!(n−j)!​j=0∑n​gj​i=j∑n​(−1)i+j(jn​)(n−in−j​)j=0∑n​(jn​)gj​i=j∑n​(−1)i+j(n−in−j​)∵ ∀x∈Z+​i=0∑x​(−1)i(ix​)=0 ∀j∈N∧j&lt;n​i=j∑n​(−1)i+j(n−in−j​)=0i=0∑n​(−1)i(in​)fi​j=0∑n​(jn​)gj​i=j∑n​(−1)i+j(n−in−j​)(nn​)gn​i=n∑n​(−1)i+j(n−in−j​)gn​上得到，fn​=i=0∑n​(−1)i(in​)gi​⇔gn​=i=0∑n​(−1)i(in​)fi​毕.​ 其它 上面的两个方法只说明了 ①①① 式的证明，而事实上剩下的三个式子可以很容易从 ①①① 式边形得到，或也可用方法 2 类似的做法得到 扩展 二项式反演可以用 NTT 优化（还没学，学了马上写 Code Empty! ( 应用 套路 求“恰好 nnn 个”的答案困难，但求“选出 nnn 个”容易，然后通过“选出 nnn 个”再得到“钦定 nnn 个”（即选出 nnn 个之后，剩下的随便搞的方案数），而“钦定 nnn 个”与“恰好 nnn 个”刚好有二项式反演的形式（一般是 ②②② 或 ④④④ 式） 例题 BZOJ2839 - 集合计数 NOI Online R2 TG - T3 游戏 习题 BZOJ4710 / Luogu P5505 - 「JSOI2011」分特产 BZOJ3622 / Luogu P4859 - 已经没有什么好害怕的了 ","link":"https://imzzy1201.github.io/post/sdj9zeaTV/"},{"title":"NOI Online R2 TG 订正","content":" If you don't try, how can you know what it feels like to be desperate? 1. 概况 悲 T1 80pts 该死地用了某 __gcd。还好过了编，大概丢了 10 分？ T2 90pts 该死地被卡了常，丢 10 分。 T3 20pts 剩下的分我也不会。 总分 190pts，一般。 2. 题解 题解同期发布于我的 luogu 博客 T1 涂色游戏 题面（luogu） 前置知识 欧几里得算法 思路 因为 p1,p2≤109p_1,p_2\\le10^9p1​,p2​≤109，而我们有 102010^{20}1020 个格子， 所以 [p1,p2]≤p1p2&lt;1020[p_1,p_2]\\le p_1p_2&lt;10^{20}[p1​,p2​]≤p1​p2​&lt;1020，而每 [p1,p2][p_1,p_2][p1​,p2​] 个格子都是个循环节，即若第一个循环节范围内存在合法解，则后面的每个循环节都能按照此解来染色。 所以 102010^{20}1020 可以扔掉（在一个周期里存在合法解即可得无论多少格子都存在合法解）。 我们先令 f(a,b,c)f(a,b,c)f(a,b,c) 表示 p1=a,p2=b,k=cp_1=a,p_2=b,k=cp1​=a,p2​=b,k=c 对应的答案。 那么首先我们可以发现，若 p1=q1g, p2=q2gp_1=q_1g,\\ p_2=q_2gp1​=q1​g, p2​=q2​g，则 f(p1,p2,k)=f(q1,q2,k)f(p_1,p_2,k)=f(q_1,q_2,k)f(p1​,p2​,k)=f(q1​,q2​,k)。因为若 p1=q1g, p2=q2gp_1=q_1g,\\ p_2=q_2gp1​=q1​g, p2​=q2​g，则必定所有编号不为 ggg 的倍数的格子都不会被染色，可以忽略掉。 所以不妨令 q1≥q2, (q1,q2)=1q_1\\ge q_2,\\ (q_1,q_2)=1q1​≥q2​, (q1​,q2​)=1 求 f(q1,q2,k)f(q_1,q_2,k)f(q1​,q2​,k)。 因为 q1&gt;q2q_1&gt;q_2q1​&gt;q2​，所以首个格子填红色比填蓝色更优（蓝色方块密度更大）。 又因为 (q1,q2)=1(q_1,q_2)=1(q1​,q2​)=1， 所以根据裴蜀定理易得对于所有整数 nnn 都存在一个 mmm 使 q1∣m, q2∣m+nq_1|m,\\ q_2|m+nq1​∣m, q2​∣m+n。 即对于每个 nnn ，都能在格中找到编号 mmm ，使得 mmm 为红，m+nm+nm+n 为蓝。 所以我们现在只需要处理最坏情况，即 mmm 为红，m+1m+1m+1 为蓝。 观察下面几个例子： 我们可以推出，染 xxx 个蓝格子至少需要 q2(x−1)+1q_2(x-1)+1q2​(x−1)+1 个连续非红格子。 所以最坏情况下，最多有 ⌊q1−2q2⌋+1\\Large\\lfloor\\normalsize\\dfrac{q_1-2}{q_2}\\Large\\rfloor\\normalsize+1⌊q2​q1​−2​⌋+1 个连续的蓝格子。 注意：特判 k=1k=1k=1 的情况为 NO。 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=200004; const int mod=998244353,inf=1000000007; ll gcd(ll a,ll b) {return a==0?b:gcd(b%a,a);} // gcd, 最大公约数 signed main() { // freopen(&quot;color.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;color.out&quot;,&quot;w&quot;,stdout); ll T,p1,p2,k; fin&gt;&gt;T; while(T--) { fin&gt;&gt;p1&gt;&gt;p2&gt;&gt;k; if(k==1) {puts(&quot;NO&quot;); continue;} // 特判 ll g=gcd(p1,p2); p1/=g,p2/=g; if(p1&lt;p2) std::swap(p1,p2); puts(((p1-2LL)/p2+1&lt;k)?&quot;YES&quot;:&quot;NO&quot;); } return 0; } // ---------------------------- // by imzzy T2 子序列问题 题面（luogu） 前置知识 普通线段树 思路 考虑离散化 AAA 数组，以便于对每个位置的数记录一个 pre[i]pre[i]pre[i] 表示一个最大的数 jjj 满足 j&lt;ij&lt;ij&lt;i 且 Aj=AiA_j=A_iAj​=Ai​（若不存在这样的 jjj 则令其为 000）。 建立一颗线段树，支持一下操作：区间加 1，全局查询每个数的平方的和。具体实现方法见代码。 考虑递推计算以每个位置为结尾的区间的贡献； 即对于每个 iii，计算 gi=∑j=1if(j,i)2g_i=\\sum\\limits_{j=1}^i f(j,i)^2gi​=j=1∑i​f(j,i)2。 我们还可以得到，∀j≤pre[i+1]\\forall j\\le pre[i+1]∀j≤pre[i+1]，有 f(j,i)=f(j,i+1)f(j,i)=f(j,i+1)f(j,i)=f(j,i+1)，因为此区间 (j,i)(j,i)(j,i) 中必定包含 Apre[i+1]=Ai+1A_{pre[i+1]}=A_{i+1}Apre[i+1]​=Ai+1​，即第 i+1i+1i+1 个数对此区间的 fff 值无贡献。 同理得，∀j&gt;pre[i+1]\\forall j&gt;pre[i+1]∀j&gt;pre[i+1]，有 f(j,i)+1=f(j,i+1)f(j,i)+1=f(j,i+1)f(j,i)+1=f(j,i+1)。 记 hi,j=f(j,i)h_{i,j}=f(j,i)hi,j​=f(j,i) 那么我们维护 hih_ihi​ 这个序列，考虑到 hih_ihi​ 转移到 hi+1h_{i+1}hi+1​ 仅需将 (pre[i+1]+1,i+1)(pre[i+1]+1,i+1)(pre[i+1]+1,i+1) 这个区间的每个数加 111，求 gig_igi​ 则正是全局查询每个数的平方的和，所以正可以上述线段树来维护。 注意：跑 luogu 民间数据如果不开 O2，可能需要常数优化。 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=1000004; const int mod=1000000007,inf=1000000007; int a[maxn]; int val[maxn],last[maxn],pre[maxn]; class segment_tree{ #define mid ((l+r)&gt;&gt;1) private: int size,ql,qr; int sum[2097154],sqrsum[2097154],tag[2097154]; // 线段树维护 3 个值，sum 即区间和，sqrsum 即区间平方和，tag 即区间加的标记 inline void pushdown(int p,int l,int r) { if(tag[p]) { tag[p&lt;&lt;1]+=tag[p],tag[p&lt;&lt;1|1]+=tag[p]; sqrsum[p&lt;&lt;1]=(1LL*sqrsum[p&lt;&lt;1] + 1LL*(mid-l+1)*tag[p]%mod*tag[p]%mod + 2LL*tag[p]*sum[p&lt;&lt;1]%mod)%mod; sqrsum[p&lt;&lt;1|1]=(1LL*sqrsum[p&lt;&lt;1|1] + 1LL*(r-mid)*tag[p]%mod*tag[p]%mod + 2LL*tag[p]*sum[p&lt;&lt;1|1]%mod)%mod; // 考虑 (a+b)²=a²+b²+2ab，所以区间加 b 后，每个数的平方值+=b²+2ab // 即区间平方和 += 区间长度×b²+2×区间和×b sum[p&lt;&lt;1]=(1LL*sum[p&lt;&lt;1] + 1LL*tag[p]*(mid-l+1))%mod; sum[p&lt;&lt;1|1]=(1LL*sum[p&lt;&lt;1|1] + 1LL*tag[p]*(r-mid))%mod; tag[p]=0; } } void update(int p,int l,int r) { if(l&gt;=ql&amp;&amp;r&lt;=qr) { sqrsum[p]=(1LL*sqrsum[p]+sum[p]*2LL+(r-l+1))%mod; // 同理，(a+1)²=a²+2a+1 // 即区间平方和+=2×区间和+区间长度 if((sum[p]+=r-l+1)&gt;=mod) sum[p]-=mod; ++tag[p]; return; } pushdown(p,l,r); if(mid&gt;=ql) update(p&lt;&lt;1,l,mid); if(mid&lt;qr) update(p&lt;&lt;1|1,mid+1,r); if((sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1])&gt;=mod) sum[p]-=mod; if((sqrsum[p]=sqrsum[p&lt;&lt;1]+sqrsum[p&lt;&lt;1|1])&gt;=mod) sqrsum[p]-=mod; } public: inline void build(int siz) {size=siz;} inline void update(int l,int r) {ql=l,qr=r,update(1,1,size);} inline int query() {return sqrsum[1];} #undef mid }sgt; signed main() { // freopen(&quot;sequence.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;sequence.out&quot;,&quot;w&quot;,stdout); rgi n,cnt; fin&gt;&gt;n; for(rgi i=1;i&lt;=n;++i) fin&gt;&gt;a[i]; memcpy(val,a,sizeof(int)*(n+1)); std::sort(val+1,val+1+n),cnt=std::unique(val+1,val+1+n)-val; for(rgi i=1;i&lt;=n;++i) { a[i]=std::lower_bound(val+1,val+cnt,a[i])-val; pre[i]=last[a[i]],last[a[i]]=i; // last[i] 当前最大的 j 满足 A[j]=i } sgt.build(n); rgi ans=0; for(rgi i=1;i&lt;=n;++i) { sgt.update(pre[i]+1,i); if((ans+=sgt.query())&gt;=mod) ans-=mod; } fout&lt;&lt;ans; return 0; } // ---------------------------- // by imzzy T3 游戏 题面（luogu） 前置知识 二项式反演 树上背包* 思路 定义 g[i][j]g[i][j]g[i][j] 代表在以节点 iii 为根的子树中选出 jjj 对非平局的方案数，D[i]D[i]D[i] 代表 iii 为根的子树中，为节点 iii 的对手的节点的个数。 用样例举个栗子： 这里加粗的节点是小 A 的，其余为小 B 的。 ggg 的值如下表 节点编号 iii g[i][0]g[i][0]g[i][0] g[i][1]g[i][1]g[i][1] g[i][2]g[i][2]g[i][2] g[i][3]g[i][3]g[i][3] g[i][4]g[i][4]g[i][4] 1 1 7 11 4 0 2 1 1 0 0 0 3 1 2 0 0 0 4 1 0 0 0 0 5 1 0 0 0 0 6 1 0 0 0 0 7 1 0 0 0 0 8 1 0 0 0 0 考虑树上动态规划计算 ggg 的值： 对于 g[i][j]g[i][j]g[i][j] 的值，我们可以发现有 222 种来源情况：一种选中了节点 iii，一种没选中（显然啊）。 现在先定义一个 g′[i][j]g&#x27;[i][j]g′[i][j] 代表没选中节点 iii 时，以节点 iii 为根的子树中选出 jjj 对非平局的方案数。 下表为 g′g&#x27;g′ 的值表 节点编号 iii g′[i][0]g&#x27;[i][0]g′[i][0] g′[i][1]g&#x27;[i][1]g′[i][1] g′[i][2]g&#x27;[i][2]g′[i][2] g′[i][3]g&#x27;[i][3]g′[i][3] g′[i][4]g&#x27;[i][4]g′[i][4] 1 1 3 2 0 0 2 1 0 0 0 0 3 1 0 0 0 0 4 1 0 0 0 0 5 1 0 0 0 0 6 1 0 0 0 0 7 1 0 0 0 0 8 1 0 0 0 0 则很容易得到 g[i][j]=g′[i][j]+g′[i][j−1]×(D[i]−j+1)g[i][j]=g&#x27;[i][j]+g&#x27;[i][j-1]\\times (D[i]-j+1)g[i][j]=g′[i][j]+g′[i][j−1]×(D[i]−j+1)，因为不选中节点 iii 的方案数就是 g′[i][j]g&#x27;[i][j]g′[i][j]；而选中节点 iii 后必然有个对手的点与其凑成一非平局，这个对手的点共 D[i]−j+1D[i]-j+1D[i]−j+1 个可选。 现在考虑如何计算 g′[i][j]g&#x27;[i][j]g′[i][j]。易得，可从 iii 的各个子树中各选取几对非平局，使得选出来的总数为 jjj，即 g′[i][j]=∑k1+k2+⋯+ktg[soni,1][k1]×g[soni,2][k2]×⋯×g[soni,t][kt]g&#x27;[i][j]=\\sum_{k_1+k_2+\\cdots+k_t} g[son_{i,1}][k_1]\\times g[son_{i,2}][k_2]\\times\\cdots\\times g[son_{i,t}][k_t]g′[i][j]=∑k1​+k2​+⋯+kt​​g[soni,1​][k1​]×g[soni,2​][k2​]×⋯×g[soni,t​][kt​]（这里 soni,tson_{i,t}soni,t​ 表示 iii 的第 ttt 个子节点）。 发现这个复杂度很不正确，肯定过不了，所以要改进。 可以考虑这样：先把 iii 的所有子树砍掉，每次插入一颗子树，并计算其对 g′g&#x27;g′ 的新贡献。 则可以看出若定义 g′′[i][k]g&#x27;&#x27;[i][k]g′′[i][k] 表示以 iii 为根的子树中，前 kkk 个 iii 的子树对 g′g&#x27;g′ 的贡献， 那么 g′′[i][k][a+b]=∑g′′[i][k−1][a]×g′[soni,k][b]g&#x27;&#x27;[i][k][a+b]=\\sum g&#x27;&#x27;[i][k-1][a]\\times g&#x27;[son_{i,k}][b]g′′[i][k][a+b]=∑g′′[i][k−1][a]×g′[soni,k​][b]，即前 k−1k-1k−1 个子树中选 aaa 对，第 kkk 个子树中选 bbb 对。 这样算，乍一看是 O(n3)O(n^3)O(n3) 的，但其实不然。 如果 g′′[i][k−1][a]=0g&#x27;&#x27;[i][k-1][a]=0g′′[i][k−1][a]=0，则显然 g′′[i][k−1][a+1]=0g&#x27;&#x27;[i][k-1][a+1]=0g′′[i][k−1][a+1]=0；同理，若 g′[soni,k][b]=0g&#x27;[son_{i,k}][b]=0g′[soni,k​][b]=0，则显然 g′[soni,k][b+1]=0g&#x27;[son_{i,k}][b+1]=0g′[soni,k​][b+1]=0。 所以如果我们卡 a,ba,ba,b 的上界，使得参与计算的 g′′[i][k−1][a]×g′[soni,k][b]≠0g&#x27;&#x27;[i][k-1][a]\\times g&#x27;[son_{i,k}][b]\\neq 0g′′[i][k−1][a]×g′[soni,k​][b]​=0，则可证明复杂度为 O(n2)O(n^2)O(n2)。 这其实是一个树上背包，具体复杂度证明可以看 ouuan 的博客，这里不赘述。 说明：这里的 g′g&#x27;g′ 和 g′′g&#x27;&#x27;g′′ 仅为了方便描述，其实在代码中不需要专门存储。 至此，我们用 O(n2)O(n^2)O(n2) 的复杂度内得出了 ggg 的值表。 现在定义 f[i]f[i]f[i] 为正好 iii 对非平局的方案总数，h[i]h[i]h[i] 为钦定 iii 对非平局的方案总数。 这可能不太好理解，换句话说，就是 ∑任意选定 j 对非平局后剩下的节点自由配对的方案数\\sum_{任意选定\\ j\\ 对非平局后} 剩下的节点自由配对的方案数∑任意选定 j 对非平局后​剩下的节点自由配对的方案数。 样例中，h[0]=24, h[1]=42, h[2]=22, h[3]=4, h[4]=0h[0]=24,\\ h[1]=42,\\ h[2]=22,\\ h[3]=4,\\ h[4]=0h[0]=24, h[1]=42, h[2]=22, h[3]=4, h[4]=0。 很明显，根据定义，h[i]=g[1][i]×(m−i)!h[i]=g[1][i]\\times (m-i)!h[i]=g[1][i]×(m−i)!，因为 iii 对节点被选中后共可匹配 m−im-im−i 对局面。 你可能能感觉出 hhh 与 fff 间有某种关系，然而 hhh 与 fff 的关系并不只是简简单单的后缀和，考虑 h[i]h[i]h[i] 事实上将每个 jjj 对非平局的情况都算了 (ji)\\dbinom{j}{i}(ij​) 次，因为钦定其中每 iii 个节点时，都会算上一次这个状态； 即 h[i]=∑j=im(ji)f[j]h[i]=\\sum\\limits_{j=i}^m\\dbinom{j}{i}f[j]h[i]=j=i∑m​(ij​)f[j]。 我们便发现，这是一个 二项式反演 的形式， 可得 h[i]=∑j=im(ji)f[j]⇔f[i]=∑j=im(−1)j−i(ji)h[j]h[i]=\\sum\\limits_{j=i}^m\\dbinom{j}{i}f[j]\\Leftrightarrow f[i]=\\sum\\limits_{j=i}^m(-1)^{j-i}\\dbinom{j}{i}h[j]h[i]=j=i∑m​(ij​)f[j]⇔f[i]=j=i∑m​(−1)j−i(ij​)h[j]。 那么我们就可以根据这个公式，通过 hhh 值表在 O(n2)O(n^2)O(n2) 以内计算出 fff 值表了。 至此，我们在 O(n2)O(n^2)O(n2) 的复杂度内计算出了答案。 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=5004; const int mod=998244353,inf=1000000007; int n,m; struct EDGE{int v,nxt;}e[maxn&lt;&lt;1]; int first[maxn],cnte; inline void addedge(int u,int v) { e[++cnte].v=v, e[cnte].nxt=first[u], first[u]=cnte; } char s[maxn]; int cnt[maxn][2],siz[maxn]; // cnt[i][j] 表示 i 的子树中，隶属于 j 的节点的个数；siz[i] 代表 i 的子树节点数 ll tmp[maxn],g[maxn][maxn],h[maxn]; void dfs(int fa,int now) { cnt[now][s[now]=='1']=siz[now]=1,g[now][0]=1; for(rgi i=first[now],to=e[i].v;i;i=e[i].nxt,to=e[i].v) { if(to==fa) continue; dfs(now,to); for(rgi j=0;j&lt;=siz[now]+siz[to];++j) tmp[j]=0; for(rgi j=0;g[now][j];++j) for(rgi k=0;g[to][k];++k) (tmp[j+k]+=g[now][j]*g[to][k])%=mod; for(rgi j=0;j&lt;=siz[now]+siz[to];++j) g[now][j]=tmp[j]; siz[now]+=siz[to],cnt[now][0]+=cnt[to][0],cnt[now][1]+=cnt[to][1]; } // 上面这段相当于计算 g' for(rgi i=m;i&gt;0;--i) (g[now][i]+=g[now][i-1]*std::max(0,cnt[now][s[now]=='0']-i+1))%=mod; // 上面这段则相当于计算真实的 g 值 } ll ans[maxn]; ll fact[maxn],invfact[maxn]; inline ll inv(ll a) { ll b=mod-2,res=1; while(b) {if(b&amp;1) (res*=a)%=mod; (a*=a)%=mod,b&gt;&gt;=1;} return res; } inline ll C(ll a,ll b) {return fact[a]*invfact[b]%mod*invfact[a-b]%mod;} inline void solve() { fact[0]=invfact[0]=1; for(rgi i=1;i&lt;=m;++i) fact[i]=fact[i-1]*i%mod,invfact[i]=inv(fact[i]); for(rgi i=0;i&lt;=m;++i) h[i]=g[1][i]*fact[m-i]%mod/*,fout&lt;&lt;h[i]&lt;&lt;' '*/; for(rgi i=0;i&lt;=m;++i) for(rgi j=i;j&lt;=m;++j) (ans[i]+=h[j]*(((j-i)&amp;1)?(mod-1):1)%mod*C(j,i))%=mod; } signed main() { // freopen(&quot;match.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;match.out&quot;,&quot;w&quot;,stdout); int x,y; fin&gt;&gt;n; scanf(&quot;%s&quot;,s+1); for(rgi i=1;i&lt;n;++i) fin&gt;&gt;x&gt;&gt;y,addedge(x,y),addedge(y,x); m=n&gt;&gt;1,dfs(0,1),solve(); // for(rgi i=1;i&lt;=n;++i) // { // for(rgi j=0;j&lt;=m;++j) fout&lt;&lt;g[i][j]&lt;&lt;' '; // fout&lt;&lt;endl; // } for(rgi i=0;i&lt;=m;++i) fout&lt;&lt;ans[i]&lt;&lt;endl; return 0; } // ---------------------------- // by imzzy 3. 总结 Never use __gcd! ","link":"https://imzzy1201.github.io/post/-5pBeF37l/"},{"title":"备忘录","content":" The more you learn, the more you know; the more you know, the more you forget; the more you forget, the less you know. So why bother to learn? 板子 #include&lt;bits/stdc++.h&gt; namespace P_TEMPLATE{ #define endl '\\n' #define rgi register int #define ll long long class fastin{private:int _ch,_f; public:inline fastin&amp;operator&gt;&gt;(char&amp;c){c=getchar();return*this;} template&lt;typename _Tp&gt;inline fastin&amp;operator&gt;&gt;(_Tp&amp;_x){ _x=0;while(!isdigit(_ch))_f|=(_ch==45),_ch=getchar(); while(isdigit(_ch))_x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0);return*this;}fastin(){_ch=_f=0;} }fin;class fastout{private:int _num[32],_head; public:inline fastout&amp;operator&lt;&lt;(char c){putchar(c);return*this;} template&lt;typename _Tp&gt; inline fastout&amp;operator&lt;&lt;(_Tp _x){ _Tp _k;if(_x==0){putchar('0');return *this;}if(_x&lt;0)putchar('-'),_x=-_x; while(_x&gt;0)_k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0)putchar(_num[_head]),--_head;return*this;}fastout(){_head=0;} }fout;inline void P_INIT(){ #ifdef D_STDOUT_UNBUFFERED setbuf(stdout,NULL); #endif }}using namespace P_TEMPLATE; // ---------------------------- // #define int ll // using namespace std; const int maxn=1000004; const int mod=1000000007,inf=1201201201; signed main() {P_INIT(); return 0; } // ---------------------------- // by imzzy 数学相关 排列组合 Pnm=Anm=n!(n−m)!Cnm=(nm)=Pnmm!=n!m!(n−m)!\\begin{aligned} \\\\ &amp; P_n^m=A_n^m=\\dfrac{n!}{(n-m)!} \\\\ &amp; C_n^m=\\dbinom{n}{m}=\\dfrac{P_n^m}{m!}=\\dfrac{n!}{m!(n-m)!} \\\\ \\end{aligned} ​Pnm​=Anm​=(n−m)!n!​Cnm​=(mn​)=m!Pnm​​=m!(n−m)!n!​​ exgcd void exgcd(ll a,ll b,ll &amp;x,ll &amp;y,ll &amp;d) {if(!b) x=1,y=0,d=a; else exgcd(b,a%b,y,x,d),y-=x*(a/b);} Miller-Rabin 素性检测 来自 Wikipedia 的数据 if n &lt; 2,047, it is enough to test a = 2; if n &lt; 1,373,653, it is enough to test a = 2 and 3; if n &lt; 9,080,191, it is enough to test a = 31 and 73; if n &lt; 25,326,001, it is enough to test a = 2, 3, and 5; if n &lt; 3,215,031,751, it is enough to test a = 2, 3, 5, and 7; if n &lt; 4,759,123,141, it is enough to test a = 2, 7, and 61; if n &lt; 1,122,004,669,633, it is enough to test a = 2, 13, 23, and 1662803; if n &lt; 2,152,302,898,747, it is enough to test a = 2, 3, 5, 7, and 11; if n &lt; 3,474,749,660,383, it is enough to test a = 2, 3, 5, 7, 11, and 13; if n &lt; 341,550,071,728,321, it is enough to test a = 2, 3, 5, 7, 11, 13, and 17. if n &lt; 3,825,123,056,546,413,051, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, and 23. if n &lt; 18,446,744,073,709,551,616 = 264, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37. if n &lt; 318,665,857,834,031,151,167,461, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37. if n &lt; 3,317,044,064,679,887,385,961,981, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, and 41. inline ll mulmod(ll a,ll b,ll m) { ll res=0; while(b) { if(b&amp;1) if((res+=a)&gt;=m) res-=m; if((a+=a)&gt;=m) a-=m; b&gt;&gt;=1; } return res; } inline ll powmod(ll a,ll b,ll m) { ll res=1; while(b) { if(b&amp;1) res=mulmod(res,a,m); a=mulmod(a,a,m); b&gt;&gt;=1; } return res; } inline bool Miller_Rabin(ll n) // true 为质数，false 为非质数 { if(n&lt;2) return false; const ll tests[]={2,3,5,7,11,13,17,19,23,29,31,37}; ll tmp=n-1,d,a,t; while(!(tmp&amp;1)) tmp&gt;&gt;=1; for(rgi i=0;i&lt;12&amp;&amp;tests[i]&lt;n;++i) { a=tests[i],t=powmod(a,d=tmp,n); while(d!=n-1&amp;&amp;t!=1&amp;&amp;t!=n-1) t=mulmod(t,t,n),d&lt;&lt;=1; if(t!=n-1&amp;&amp;!(t==1&amp;&amp;d&amp;1)) return false; } return true; } 二项式反演 四种常用形式： 从 000 到 nnn ： fn=∑i=0n(−1)i(ni)gi⇔gn=∑i=0n(−1)i(ni)fi亦作fn=∑i=0n(ni)gi⇔gn=∑i=0n(−1)n−i(ni)fi\\begin{aligned}\\\\ f_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_i \\\\ \\textsf{亦作} f_n=\\sum\\limits_{i=0}^n\\dbinom{n}{i}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=0}^n (-1)^{n-i} \\dbinom{n}{i} f_i \\\\ \\end{aligned} fn​=i=0∑n​(−1)i(in​)gi​亦作fn​=i=0∑n​(in​)gi​​⇔gn​=i=0∑n​(−1)i(in​)fi​⇔gn​=i=0∑n​(−1)n−i(in​)fi​​ 从 nnn 到 mmm ： fn=∑i=nm(−1)i(in)gi⇔gn=∑i=nm(−1)i(in)fi亦作fn=∑i=nm(in)gi⇔gn=∑i=nm(−1)i−n(in)fi\\begin{aligned}\\\\ f_n=\\sum\\limits_{i=n}^m(-1)^i\\dbinom{i}{n}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=n}^m(-1)^i\\dbinom{i}{n}f_i \\\\ \\textsf{亦作} f_n=\\sum\\limits_{i=n}^m\\dbinom{i}{n}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=n}^m (-1)^{i-n} \\dbinom{i}{n} f_i \\\\ \\end{aligned} fn​=i=n∑m​(−1)i(ni​)gi​亦作fn​=i=n∑m​(ni​)gi​​⇔gn​=i=n∑m​(−1)i(ni​)fi​⇔gn​=i=n∑m​(−1)i−n(ni​)fi​​ 莫比乌斯函数 μ\\muμ μ(d)={1d=1(−1)kd=p1p2p3...pk, pi为 d 的质因子且两两互素0otherwise\\mu(d)= \\begin{cases} 1 &amp; d=1\\\\ (-1)^k &amp; d=p_1p_2p_3...p_k,\\ p_i \\textsf{为 } d \\textsf{ 的质因子且两两互素} \\\\ 0 &amp; \\text{otherwise} \\end{cases} μ(d)=⎩⎪⎨⎪⎧​1(−1)k0​d=1d=p1​p2​p3​...pk​, pi​为 d 的质因子且两两互素otherwise​ 性质： 1.∑d∣nμ(d)=[n=1]2.∑d∣nμ(d)d=ϕ(n)n\\begin{aligned}\\\\ 1. &amp;\\sum_{d|n}\\mu(d)=[n=1]\\\\ 2. &amp;\\sum_{d|n}\\frac{\\mu(d)}{d}=\\frac{\\phi(n)}{n} \\end{aligned}\\\\ 1.2.​d∣n∑​μ(d)=[n=1]d∣n∑​dμ(d)​=nϕ(n)​​ 莫比乌斯反演 其实一般直接套性质 1 就好了 F(n)=∑d∣nf(d)⇔f(d)=∑d∣nμ(d)F(nd)F(n)=\\sum_{d|n}f(d)\\Leftrightarrow f(d)=\\sum_{d|n}\\mu(d)F\\left(\\frac{n}{d}\\right) F(n)=d∣n∑​f(d)⇔f(d)=d∣n∑​μ(d)F(dn​) 欧拉函数 ϕ(x)=∑i=1x[gcd⁡(i,x)=1]=x∏i=1n(1−1pi)\\phi(x)=\\sum_{i=1}^x [\\gcd(i,x)=1]=x\\prod_{i=1}^n\\left(1-\\frac{1}{p_i}\\right) ϕ(x)=i=1∑x​[gcd(i,x)=1]=xi=1∏n​(1−pi​1​) 其中 {p1,p2,⋯ ,pn}\\{p_1,p_2,\\cdots,p_n\\}{p1​,p2​,⋯,pn​} 为 xxx 的所有质因数。 性质： 1.∑d∣nϕ(d)=d2.ϕ(n)=n−1⇔n∈prime3.∑d∣nμ(d)d=ϕ(n)n\\begin{aligned}\\\\ 1. &amp;\\sum_{d|n}\\phi(d)=d\\\\ 2. &amp;\\phi(n)=n-1 \\Leftrightarrow n \\in prime 3. &amp;\\sum_{d|n}\\frac{\\mu(d)}{d}=\\frac{\\phi(n)}{n} \\end{aligned}\\\\ 1.2.​d∣n∑​ϕ(d)=dϕ(n)=n−1⇔n∈prime3.​d∣n∑​dμ(d)​=nϕ(n)​​ 图论 网络瘤 Dinic 原理我想是不会忘了的。 MCMF 我们写的方法基本都是指数级别的，很容易被叉，参考 ouuan's Blog 下面是我巨大的 Dinic 当前弧优化 + 史上最慢指数级 MCMF 板子： namespace FLOWS{ struct EDGE{int to,w,nxt;} e[maxm&lt;&lt;1|1]; int n,cnte,first[maxn+1]; inline void init(int _n) {n=_n,cnte=-1,memset(first,-1,(n+1)*sizeof(int));} inline void addedge(int from,int to,int w) {e[++cnte]=(EDGE){to,w,first[from]},first[from]=cnte;} } namespace MAXFLOW{ using namespace FLOWS; int n,s,t,ans; inline void init(int _n,int _s,int _t) {s=_s,t=_t,ans=0,n=_n,FLOWS::init(n);} inline void addedge(int from,int to,int w) { if(debug&amp;1) std::cout&lt;&lt;&quot;MAXFLOW::addedge &quot;&lt;&lt;from&lt;&lt;' '&lt;&lt;to&lt;&lt;' '&lt;&lt;w&lt;&lt;endl; FLOWS::addedge(from,to,w),FLOWS::addedge(to,from,0); } int dep[maxn+1],cur[maxn+1],q[maxn+1]; inline bool bfs() { memcpy(cur,first,(n+1)*sizeof(int)); memset(dep,0,(n+1)*sizeof(int)); rgi l=1,r=1,u,i; q[1]=s,dep[s]=1; while(l&lt;=r) for(u=q[l++],i=first[u];~i;i=e[i].nxt) if(e[i].w&gt;0&amp;&amp;!dep[e[i].to]) dep[e[i].to]=dep[u]+1,q[++r]=e[i].to; return dep[t]; } int dfs(int now,int flow) { if(now==t) return flow; int res=0; for(rgi i=cur[now],to;~i;i=e[i].nxt) { cur[now]=i,to=e[i].to; if(dep[to]==dep[now]+1&amp;&amp;e[i].w&gt;0) if((res=dfs(to,std::min(flow,e[i].w)))&gt;0) {e[i].w-=res,e[i^1].w+=res; return res;} } return 0; } inline int work() { int now; while(bfs()) while((now=dfs(s,inf))&gt;0) { ans+=now; if((debug&gt;&gt;1)&amp;1) std::cout&lt;&lt;&quot;MAXFLOW::work &quot;&lt;&lt;ans&lt;&lt;'\\n'; } return ans; } } namespace MCMF{ using namespace FLOWS; int n,s,t,maxflow,mincost; int cost[maxm&lt;&lt;1|1]; inline void init(int _n,int _s,int _t) {n=_n,s=_s,t=_t,maxflow=mincost=0,FLOWS::init(n);} inline void addedge(int from,int to,int w,int c) { if(debug&amp;1) std::cout&lt;&lt;&quot;MCMF::addedge &quot;&lt;&lt;from&lt;&lt;' '&lt;&lt;to&lt;&lt;' '&lt;&lt;w&lt;&lt;' '&lt;&lt;c&lt;&lt;'\\n'; FLOWS::addedge(from,to,w),cost[cnte]=c; FLOWS::addedge(to,from,0),cost[cnte]=-c; } int dist[maxn+1],flow[maxn+1]; int pre[maxn+1]; bool vis[maxn+1]; std::queue&lt;int&gt; q; inline bool SPFA() { memset(vis,0,(n+1)*sizeof(bool)); memset(flow,0,(n+1)*sizeof(int)); memset(dist,0x3f,(n+1)*sizeof(int)); rgi u,i,to; q.push(s),dist[s]=0,flow[s]=inf; while(!q.empty()) { vis[u=q.front()]=0; q.pop(); for(i=first[u];~i;i=e[i].nxt) { to=e[i].to; if(e[i].w&gt;0&amp;&amp;dist[to]&gt;dist[u]+cost[i]) { dist[to]=dist[u]+cost[i],pre[to]=i; flow[to]=std::min(flow[u],e[i].w); if(!vis[to]) q.push(to),vis[to]=1; } } } return dist[t]&lt;inf; } inline std::pair&lt;int,int&gt; work() { rgi i; while(SPFA()) { maxflow+=flow[t],mincost+=flow[t]*dist[t]; for(i=t;i!=s;i=e[pre[i]^1].to) e[pre[i]].w-=flow[t],e[pre[i]^1].w+=flow[t]; if((debug&gt;&gt;1)&amp;1) std::cout&lt;&lt;&quot;MCMF::work &quot;&lt;&lt;maxflow&lt;&lt;' '&lt;&lt;mincost&lt;&lt;'\\n'; } return std::make_pair(maxflow,mincost); } } DS 普通平衡树 Splay class SPLAY{ private: int root,sum,inf_; struct NODE{int val,cnt,siz,fa,ch[2];}t[maxn]; inline int newnode(int f,int v) { t[++sum].fa=f,t[sum].ch[0]=t[sum].ch[1]=0; t[sum].cnt=t[sum].siz=1,t[sum].val=v; return sum; } inline int son(int p) {return t[t[p].fa].ch[1]==p;} inline void connect(int p,int f,int d) {t[p].fa=f,t[f].ch[d]=p;} inline void pushup(int p) {t[p].siz=t[t[p].ch[0]].siz+t[t[p].ch[1]].siz+t[p].cnt;} inline void rotate(int p) { int f=t[p].fa,g=t[f].fa,s1=son(p),s2=son(f); connect(t[p].ch[s1^1],f,s1),connect(f,p,s1^1),connect(p,g,s2); pushup(f),pushup(p); if(root==f) root=p; } inline void splay(int p,int q) { int u=t[q].fa,f,g; while(t[p].fa!=u) { f=t[p].fa,g=t[f].fa; if(g!=u) son(p)^son(f)?rotate(p):rotate(f); rotate(p); } } inline int find(int x) { int p=root; if(!p) return 0; while(t[p].ch[x&gt;t[p].val]&amp;&amp;x!=t[p].val) p=t[p].ch[x&gt;t[p].val]; return splay(p,root),p; } inline int near(int x,int d) { // 0 pre, 1 suc int p=root,res=0; while(p) {//fout&lt;&lt;p&lt;&lt;endl; if((d?x:t[p].val)&lt;(d?t[p].val:x)) res=p,p=t[p].ch[d^1]; else p=t[p].ch[d]; } if(res) splay(res,root); return t[res].val; } public: inline void insert(int x) { int p=root,nxt; if(!p) return root=newnode(0,x),void(); while(1) { ++t[p].siz; if(t[p].val==x) return ++t[p].cnt,splay(p,root); nxt=(x&gt;t[p].val); if(!t[p].ch[nxt]) return splay(t[p].ch[nxt]=newnode(p,x),root); p=t[p].ch[nxt]; } } inline bool erase(int x) { int p=find(x); if(!p) return 1; if(t[p].cnt&gt;1) return --t[p].cnt,--t[p].siz,0; if(!t[p].ch[0]||!t[p].ch[1]) return t[root=t[p].ch[0]+t[p].ch[1]].fa=0; int q=t[p].ch[1]; while(t[q].ch[0]) q=t[q].ch[0]; splay(q,root),connect(t[p].ch[0],q,0),t[q].fa=0; return pushup(q),0; } inline int rank(int x) {return find(x)?(t[t[root].ch[0]].siz+1+t[root].cnt*(t[root].val&lt;x)):1;} inline int kth(int k) { int p=root; while(p) { if(t[t[p].ch[0]].siz&lt;k&amp;&amp;t[t[p].ch[0]].siz+t[p].cnt&gt;=k) return splay(p,root),t[p].val; if(t[t[p].ch[0]].siz&lt;k) k-=t[t[p].ch[0]].siz+t[p].cnt,p=t[p].ch[1]; else p=t[p].ch[0]; } return inf_; } inline int pre(int x) {return near(x,0);} inline int suc(int x) {return near(x,1);} inline void build() {t[0].siz=root=sum=0,inf_=2147483647;} }; Treap class TREAP{ private: int root,sum,inf_; struct NODE{int val,cnt,siz,fa,ch[2],pri;}t[maxn]; inline int newnode(int f,int v) { t[++sum].fa=f,t[sum].ch[0]=t[sum].ch[1]=0; t[sum].val=v,t[sum].pri=rand()%inf+1; t[sum].cnt=t[sum].siz=1; return sum; } inline int son(int p) {return t[t[p].fa].ch[1]==p;} inline void connect(int p,int f,int d) {t[p].fa=f,t[f].ch[d]=p;} inline void pushup(int p) {t[p].siz=t[t[p].ch[0]].siz+t[t[p].ch[1]].siz+t[p].cnt;} inline void rotate(int p) { int f=t[p].fa,g=t[f].fa,s1=son(p),s2=son(f); connect(p,g,s2),connect(t[p].ch[s1^1],f,s1),connect(f,p,s1^1); pushup(f),pushup(p); if(root==f) root=p; } inline void treap(int p) {while(p!=root&amp;&amp;t[p].pri&lt;t[t[p].fa].pri) rotate(p);} inline int near(int x,int d) { // 0 pre, 1 suc int p=root,res=inf_; while(p) { if((d?x:t[p].val)&lt;(d?t[p].val:x)) res=t[p].val,p=t[p].ch[d^1]; else p=t[p].ch[d]; } return res; } public: inline void build() {t[0].siz=root=sum=0,t[0].pri=inf_=1201201201,srand(time(0));} inline void insert(int x) { int p=root,nxt; if(!p) return root=newnode(0,x),void(); while(1) { ++t[p].siz; if(t[p].val==x) return ++t[p].cnt,void(); nxt=(x&gt;t[p].val); if(!t[p].ch[nxt]) return treap(t[p].ch[nxt]=newnode(p,x)); p=t[p].ch[nxt]; } } inline bool erase(int x) { int p=root; while(p) { if(t[p].val==x) { if(t[p].cnt==1) { while(t[p].ch[0]||t[p].ch[1]) rotate(t[p].ch[t[t[p].ch[1]].pri&lt;t[t[p].ch[0]].pri]); connect(0,t[p].fa,son(p)); if(root==p) root=0; } else --t[p].cnt; break; } p=t[p].ch[x&gt;t[p].val]; } if(!p) return 1; while(p) pushup(p),p=t[p].fa; return 0; } inline int rank(int x) { int p=root,res=1; while(p) { if(t[p].val==x) return res+t[t[p].ch[0]].siz; if(x&gt;t[p].val) res+=t[t[p].ch[0]].siz+t[p].cnt,p=t[p].ch[1]; else p=t[p].ch[0]; } return res; } inline int kth(int k) { int p=root; while(p) { if(t[t[p].ch[0]].siz&lt;k&amp;&amp;t[t[p].ch[0]].siz+t[p].cnt&gt;=k) return t[p].val; if(t[t[p].ch[0]].siz&lt;k) k-=t[t[p].ch[0]].siz+t[p].cnt,p=t[p].ch[1]; else p=t[p].ch[0]; } return inf_; } inline int pre(int x) {return near(x,0);} inline int suc(int x) {return near(x,1);} }; FHQ-Treap class FHQ_TREAP{ private: int root,sum,inf_,a,b,c; struct NODE{int val,siz,fa,ch[2],pri;}t[maxn]; inline int newnode(int v) { ++sum,t[sum].fa=t[sum].ch[0]=t[sum].ch[1]=0; t[sum].siz=1,t[sum].val=v,t[sum].pri=rand(); return sum; } inline void pushup(int p) {t[p].siz=t[t[p].ch[0]].siz+t[t[p].ch[1]].siz+1;} void split(int p,int k,int &amp;x,int &amp;y,bool type=0) { if(!p) return x=y=0,void(); if(k&lt;(type?(t[t[p].ch[0]].siz+1):t[p].val)) y=p,split(t[p].ch[0],k,x,t[p].ch[0],type); else x=p,split(t[p].ch[1],k-(t[t[p].ch[0]].siz+1)*type,t[p].ch[1],y,type); return pushup(p); } int merge(int p,int q) { if(!p||!q) return p+q; if(t[p].pri&lt;t[q].pri) return t[p].ch[1]=merge(t[p].ch[1],q),pushup(p),p; return t[q].ch[0]=merge(p,t[q].ch[0]),pushup(q),q; } inline int near(int x,int d) { int p=root,res=inf_; while(p) { if((d?x:t[p].val)&lt;(d?t[p].val:x)) res=t[p].val,p=t[p].ch[d^1]; else p=t[p].ch[d]; } return res; } public: inline void insert(int x) {split(root,x,a=0,b=0),root=merge(merge(a,newnode(x)),b);} inline void erase(int x) { split(root,x-1,a=0,b=0),split(b,x,b,c=0); root=merge(merge(a,merge(t[b].ch[0],t[b].ch[1])),c); } inline int rank(int x) {split(root,x-1,a=0,b=0),c=t[a].siz; return merge(a,b),c+1;} inline int kth(int x) { split(root,x,a=0,b=0,1); for(c=a;t[c].ch[1];c=t[c].ch[1]); return merge(a,b),t[c].val; } inline int pre(int x) {return near(x,0);} inline int suc(int x) {return near(x,1);} inline void build() {t[0].siz=root=sum=0,t[0].pri=inf_=2147483647,srand(time(0));} }; 后缀数据结构 后缀树 class suffix_tree{ public: int s[maxn],n,now,rem,cnt; struct NODE{int link,pos,len,ch[maxm];}t[maxn&lt;&lt;1]; inline int newnode(int p,int l) { t[++cnt].pos=p,t[cnt].len=l,t[cnt].link=1; memset(t[cnt].ch,0,sizeof(t[cnt].ch)); return cnt; } inline void extend(int x) { s[++n]=x,++rem; for(rgi last=1;rem;) { while(rem&gt;t[t[now].ch[s[n-rem+1]]].len) rem-=t[now=t[now].ch[s[n-rem+1]]].len; int &amp;v=t[now].ch[s[n-rem+1]],c=s[t[v].pos+rem-1]; if(!v||c==x) { t[last].link=now,last=now; if(!v) v=newnode(n-rem+1,inf); else break; } else{ int u=newnode(t[v].pos,rem-1); t[u].ch[c]=v,t[u].ch[x]=newnode(n,inf); t[v].pos+=rem-1,t[v].len-=rem-1; t[last].link=v=u,last=u; } if(now==1) --rem; else now=t[now].link; } } inline void build(const char *str) { cnt=n=rem=0,t[0].len=inf,now=newnode(0,0); for(rgi i=0,l=strlen(str);i&lt;l;++i) extend(str[i]-'a'+1); extend(0); for(rgi i=1;i&lt;=cnt;++i) if(t[i].len&gt;n&lt;&lt;1) t[i].len=n-t[i].pos; } }; 后缀数组 class suffix_array{ public: int SA[maxn],c[maxn],t1[maxn],t2[maxn]; int *rank,height[maxn]; inline void getSA() { int *x=t1,*y=t2; for(rgi i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(rgi i=1;i&lt;=n;++i) SA[c[x[i]]--]=i; for(rgi k=1,p;k&lt;=n;k&lt;&lt;=1) {p=0; for(rgi i=n-k+1;i&lt;=n;++i) y[++p]=i; for(rgi i=1;i&lt;=n;++i) if(SA[i]&gt;k) y[++p]=SA[i]-k; for(rgi i=1;i&lt;=m;++i) c[i]=0; for(rgi i=1;i&lt;=n;++i) ++c[x[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(rgi i=n;i&gt;=1;--i) SA[c[x[y[i]]]--]=y[i],y[i]=0; std::swap(x,y),x[SA[1]]=p=1; for(rgi i=2;i&lt;=n;++i) x[SA[i]]=(y[SA[i]]==y[SA[i-1]]&amp;&amp;y[SA[i]+k]==y[SA[i-1]+k])?p:++p; if(n==(m=p)) break; } rank=x; } inline void getheight() { for(rgi i=1,j,k=0;i&lt;=n;++i) { if(k) --k; j=SA[rank[i]-1]; while(s[i+k]==s[j+k]) ++k; height[rank[i]]=k; } } inline void init() {getSA(),getheight();} }; ","link":"https://imzzy1201.github.io/post/1y_vHr2_t/"},{"title":"友情链接","content":" Some people come to you in your life, to make you know that you are such an easy target. dalao 们 Clever_Jimmy\\textsf\\color{black}C\\color{red}lever\\_JimmyClever_Jimmy FZzzz\\textsf\\color{black}F\\color{red}ZzzzFZzzz xiong_6\\textsf\\color{black}x\\color{red}iong\\_6xiong_6 lzc\\textsf\\color{black}l\\color{red}zclzc xzx\\textsf\\color{black}x\\color{red}zxxzx Polaris_Dane\\textsf\\color{black}P\\color{red}olaris\\_DanePolaris_Dane 好用的网址们 OEIS（数列找规律） NumberEmpire（数字性质） WolframAlpha（数学工具） LaTeX\\LaTeXLATE​X 索引 tool.lu（在线工具） Chrome Extension CRX Downloader（Chrome Web Store 插件下载器） ","link":"https://imzzy1201.github.io/post/friends/"},{"title":"博客搭建说明","content":" All roads lead to Rome. Yet, some people have been living there ever since they were born. Gridea 👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ 强烈安利 Gridea！确实十分好用，原因如下： 首先，Gridea 开源、安全、免费、无捆绑广告，有清新的图形界面和简易的安装方式，部署到 GitHub Pages 上只须要进行简单的几步配置，比起 Hexo 等的命令行操作及繁杂的安装过程和部署过程，显得容易上手许多。在部署上，Gridea 仅须用户 GitHub 账户及密码，即可部署至 GitHub Pages，比配置 SSH 更为方便；仅须简单的几步就可以完成 Gitalk 的配置；可实现随身携带、编辑和同步 Gridea 还自带 markdown + tex 公式编辑器，无须使用其它编辑器即可完成大部分编辑工作 Gridea 亦可跨平台操作，对于我这种双系统党较为便捷 Gridea 的缺点： 目前现有的主题还是较少，与 Hexo 和 Jekyll 等还是不可同日而语 同步的速度有待提高 主题 本站采用了 ITJoker233 大牛从 Hexo 中移植到 Gridea 的 Chic 主题，做了一些小修改 博客搭建教程 注册一个 GitHub 账号（不详讲） 来到 New Repository 界面 在 &quot;Repository name&quot; 下填写 [你的用户名].github.io 比如我的用户名为 imzzy1201，则我应填写 imzzy1201.github.io 注意这讲成为将来你的 GitHub Pages 的地址 然后 &quot;Create repository&quot; 现在转到 https://github.com/[你的用户名]/[你的用户名].github.io/settings 下拉到 &quot;GitHub Pages&quot; 一栏，你会看到： ✔️ Your site is published at https://[你的用户名].github.io/\\small\\textsf{\\color{green}Your site is published at \\color{blue}https://[你的用户名].github.io/}Your site is published at https://[你的用户名].github.io/ 这就说明你的 &quot;GitHub Pages&quot; 设置成功了。 现在下载某 Gridea 并安装（安装默认选项安装即可） 打开它，再页面左下角有个选项栏，里面可以自己设置语言和站点源文件位置，建议记下来你的站点源文件位置，以便折腾主题之类的东西 现在开始配置同步服务 在域名中选择 &quot;https://&quot;，然后填入 [你的用户名].github.io/ 仓库名称填 [你的用户名].github.io 分支填 master 仓库用户名填 [你的用户名] 邮箱填你用来注册 GitHub 的那个邮箱 令牌填你 GitHub 的密码 保存后，点检测远程连接，如果上方出现： ✔️ 远程连接成功 则说明你的博客已经配置好了 现在点左下角的 &quot;同步&quot;，等待它提示 &quot;同步成功&quot; 后，再在浏览器打开 [你的用户名].github.io，就会发现 Gridea 预置的主题和文章已经上传到了你的 GitHub Pages 上了 如果需要改主题可以将你的主题放在 [你的站点源文件路径]/themes/，然后重启 Gridea 即可在“主题”一栏找到你的新主题了。 ","link":"https://imzzy1201.github.io/post/myblog/"}]}
