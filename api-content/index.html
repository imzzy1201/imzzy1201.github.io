{"posts":[{"title":"20200715 校内测试订正","content":" Some people seem to have everything. In fact, they do have everything. 1. 概况 T1 53pt 我 sb 了。 T2 44pt 我 sb 了。 T3 0pt 完全不会。🙃 总分连三位数都没有，sb 实锤。 2. 题解 测试资源链接（校内题库，不公开密码） T1 简单棋盘问题 题面（暂无） 思路 考虑到其相当于求所有国王到目标位置的切比雪夫距离，而我们知道切比雪夫距离是可以转化为曼哈顿距离的。 举个例子下面坐标系中有 A,BA,BA,B 两点： 那么他们的切比雪夫距离就是 max⁡(∣xA−xB∣,∣yA−yB∣)=max⁡(∣1−5∣,∣4−2∣)=4\\max(|x_A-x_B|,|y_A-y_B|)=\\max(|1-5|,|4-2|)=4max(∣xA​−xB​∣,∣yA​−yB​∣)=max(∣1−5∣,∣4−2∣)=4（即红橙两段中较长的橙线段的长度） 它们的曼哈顿距离则为 ∣xA−xB∣+∣yA−yB∣=∣1−5∣+∣4−2∣=6|x_A-x_B|+|y_A-y_B|=|1-5|+|4-2|=6∣xA​−xB​∣+∣yA​−yB​∣=∣1−5∣+∣4−2∣=6（即红橙两线段长度和 这两种距离看起来没啥关系，其实却有很大的联系。 考虑旋转坐标轴，逆时针饶原点旋转 45°，也就是转到了这里： 在新的坐标轴上我们对两点求曼哈顿距离（即紫色折线的总的长度） 我们发现此时的曼哈顿距离 424\\sqrt{2}42​ 正好是原来的切比雪夫距离 444 的 2\\sqrt{2}2​ 倍。 多试几个点可以发现，这个结论是恒成立的。这个结论也不难证明，带入坐标推式子即可说明正确性。下面主要说的是实现方法。 实现的时候，可以直接将所有点（包括询问的点）的坐标 (x,y)(x,y)(x,y) 改成 (x+y,x−y)(x+y,x-y)(x+y,x−y)，然后求曼哈顿距离和即可。注意最终答案是这个距离和的一半。 关于求法的话，可以离散化后用树状数组对横纵坐标各维护两个值：区间内的点数和区间坐标和。统计答案时分别求大于和小于当前询问坐标的答案即可。代码应该很好懂： Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=1000004; const int mod=998244353,inf=1000000007; struct POINT{int x,y;}p[maxn]; int val0[maxn],cnt0,val1[maxn],cnt1; // 离散化用的数组 class BIT{ // 树状数组 private: ll size,val[maxn]; public: inline int lowbit(int x) {return x&amp;-x;} inline void update(int p,ll x) {while(p&lt;=size) val[p]+=x,p+=lowbit(p);} inline ll query(int p) {ll res=0; while(p&gt;0) res+=val[p],p-=lowbit(p); return res;} inline ll query(int l,int r) {return query(r)-query(l-1);} inline void build(int s) {size=s; memset(val,0,sizeof(ll)*(size+2));} }B[2],C[2]; // B 记录坐标和，C 点的个数 // 上面那些变量 0 指横坐标，1 指纵坐标 signed main() { // freopen(&quot;chess.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;chess.out&quot;,&quot;w&quot;,stdout); int n,x,y,qx,qy; ll ans=0; rgi T,q; fin&gt;&gt;T; while(T--) { cnt0=cnt1=0,fin&gt;&gt;n&gt;&gt;q; for(rgi i=1;i&lt;=n;++i) fin&gt;&gt;p[i].x&gt;&gt;p[i].y,val0[++cnt0]=p[i].x+p[i].y,val1[++cnt1]=p[i].x-p[i].y; std::sort(val0+1,val0+1+cnt0),cnt0=std::unique(val0+1,val0+1+cnt0)-val0-1; std::sort(val1+1,val1+1+cnt1),cnt1=std::unique(val1+1,val1+1+cnt1)-val1-1; B[0].build(cnt0),C[0].build(cnt0); B[1].build(cnt1),C[1].build(cnt1); // 上为离散化 for(rgi i=1,t3,t4;i&lt;=n;++i) { t3=std::lower_bound(val0+1,val0+1+cnt0,p[i].x+p[i].y)-val0; t4=std::lower_bound(val1+1,val1+1+cnt1,p[i].x-p[i].y)-val1; B[0].update(t3,p[i].x+p[i].y),C[0].update(t3,1); B[1].update(t4,p[i].x-p[i].y),C[1].update(t4,1); } // 插入树状数组 while(q--) { fin&gt;&gt;x&gt;&gt;y,ans=0; qx=std::lower_bound(val0+1,val0+1+cnt0,x+y)-val0; qy=std::lower_bound(val1+1,val1+1+cnt1,x-y)-val1; ans+=C[0].query(qx-1)*(x+y)-B[0].query(qx-1); ans+=B[0].query(qx,cnt0)-C[0].query(qx,cnt0)*(x+y); // 统计横坐标 ans+=C[1].query(qy-1)*(x-y)-B[1].query(qy-1); ans+=B[1].query(qy,cnt1)-C[1].query(qy,cnt1)*(x-y); // 统计纵坐标 fout&lt;&lt;ans/2&lt;&lt;endl; } } return 0; } // ---------------------------- // by imzzy T2 简单数据结构 题面（暂无） 思路 菜到连线段树都写挂（雾 考虑用线段树暴力维护区间最小值，然后查询的时候每次取出区间里的最小值，放入答案队列，然后删掉这个位置的值（即赋值为 inf⁡\\infinf）如果取到某个时候发现取出来的数比 xxx 还大了就说明此次询问无解。 复杂度应该是 [m+∑K]log⁡n[m+\\sum K]\\log n[m+∑K]logn，大概是 10810^8108 级别的，卡卡常就能过。 也是可以的，我一共过了两个测试点，其中一个就是大样例（雾 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll using namespace std; const int maxn=500004; const int mod=998244353,inf=2000000007; class segment_tree{ #define mid ((l+r)&gt;&gt;1) private: int size,ql,qr,qv,*A,fill[maxn&lt;&lt;2],cnt; // fill 打的是取 max 标记 pair&lt;int,int&gt; minv[maxn&lt;&lt;2],changed[maxn]; // first 维护最小值，second 维护最小值对应的下标 inline void pushup(int p) {minv[p]=min(minv[p&lt;&lt;1],minv[p&lt;&lt;1|1]);} inline void pushdown(int p,int l,int r) { if(!fill[p]) return; fill[p&lt;&lt;1]=max(fill[p],fill[p&lt;&lt;1]),fill[p&lt;&lt;1|1]=max(fill[p],fill[p&lt;&lt;1|1]); minv[p&lt;&lt;1]=max(minv[p&lt;&lt;1],make_pair(fill[p],minv[p&lt;&lt;1].second)); minv[p&lt;&lt;1|1]=max(minv[p&lt;&lt;1|1],make_pair(fill[p],minv[p&lt;&lt;1|1].second)); fill[p]=0; } void build(int p,int l,int r) { fill[p]=0; if(l==r) return minv[p]=make_pair(A[l],l),void(); build(p&lt;&lt;1,l,mid),build(p&lt;&lt;1|1,mid+1,r),pushup(p); } void modify(int p,int l,int r) { // 修改单点的值 if(l==r) return fill[p]=qv,minv[p]=make_pair(qv,l),void(); pushdown(p,l,r); if(ql&lt;=mid) modify(p&lt;&lt;1,l,mid); else modify(p&lt;&lt;1|1,mid+1,r); pushup(p); } void update_(int p,int l,int r) { // 区间取 max if(l&gt;=ql&amp;&amp;r&lt;=qr) return minv[p]=max(minv[p],make_pair(qv,minv[p].second)),fill[p]=max(fill[p],qv),void(); pushdown(p,l,r); if(ql&lt;=mid) update_(p&lt;&lt;1,l,mid); if(qr&gt;mid) update_(p&lt;&lt;1|1,mid+1,r); pushup(p); } pair&lt;int,int&gt; query(int p,int l,int r) { // 查询区间最小值 if(l&gt;=ql&amp;&amp;r&lt;=qr) return minv[p]; pushdown(p,l,r); if(qr&lt;=mid) return query(p&lt;&lt;1,l,mid); if(ql&gt;mid) return query(p&lt;&lt;1|1,mid+1,r); return min(query(p&lt;&lt;1,l,mid),query(p&lt;&lt;1|1,mid+1,r)); } public: inline void build(int siz,int *k) {A=k,size=siz,cnt=0,build(1,1,size);} inline void update(int l,int r,int v) {ql=l,qr=r,qv=v,update_(1,1,size);} inline bool query(int l,int r,int x,int k,int *ans) { bool flag=1; for(rgi i=1;i&lt;=k&amp;&amp;flag;++i) { ql=l,qr=r,changed[++cnt]=query(1,1,size); // 改成 inf 时要加入队列因为最后要还原的 ql=changed[cnt].second,qv=inf,modify(1,1,size); if(changed[cnt].first&lt;x) ans[i]=changed[cnt].first; else flag=0; } while(cnt) ql=changed[cnt].second,qv=changed[cnt--].first,modify(1,1,size); return flag; } #undef mid }sgt; int a[maxn]; signed main() { // freopen(&quot;segtree.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;segtree.out&quot;,&quot;w&quot;,stdout); int n,m,op,l,r,x,k; fin&gt;&gt;n; for(rgi i=1;i&lt;=n;++i) fin&gt;&gt;a[i]; sgt.build(n,a); for(fin&gt;&gt;m;m;--m) { fin&gt;&gt;op; if(op==1) fin&gt;&gt;l&gt;&gt;r&gt;&gt;x,sgt.update(l,r,x); else{ fin&gt;&gt;l&gt;&gt;r&gt;&gt;x&gt;&gt;k,op=sgt.query(l,r,x,k,a); if(op) {for(rgi i=1;i&lt;=k;++i) fout&lt;&lt;a[i]&lt;&lt;' '; fout&lt;&lt;endl;} else fout&lt;&lt;-1&lt;&lt;endl; } } return 0; } // ---------------------------- // by imzzy T3 简单树上路径 题面（暂无） 思路 神仙题 咕了明天补完思路 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=300004,maxq=50004,maxm=1004; const int mod=998244353,inf=1000000007; int anc[20][maxn],dep[maxn],c[maxq],v[6][maxq]; std::bitset&lt;maxm&gt; f[maxn],g[maxn],p[6][maxq],tmp; inline int LCA(int p,int q) { if(dep[p]&lt;dep[q]) std::swap(p,q); for(rgi i=19;i&gt;=0;--i) if(dep[q]&lt;=dep[p]-(1&lt;&lt;i)) p=anc[i][p]; if(p==q) return p; for(rgi i=19;i&gt;=0;--i) if(anc[i][p]!=anc[i][q]) p=anc[i][p],q=anc[i][q]; return anc[0][p]; } signed main() { // freopen(&quot;travel.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;travel.out&quot;,&quot;w&quot;,stdout); int n,m,q,t,ans; fin&gt;&gt;n&gt;&gt;m&gt;&gt;q; anc[0][1]=dep[1]=1; for(rgi i=2;i&lt;=n;++i) fin&gt;&gt;anc[0][i],dep[i]=dep[anc[0][i]]+1; for(rgi i=1;i&lt;=n;++i) fin&gt;&gt;t,g[i][t]=1; for(rgi i=1;i&lt;=n;++i) f[i]=g[anc[0][i]]; for(rgi j=1;j&lt;20;++j) for(rgi i=1;i&lt;=n;++i) anc[j][i]=anc[j-1][anc[j-1][i]]; for(rgi i=1;i&lt;=q;++i) {fin&gt;&gt;c[i]; for(rgi j=1;j&lt;=c[i];++j) fin&gt;&gt;v[j][i],p[j][i]=g[v[j][i]]; v[0][i]=v[1][i]; for(rgi j=2;j&lt;=c[i];++j) v[0][i]=LCA(v[j][i],v[0][i]); } for(rgi k=0;k&lt;20;++k) { for(rgi i=1;i&lt;=q;++i) for(rgi j=1;j&lt;=c[i];++j) if((dep[v[j][i]]-dep[v[0][i]])&amp;(1&lt;&lt;k)) p[j][i]|=f[v[j][i]],v[j][i]=anc[k][v[j][i]]; memcpy(g,f,sizeof(f)); for(rgi i=1;i&lt;=n;++i) f[i]=g[i]|g[anc[k][i]]; } for(rgi k=1;k&lt;=q;++k) { ans=inf; for(rgi i=1;i&lt;1&lt;&lt;c[k];++i) {tmp=0; for(rgi j=1;j&lt;=c[k];++j) if(i&amp;(1&lt;&lt;(j-1))) tmp|=p[j][k]; ans=std::min(ans,(int)tmp.count()/__builtin_popcount(i)); } fout&lt;&lt;(ans*c[k])&lt;&lt;endl; } return 0; } // ---------------------------- // by imzzy 总结 实力是硬伤。😟 依然是前两题都想到了，都码挂了，最后一题压根不会。 继续努力吧。 ","link":"https://imzzy1201.github.io/post/1iyhTQXar/"},{"title":"20200713 校内测试订正","content":" I may not be able to change the past, but I can learn from it. 1. 概况 T1 100pts 挺简单没啥问题。 T2 90pts 码错了好几个地方竟然还能这么高？？？ T3 0pts 差一行就切了。🙃 T4 0pts 不会。 总分 190pts，差。 2. 题解 测试资源链接（校内题库，不公开密码） T1 变换序列 题面（luogu） 前置知识 二分图匹配（匈牙利和网络瘤都可以） 思路 先考虑数 iii 能放的位置，其下标（从 000 开始）只可能为 (i+Di) mod N(i+D_i)\\bmod N(i+Di​)modN 和 (i−Di) mod N(i-D_i)\\bmod N(i−Di​)modN，每个数只能放一个位置，而每个位置也只能放一个数。所以可以规约成完美匹配问题，即用下标与数字匹配，数字 iii 向下标 (i±Di) mod N(i\\pm D_i)\\bmod N(i±Di​)modN 连边，跑二分图匹配，如果没有完美匹配就相当于无解。 另一个问题是要求输出字典序最小的一组解，考虑到匹配过程是每次尝试增广。因为我们希望越小的数字越往前放，所以我们希望它靠后开始增广。这一点不难理解。同时，在一次增广中，也应该先尝试从下标较小的位置开始。可以用反证法证明这个策略的正确性 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long // ---------------------------- // #define int ll using namespace std; const int maxn=10004; const int mod=998244353,inf=1000000007; inline int read() { int x=0,f=0,ch=0; while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); return f?-x:x; } vector&lt;int&gt; mp[maxn]; int match[maxn]; bool vis[maxn]; bool dfs(int p) // 匈牙利算法 { for(unsigned rgi i=0,v;i&lt;mp[p].size();++i) { v=mp[p][i]; if(vis[v]) continue; vis[v]=1; if(match[v]==-1||dfs(match[v])) return match[v]=p,1; } return 0; } int a[maxn],ans[maxn]; signed main() { // freopen(&quot;transform.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;transform.out&quot;,&quot;w&quot;,stdout); int n=read(); for(rgi i=0;i&lt;n;++i) { a[i]=read(); mp[i].push_back((i+a[i])%n); mp[i].push_back((i-a[i]+n)%n); sort(mp[i].begin(),mp[i].end()); } memset(match,-1,sizeof(match)); for(rgi i=n-1;i&gt;=0;--i) { memset(vis,0,sizeof(vis)); if(!dfs(i)) {puts(&quot;No Answer&quot;); return 0;} // 无法增广即说明无解 } for(rgi i=0;i&lt;n;++i) ans[match[i]]=i; // 注意答案不直接为这个匹配，这个匹配是数与下标的对应而非下标与数的对应，所以要反过来一下 for(rgi i=0;i&lt;n;++i) printf(&quot;%d &quot;,ans[i]); return 0; } // ---------------------------- // by imzzy T2 最大子图 题面（luogu） 前置知识 缩点（tarjan 算法） 拓扑排序 DAG 上 DP 思路 题目要求“最大半连通导出子图的节点数”及“并列最大半连通导出子图的个数”。先观察半连通图的性质，我们发现一个图是半连通图当且仅当图中存在一条路径能经过所有节点。这个结论也比较显而易见。 然后，继续结合强连通分量的很好的性质：强连通分量内任意两点 u,vu,vu,v 间存在至少一条有向路径。也就是说一条路径只要进了强连通分量就可以走完这个分量里的所有点，再从任何一点出去。所以可以缩点，并记录编号为 iii 的强连通分量里的节点数 siz[i]siz[i]siz[i]，路径进了分量 iii 就相当于能走 siz[i]siz[i]siz[i] 个节点。 缩点之后图成了 DAG，根据套路我们将其拓扑排序并 DP。拓扑排序后，考虑按逆拓扑序动态规划以分量 iii 为起点的“最大半连通导出子图节点数”和“这样的导出子图的个数”，即可。 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long // ---------------------------- // #define int ll using namespace std; const int maxn=200004; const int mod=998244353,inf=1000000007; inline int read() { int x=0,f=0,ch=0; while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); return f?-x:x; } int n,m,p,u,v; vector&lt;int&gt; to[maxn],to2[maxn]; // to 存原图，to2 存缩点后的辅助图（用于拓扑排序和 DP） int col[maxn],siz[maxn]; // col[i] 表示 i 所在的强连通分量编号，siz[i] 表示编号为 i 的强连通分量节点数 bool vis[maxn]; int dfn[maxn],low[maxn],stk[maxn]; int dfsclock,indxs,cnt; void tarjan(int p) // 缩点 { vis[stk[++indxs]=p]=1; low[p]=dfn[p]=++dfsclock; for(rgi i=0;i&lt;to[p].size();++i) if(!dfn[to[p][i]]) tarjan(to[p][i]),low[p]=min(low[p],low[to[p][i]]); else if(vis[to[p][i]]) low[p]=min(low[p],dfn[to[p][i]]); if(low[p]==dfn[p]) { vis[p]=0,siz[col[p]=++cnt]=1; while(p!=stk[indxs]) vis[stk[indxs]]=0,++siz[cnt],col[stk[indxs--]]=cnt; --indxs; } } int ccf[maxn],topo[maxn],ip; queue&lt;int&gt; q; inline void topsort() // 拓扑排序 { for(rgi i=1;i&lt;=n;++i) for(rgi j=0;j&lt;to[i].size();++j) if(col[i]!=col[to[i][j]]) to2[col[i]].push_back(col[to[i][j]]),++ccf[col[to[i][j]]]; for(rgi i=1;i&lt;=cnt;++i) if(ccf[i]==0) q.push(i),topo[++ip]=i; int u,v; while(!q.empty()) { u=q.front(),q.pop(); for(rgi i=0;i&lt;to2[u].size();++i) if((--ccf[to2[u][i]])==0) q.push(to2[u][i]),topo[++ip]=to2[u][i]; } } pair&lt;ll,ll&gt; f[maxn]; // f[i].first 为“…的节点数”，f[i].second 为“…的个数”，其中 i 为分量编号 inline void insert(pair&lt;ll,ll&gt; &amp;a,pair&lt;ll,ll&gt; b) {if(b.first==a.first) (a.second+=b.second)%=p; if(b.first&gt;a.first) a=b;} // insert 是用 b 来更新 a set&lt;pair&lt;int,int&gt; &gt; s; inline pair&lt;ll,ll&gt; calc() { for(rgi i=1;i&lt;=cnt;++i) to2[i].clear(),f[i].second=1; // 这里要反向建图，所以清空了重来 for(rgi i=1;i&lt;=n;++i) for(rgi j=0;j&lt;to[i].size();++j) if(col[i]!=col[to[i][j]]&amp;&amp;!s.count(make_pair(col[i],col[to[i][j]]))) to2[col[to[i][j]]].push_back(col[i]),s.insert(make_pair(col[i],col[to[i][j]])); // 注意连接两分量的同一条边不能加多次，否则会多次更新 pair&lt;ll,ll&gt; res=make_pair(0,0); for(rgi i=cnt,u;i&gt;0;--i) { u=topo[i],f[u].first+=siz[u],insert(res,f[u]); for(rgi j=0;j&lt;to2[u].size();++j) insert(f[to2[u][j]],f[u]); } return res; } signed main() { // freopen(&quot;graph.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;graph.out&quot;,&quot;w&quot;,stdout); n=read(),m=read(),p=read(); for(rgi i=1;i&lt;=m;++i) u=read(),v=read(),to[u].push_back(v); for(rgi i=1;i&lt;=n;++i) if(!dfn[i]) tarjan(i); topsort(); pair&lt;ll,ll&gt; ans=calc(); printf(&quot;%lld\\n%lld&quot;,ans.first,ans.second); return 0; } // ---------------------------- // by imzzy T3 最短路 题面（DARKBZOJ） 前置知识 最短路算法（Dijkstra） 思路 先考虑连上所有存在的边（即每两个点间连两条，分别为横纵坐标的差），然后再考虑删掉无用边。分方向讨论，先看横向边，如果 iii 在 jjj 的左侧，jjj 在 kkk 的左侧，那么很明显 iii 至 kkk 的横向边是毫无意义的（因为这条边完全可以被 i→j→ki\\to j\\to ki→j→k 这条路径替代），也就是说按照横坐标排序后，横向边只用连接相邻两点即可。纵坐标同理。这样连边后边数就已经是 O(n)\\mathcal{O}(n)O(n) 级别的了，剩下就是正常求最短路即可 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long // ---------------------------- // #define int ll using namespace std; const int maxn=200004; const int mod=998244353,inf=1000000007; inline int read() { int x=0,f=0,ch=0; while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); return f?-x:x; } int n; struct EDGE{int v,nxt; ll w;}e[maxn&lt;&lt;2]; int first[maxn],cnte; inline void addedge(int p,int q,ll w) { e[++cnte].v=q,e[cnte].w=w, e[cnte].nxt=first[p],first[p]=cnte; } inline void addedge2(int p,int q,ll w) {addedge(p,q,w),addedge(q,p,w);} struct NODE{ int v; ll w; inline bool operator&lt;(const NODE &amp;a) const {return w&gt;a.w;}; NODE(int a,int b) {v=a,w=b;} }; ll dis[maxn]; bool vis[maxn]; priority_queue&lt;NODE&gt; q; ll Dij() // Dijkstra { memset(dis,0x3f,sizeof(dis)); int u,v; q.push(NODE(1,0)),dis[1]=0; while(!q.empty()) { u=q.top().v,q.pop(); if(vis[u]) continue; vis[u]=1; for(rgi i=first[u];i;i=e[i].nxt) { v=e[i].v; if(dis[v]&gt;dis[u]+e[i].w) dis[v]=dis[u]+e[i].w,q.push(NODE(v,dis[v])); } } return dis[n]; } struct POINT{int x,y,k;}p[maxn]; inline bool cmp1(POINT a,POINT b) {return a.x&lt;b.x;} inline bool cmp2(POINT a,POINT b) {return a.y&lt;b.y;} signed main() { // freopen(&quot;dist.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;dist.out&quot;,&quot;w&quot;,stdout); n=read(); for(rgi i=1;i&lt;=n;++i) p[i].x=read(),p[i].y=read(),p[i].k=i; sort(p+1,p+1+n,cmp1); for(rgi i=1;i&lt;n;++i) addedge2(p[i].k,p[i+1].k,p[i+1].x-p[i].x); sort(p+1,p+1+n,cmp2); for(rgi i=1;i&lt;n;++i) addedge2(p[i].k,p[i+1].k,p[i+1].y-p[i].y); // 分别按横纵坐标排序后加边 printf(&quot;%lld&quot;,Dij()); return 0; } // ---------------------------- // by imzzy T4 平面图判定 题面（luogu） 前置知识 并查集 思路 首先，我们知道平面图节点数 nnn 和边数 mmm 总有 m≤3n−6m\\le3n-6m≤3n−6，因此如果给的 m&gt;3n−6m&gt;3n-6m&gt;3n−6 就可以直接断言其非平面图了。因此可以将图的边数降至 O(n)\\mathcal{O}(n)O(n) 级别。 既然题目给的是个哈密顿图，还给出了哈密顿回路，那么我们就先画出这个回路，形成一个大圈。很明显，这个图里的所有边，要么在圈内，要么在圈外，要么在圈上 （废话）。 在圈上的边不用考虑，因为说“要么在圈内，要么在圈外，要么在圈上”时已经确定了没有边穿过圈，即圈上所有边不跟其它边相交。而对于其它边，如果记 st[i]st[i]st[i] 为边 iii 在圈内的断言，st′[i]st&#x27;[i]st′[i] 为边 iii 在圈外的断言，那么如果边 i,ji,ji,j 在圈内会相交，则始终有 st[i]⇔st′[j],st[j]⇔st′[i]st[i]\\Leftrightarrow st&#x27;[j],st[j]\\Leftrightarrow st&#x27;[i]st[i]⇔st′[j],st[j]⇔st′[i] 成立。 因此我们只用将所有此类条件整合，并检查是否有矛盾即可。矛盾的形式也很容易看出来，只用判断有没有 st[i]∧st′[i]st[i]\\wedge st&#x27;[i]st[i]∧st′[i] 为真的情况，如果没有就是平面图，有则不是 至于维护这些关系，我们可以用并查集维护一些等价类。比如 st[i]⇔st′[j]st[i]\\Leftrightarrow st&#x27;[j]st[i]⇔st′[j] 就相当于 st[i]st[i]st[i] 和 st′[j]st&#x27;[j]st′[j] 在同一等价类中，即对这两个状态原处的等价类进行合并；最后对于每个 iii 再检查 st[i]st[i]st[i] 和 st′[i]st&#x27;[i]st′[i] 是否在同一等价类即可。 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long // ---------------------------- // #define int ll using namespace std; const int maxn=204,maxm=100004; const int mod=998244353,inf=1000000007; inline int read() { int x=0,f=0,ch=0; while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'),ch=getchar(); return f?-x:x; } int n,m; int u[maxm],v[maxm],a[maxn],pos[maxn]; class DSU{ // 并查集 private: int fa[maxm]; public: inline void build(int siz) {for(rgi i=1;i&lt;=siz;++i) fa[i]=i;} inline int find(int p) {while(fa[p]!=p) p=fa[p]=fa[fa[p]]; return p;} inline void merge(int p,int q) {fa[find(p)]=find(q);} inline bool query(int p,int q) {return find(p)==find(q);} }dsu; signed main() { // freopen(&quot;planar.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;planar.out&quot;,&quot;w&quot;,stdout); rgi T=read(); while(T--) { n=read(),m=read(); for(rgi i=1;i&lt;=m;++i) u[i]=read(),v[i]=read(); for(rgi i=1;i&lt;=n;++i) a[i]=read(),pos[a[i]]=i; // pos[i] 为节点 i 在圈上的编号 if(m&gt;n*3-6) {puts(&quot;NO&quot;); continue;} for(rgi i=1;i&lt;=m;++i) { u[i]=pos[u[i]],v[i]=pos[v[i]]; // 改一下节点编号，方便后面判圈内两边是否交叉 if(u[i]&gt;v[i]) swap(u[i],v[i]); // 免于分类讨论 } dsu.build(m*2+1); for(rgi i=1;i&lt;=m;++i) for(rgi j=i+1;j&lt;=m;++j) { if(u[i]==u[j]||v[i]==v[j]||u[j]==v[i]||u[i]==v[j]) continue; // 有相同节点即可跳过 int a=i,b=j; if(u[a]&gt;u[b]) swap(a,b); // 免于分类讨论 if(u[b]&lt;v[a]&amp;&amp;v[a]&lt;v[b]) dsu.merge(a,b+m),dsu.merge(b,a+m); } bool flag=1; for(rgi i=1;i&lt;=m&amp;&amp;flag;++i) if(dsu.query(i,i+m)) flag=0; puts(flag?&quot;YES&quot;:&quot;NO&quot;); } return 0; } // ---------------------------- // by imzzy 3. 总结 emmmm…… 前三题都还是想到了的，但时间分配不当、实现上也有些问题，所以丢了不少分。最后一题 2-SAT 或者 DSU，这个套路没怎么做过，不太会用，平面图的性质也不知道，没想出来也算正常（?） ","link":"https://imzzy1201.github.io/post/LQUS5KCXn/"},{"title":"杂题 - CF1375F Integer Game","content":" Whatever you do, you hold on to that foolishly hopeful smile. 题面 题意简述： Anton 有 3 堆石头，分别有 a,b,ca,b,ca,b,c 个。每次操作 Harris 扔给 Anton yyy 个石头，Anton 要选择一堆扔进去，相邻两次操作 Anton 不能扔进同一堆。如果 3 堆中任意两堆的石头个数一样，Anton 输；如果 1000 轮操作 Anton 还没输，Harris 就输。 给你 a,b,ca,b,ca,b,c，让你选个人只会他赢。 前置知识 顺序结构程序设计（ ? ? ? ） 思路 我们先考虑什么时候 Anton 会挂。现在我们先假设 a&lt;b&lt;ca&lt;b&lt;ca&lt;b&lt;c，其分别对应的石子堆记为 A,B,CA,B,CA,B,C（注意 A,B,CA,B,CA,B,C 在不同轮代表的石堆也不同）下面分类讨论： Anton 上一轮没扔进 CCC 很明显他这轮选 CCC 的堆往里面扔，一定死不了。 Anton 上一轮扔进了 CCC 我们假设 c−b≠b−ac-b\\neq b-ac−b​=b−a，那么如果 k=c−bk=c-bk=c−b 就往 AAA 里扔，如果 k=b−ak=b-ak=b−a 就往 BBB 里扔，否则随便扔。 假设 c−b=b−ac-b=b-ac−b=b−a，那么只要扔给他 b−ab-ab−a 个石头 Anton 就必死无疑了 那么也就是说，只有 Anton 上一轮扔进了 CCC，并且 c−b=b−ac-b=b-ac−b=b−a，Harris 才必胜。 再往前推一步，怎么让 Anton 只能选扔进 CCC，并且 c−b=b−ac-b=b-ac−b=b−a 呢？ 一个巧妙的构造方法是，假设当前三堆石头个数分别为 a0,b0,c0 (a0&lt;b0&lt;c0)a_0,b_0,c_0\\ (a_0&lt;b_0&lt;c_0)a0​,b0​,c0​ (a0​&lt;b0​&lt;c0​)，并且上一轮 Anton 扔到了 CCC 里。如果叫 Harris 扔给 Anton 2c0−a0−b02c_0-a_0-b_02c0​−a0​−b0​ 个石头，我们发现： 如果 Anton 放进了 AAA，则新的石头个数为 b0,c0,2c0−b0b_0,c_0,2c_0-b_0b0​,c0​,2c0​−b0​，则有 c−b=b−a=c0−b0c-b=b-a=c_0-b_0c−b=b−a=c0​−b0​ 如果 Anton 放进了 BBB，则新的石头个数为 a0,c0,2c0−a0a_0,c_0,2c_0-a_0a0​,c0​,2c0​−a0​，则有 c−b=b−a=c0−a0c-b=b-a=c_0-a_0c−b=b−a=c0​−a0​ 那么这样操作就逼死 Anton 了。 最后有一个小问题，就是上面的方法中要求 Anton 前一轮扔到了 CCC 里。这也很好解决，叫 Harris 一开始就扔给 Anton 一个嘿大的数，不管怎样 Anton 扔到的堆都会成为新一轮的 CCC。 Code ll a[4]; signed main() { fin&gt;&gt;a[1]&gt;&gt;a[2]&gt;&gt;a[3]; puts(&quot;First&quot;),fflush(stdout); puts(&quot;100000000000&quot;),fflush(stdout); int t,x; fin&gt;&gt;t,a[t]+=100000000000ll; fout&lt;&lt;(3ll*a[t]-a[1]-a[2]-a[3])&lt;&lt;endl,fflush(stdout); fin&gt;&gt;x; fout&lt;&lt;a[t]-a[6-x-t]&lt;&lt;endl,fflush(stdout); fin&gt;&gt;x; return 0; } ","link":"https://imzzy1201.github.io/post/1Qf-3P6_-/"},{"title":"游记 - HBOI2020","content":" You have to work very hard to believe that you are really powerless. Day -?? 沉迷于 whk，码了几个小 DS，然后开始重写各种各样的【模板】。 Day -? 发现自己连 kmp 都忘了，然后开始恶补字符串。（虽然最后根本没考串串） 考了套模拟赛，做得还不错。 Day 0 whk 考试去了，最后晚上陪 xiong_6\\textsf{\\color{black}x\\color{red}iong\\_6}xiong_6 码了个线段树 1（听说能增加 rp ？？？）然后就睡了。 Day 1 题目还好，拿到之后扫一遍题面觉得 T1 可做，T2 说不准，T3 完全不可做。 仔细想了想 T1，想法是值域树状数组上二分，log⁡2\\log^2log2 的，但自以为常数很小能过，于是没有继续想一个 log⁡\\loglog 的解法了。 然后开始肝 T2，发现大概在寒假的时候我问过 xiong_6 差不多的题？？？然而遗憾的是那时候没做出来。于是开始尝试找规律。大概就是给定 n,kn,kn,k，尝试把 ∑i=0nikxi(ni)\\sum_{i=0}^n i^kx^i\\binom{n}{i} i=0∑n​ikxi(in​) 表示成 ∑i=n−knfixn−i∑j=0ixj(ij)\\sum_{i=n-k}^nf_ix^{n-i}\\sum_{j=0}^{i}x^j\\binom{i}{j} i=n−k∑n​fi​xn−ij=0∑i​xj(ji​) 即 ∑i=n−knfixn−i(x+1)i\\sum_{i=n-k}^nf_ix^{n-i}(x+1)^i i=n−k∑n​fi​xn−i(x+1)i 然后就开始对 {f}\\{f\\}{f} 找规律。 配合着暴力程序，估摸着找了 2h，找到了个奇奇怪怪的规律，然后码出来就过了大样例。 回头来码 T1 了，码了一半才发现常数巨大。。。但时间已经不多了，所以决定先码完 T1 log⁡2\\log^2log2 和 T3 大暴力再回头想。 于是就调了半天 T3 。。。 最后慌慌张张自己造了几个小数据拍了下 T1 T2，检查了 freopen，就考试结束了。然后发现好多人都没做出来 T2 ？？ 然后估分 Day 1 60+100+15=17560+100+15=17560+100+15=175，感觉良好 回家也没干啥主要就是补觉，然后听说 FZzzz\\textsf{\\color{black}F\\color{red}Zzzz}FZzzz T1 一个 log⁡\\loglog 跑 10s+ ？？？于是开始怀疑自己 606060 都拿不到了（ Day 2 一拿到卷子就毫无头绪（预示着要爆零？） 冷静想了想……依然毫无头绪…… T1 准备先写个暴力找找规律，然后发现找不到规律。然后尝试贪心，发现贪心是错的。考虑 DP 但不会 DP。决定先放着暴力看后面的题去。 然后是 T2，DS 题，看起来要支持区间加一、插入值、查询区间异或和。尝试线段树，failed；尝试值域树状数组，failed；尝试 01trie，发现自己根本没做过 01trie 的题，果断 failed。于是只得调头拿傻瓜分，并期望着出题人拿脚造数据。 看 T3 去了，求生成树个数 ？又推了半天式子然而毫无进展，于是又去码暴力了。 然后就开始狂想 T1 T3 的其它部分分，但依然不会。 最后除了暴力分啥也没拿到…… 估分 Day 2 30+10+30=7030+10+30=7030+10+30=70，爬了 回家才知道 T2 是原题 Day 3 到咕上测了两天的 T1 T2，D1 T1 606060 T2 100100100，D2 T1 挂了 T2 808080 (?) 然后发现 D1 T1 真的好卡常啊 Day 4 这，就出成绩了？ 于是 D2 T2 依然只有 101010 分，D2 T3 还 WA 了 555 分 End 总分：240240240（HB rk9） 加权分：240×70%+241×30%=240.3240\\times70\\%+241\\times30\\%=240.3240×70%+241×30%=240.3（HB rk13） E 队差一点 省选考得还好，但去年 CSP-S 太菜了，整个队线里 CSP 成绩倒数第二的比我高 50 😵 问题主要在会的知识点太少了，然后有些知识点会但练得不够，还有不会卡常 今年省选的题也是垃圾，5/6 原题 然后弱省终究是弱省，线不到 200 怕不是码全暴力 = 进队 ","link":"https://imzzy1201.github.io/post/akubgc5lY/"},{"title":"笔记 - 后缀数据结构","content":" Everythings comes full circle. 后缀数据结构是解决字符串相关问题的利器，其具有代码短、板子好记、时间复杂度低、应用广泛的优点。 此介绍 2 种常用结构：后缀树、后缀数组 前置约定 ϵ\\epsilonϵ 为空串 SSS 为原串，其下标从 111 开始 n=∣S∣n=|S|n=∣S∣ 为 SSS 的长度，代码中其最大值用 maxn 表示 S[i]S[i]S[i] 为 SSS 的第 iii 个字符 S[l..r]S[l..r]S[l..r] 为 SSS 中第 lll 个字符到第 rrr 个字符顺序连接形成的子串 SiS^iSi 为 SSS 的以第 iii 个字符为起始的后缀，即 S[i..n]S[i..n]S[i..n] SiS_iSi​ 为 SSS 的以第 iii 个字符为末尾的前缀，即 S[1..i]S[1..i]S[1..i] S1S2‾\\overline{S_1S_2}S1​S2​​ 表示 S1S_1S1​ 和 S2S_2S2​ 串连得到的字符串 Σ\\SigmaΣ 为 SSS 的字符集 ∣Σ∣|\\Sigma|∣Σ∣ 为 SSS 的字符集的元素个数，代码中其最大值用 maxm 表示 后缀树 前置知识 字符串和树的定义与基础知识 字典树（Trie） 定义 为了方便描述，我们先作出如下几个特殊定义： 边的标记串：边上的字符串 路径的标记串：AAA 和 BBB 两节点（约定 AAA 是 BBB 的祖先）间的路径标记为，从浅到深，串连从 AAA 到 BBB 的唯一路径经过的所有边的标记串，所得到的新串 节点对应的串：AAA 节点对应的串即为从根节点到 AAA 的路径标记串 一个串在后缀树中：即其可被表示为某个节点对应串的前缀 一个串在节点 AAA 上：即 AAA 的对应串就是这个串 后缀树（Suffix Tree, SFT）可以看作是压缩后的后缀字典树。具体来说，对于一个串 SSS，其后缀树可以认为是，将其所有后缀插入一个字典树中，然后去掉所有子节点个数为 111 的非根节点，并合并其父边和其唯一的子边（合并后的边标记串即为从被删去的节点的父节点到子节点的路径标记串）。 举个例子，下图是串 S=bananaS=\\mathtt{banana}S=banana 的后缀字典树： 下图是其后缀树： 但我们发现，并不是 SSS 的所有后缀都在某个节点上，比如 banana\\mathtt{banana}banana 的后缀树中 na\\mathtt{na}na 就不在任何一个节点上。这个问题在应用中会造成很多不便之处，所以一般而言说 SSS 的后缀树指的是在末尾加一个结束符 $\\mathtt{\\$}$ 后得到的串的后缀树，即 S $‾\\overline{S\\;\\mathtt{\\$}}S$​ 的后缀树： 这样就不存在这个问题了。 性质 后缀树的性质比较显然，但无论在构造中还是在解题中都非常重要，下面给出几个常用的： 所有非根节点的子节点个数都不为 111 原串的所有连续子串在后缀树中 所有不是原串连续子串的字符串都不在后缀树中 若原串包含结束符，那么原串的所有后缀串都在某个节点上 注：后文讲简称这些性质为“性质 1 ”“性质 3 ”等（后文方案、情况等同此表达） 表示方式 注意到所有边的标记串都是原串的连续子串，所以我们一般不会直接记录标记串，而是对其标记一个有序数对 (pos, len)(pos,\\,len)(pos,len)，表示其对应原串连续子串的起始位置和长度。特别的，如果标记串为原串的后缀，为了方便后续操作我们将其长度 lenlenlen 记为 inf⁡\\infinf。比如上图中标记为 banana$\\mathtt{banana\\$}banana$ 的边我们记为 (1, inf⁡)(1,\\,\\inf)(1,inf)，标记为 aaa 的边我们记为 (2,1)(2,1)(2,1)。边我们记录在节点的结构体中（即记录为父边） 其它的东西跟 Trie 的记录方式相同。 下面给出一个参考的节点结构体： struct NODE{ std::pair&lt;int,int&gt; fa; // 即父边 int ch[maxm]; // ch[i] 表示以 i 为始的子边连接的子节点编号 } 构建 朴素构建方式 根据定义，我们可以得到一个朴素构建方法。我们新建一个 Trie，将所有后缀顺序插入，然后根据后缀树的压缩要求压缩 Trie，得到结果。 很容易分析出，这个方法的时间和空间复杂度均为 O(n2)\\mathcal{O}(n^2)O(n2)，是很慢的。我们考虑优化，发现这个方法根本不好优化。 于是乎另一个构建的思想应运而生。 隐式树构建 名字是个幌子 所谓隐式树构建其实就是从小到大递推构建 SSS 的前缀串的后缀树，或者说维护后缀树每次往原串追加一个字符（以后称此为一轮插入），最终构建出整个包括结束符的串的后缀树。这个方法看似比朴素构建方式还慢，但优化后它可以达到线性时间。下面我们从暴力开始，一步一步优化，再得到它的线性构造方法。 暴力 首先要发现这个方法的一个算的上很优的性质，就是若 l&lt;rl&lt;rl&lt;r，则 SrS_rSr​ 的后缀树必定包含 SlS_lSl​ 的后缀树。也就是在上面说的插入一个字符后，后缀树只可能发生的一系列变化只可能有三种：一种是从某个节点伸出一条边指向一个新的节点；一种是将一条边切断为上下两部分，中间新建一个节点连接（后文称其为分裂）；另一种是往一条边的标记串追加一个字符。 现在我们来讨论在插入 S[i..j]S[i..j]S[i..j]，即构建 SjS_jSj​ 的后缀树时插入 (Sj)i(S_j)^i(Sj​)i 出现的情况 如果 S[i..j]S[i..j]S[i..j] 已经在后缀树里了，那显然可以不用管它，下面讨论如果 S[i..j]S[i..j]S[i..j] 不在后缀树里该如何操作。 首先，根据 性质 2，我们知道原树中必定有 S[i..j−1]S[i..j-1]S[i..j−1]，但它既可能正好是某个节点的对应串，也可能不是。那么我们先假设它是 AAA 的对应串的前缀（为了保证唯一性，我们令 AAA 为所有满足条件的节点中深度最小的一个） 如果 S[i..j−1]S[i..j-1]S[i..j−1] 正好在节点 AAA 上，那很好办了： 如果 AAA 是叶子节点，我们直接在 AAA 的父边标记串最后追加一个 S[j]S[j]S[j] 就好了。又因为 AAA 的对应串正好也是 Sj−1S_{j-1}Sj−1​ 的后缀，而追加后 AAA 的父边又成了 SjS_jSj​ 的后缀，所以追加前后 AAA 的父边的 lenlenlen 一直都是 inf⁡\\infinf，即不用改变其边的标记。或者简单来说，我们就跳过它！再如果 AAA 不是叶子节点，也很好办，我们从 AAA 伸出一条边，对应串为 S[j]S[j]S[j] 的边（标记为 (j, inf⁡)(j,\\,\\inf)(j,inf)），指向一个新的节点就好。注意这里的叶子节点不能包括根节点，因为根节点没有父边。 稍加思考就能发现上面两个操作方法符合后缀树的构造要求。 然而另一种情况就稍微麻烦一点了，如果 S[i..j−1]S[i..j-1]S[i..j−1] 是 AAA 对应串的真前缀（即与 AAA 的对应串不同但为其前缀），又该怎么办呢？我们先记 AAA 的对应串为 S′S&#x27;S′，假设 S[i..j−1]=Sk′S[i..j-1]=S&#x27;_kS[i..j−1]=Sk′​。根据后缀树由后缀 Trie 压缩得到的定义，我们知道本来应该从后缀 Trie 上对应串为 Sk′S&#x27;_kSk′​ 的节点 KKK 处伸出一条对应串为 S[j]S[j]S[j] 的边。然而这个 KKK 却不在后缀树上，因为它在原来的后缀树压缩的时候被扔了。这时，我们就应该把它捡回来，或者说在这里分裂出一个对应串为 Sk′S&#x27;_kSk′​ 的节点 KKK，然后像 Trie 上插入一样从这个节点上伸出一条对应串为 S[j]S[j]S[j] 的边（标记为 (j, inf⁡)(j,\\,\\inf)(j,inf)）。 总结来说，分 三种方案 ： 如果 S[i..j]S[i..j]S[i..j] 在后缀树中或 S[i..j−1]S[i..j-1]S[i..j−1] 是某个非根的叶节点 AAA 的对应串 不管它 如果 S[i..j]S[i..j]S[i..j] 在不后缀树中且 S[i..j−1]S[i..j-1]S[i..j−1] 与根节点或某个非叶子节点 AAA 的对应串相同 从 AAA 伸出一条标记为 (j, inf⁡)(j,\\,\\inf)(j,inf) 的边 其它情况 分裂出一个对应串为 S[i..j−1]S[i..j-1]S[i..j−1] 的节点，从其伸出一条标记为 (j, inf⁡)(j,\\,\\inf)(j,inf) 的边 我们按照上述方案从长到短插入即可。 没有什么比举例子更好说明的方法了，下面我们举例构造 cacfccf$\\mathtt{cacfccf\\$}cacfccf$ 的后缀树（图中红色的边即为此次插入时修改过的边）： 首先我们有个根节点 0 c\\mathtt{c}c 来了，插入串 c\\mathtt{c}c。我们发现上文提到的 S[i..j−1]S[i..j-1]S[i..j−1] 即 S[1..0]S[1..0]S[1..0] 即空串，在节点 0 上，而 0 是根节点。所以根据 方案 2 ，我们伸出一条标记为 (1, inf⁡)(1,\\,\\inf)(1,inf) 的边 然后 a\\mathtt{a}a 来了，于是我们插入串 {a,ca}\\{\\mathtt{a},\\mathtt{ca}\\}{a,ca}。对于 ca\\mathtt{ca}ca 观察到串 c\\mathtt{c}c 在节点 1 上，而 1 是叶节点，所以套用 方案 1 ；对于 a\\mathtt{a}a 观察到空串在节点 0 上，而 0 是根节点，所以套用 方案 2 又来了个 c\\mathtt{c}c，我们要插入串 {c,ac,cac}\\{\\mathtt{c},\\mathtt{ac},\\mathtt{cac}\\}{c,ac,cac}。cac\\mathtt{cac}cac 和 ac\\mathtt{ac}ac 都因为“S[i..j−1]S[i..j-1]S[i..j−1] 在某个非根的叶节点 AAA 上”而套用 方案 1 ，c\\mathtt{c}c 则因本身就在后缀树中而也套用了 方案 1 . f\\mathtt{f}f 来了，插入串 {f,cf,acf,cacf}\\{\\mathtt{f},\\mathtt{cf},\\mathtt{acf},\\mathtt{cacf}\\}{f,cf,acf,cacf}。插入 cacf\\mathtt{cacf}cacf 和 acf\\mathtt{acf}acf 时都套用 方案 1 。而当插入 cf\\mathtt{cf}cf 时，我们发现 c\\mathtt{c}c 在原树中不在任何节点上，这时我们就得用 方案 3 了， 分裂出节点 3 对应串 c\\mathtt{c}c，再从 3 伸出标记为 (4, inf⁡)(4,\\,\\inf)(4,inf) 的边指向新节点 4。最后插入 f\\mathtt{f}f 套用了 方案 2 。 剩下的几轮操作也相似，这里给出图，不再作详细说明了。 可以发现，一轮要插入 n+1n+1n+1 个字符，插入第 iii 个字符时要执行 iii 次方案，每次执行方案前都还要在后缀树中定位串的位置，所以总复杂度为 O(n3)\\mathcal{O}(n^3)O(n3)，甚至比朴素构建方法还慢……所以我们有了优化 优化 仔细看上面的图，我们会发现其中执行了很多次 方案 1 ，而 方案 1 事实上根本没有改变原树。因此我们尝试预判插入串时哪些将要执行 方案 1 ，并跳过它，或者说尽量避开 方案 1 。 假定现在插入的串是 S[i..j]S[i..j]S[i..j]，我们现在再把 方案 1 细分成 两个情况 ： S[i..j]S[i..j]S[i..j] 已经在后缀树中了 S[i..j−1]S[i..j-1]S[i..j−1] 是非根叶节点 AAA 的对应串 下面就推导几个与优化相关的重要 新性质 ： 仔细观察，我们可以发现，根据后缀树的 性质 2,3 ，如果后缀树里有串 S′S&#x27;S′ 那么 S′S&#x27;S′ 必定是原串的连续子串，而且 S′S&#x27;S′ 的所有连续子串也在后缀树中。那么，既然 S[i..j]S[i..j]S[i..j] 已经在树中了，所以 S[i+1..j], S[i+2..j],⋯ , S[j..j]S_[i+1..j],\\,S[i+2..j],\\cdots,\\,S[j..j]S[​i+1..j],S[i+2..j],⋯,S[j..j] 也都在后缀树中。因此显然，所有此轮需要插入的比 S[i..j]S[i..j]S[i..j] 短的所有串，都在树中。也就是说，当插入时遇到了 情况 1 ，我们就可以结束此轮插入。 再看到如果 S[i..j]S[i..j]S[i..j] 满足 情况 2 ，那么 S[i−1..j], S[i−2..j],⋯ , S[1..j]S[i-1..j],\\,S[i-2..j],\\cdots,\\,S[1..j]S[i−1..j],S[i−2..j],⋯,S[1..j] 也肯定满足 情况 2 。下面给出一个简单的证明： 反证法，假设 S[i−k,j−1] (0&lt;k&lt;i)S[i-k,j-1]\\ (0&lt;k&lt;i)S[i−k,j−1] (0&lt;k&lt;i) 不在非根叶节点上，那么根据 性质 2,3 ，我们可以得到必定存在一个非空串串 S′S&#x27;S′ 使得 S[i−k..j−1]S′‾\\overline{S[i-k..j-1]S&#x27;}S[i−k..j−1]S′​ 也在后缀树中（否则 S[i−k..j−1]S[i-k..j-1]S[i−k..j−1] 就在叶节点上了），再用一遍 性质 2 我们就得到 S[i,j−1]S′‾\\overline{S[i,j-1]S&#x27;}S[i,j−1]S′​ 也在树中（因为其是 S[i−k..j−1]S′‾\\overline{S[i-k..j-1]S&#x27;}S[i−k..j−1]S′​ 的后缀），所以 S[i..j−1]S[i..j-1]S[i..j−1] 也不在叶节点上，与题设矛盾！ 刚刚上面的那个新性质似乎直接不太好用，需要配合另一个性质才好。如果 S[i..j]S[i..j]S[i..j] 满足 情况 2 ，那么 S[i..j+1]S[i..j+1]S[i..j+1] 也满足 情况 2 。这个很好证，可以自行证明或感性理解一下就好了。 重要的是，根据刚刚讲的两个新性质，我们又得到了一个很棒的优化：若插入 SjS_jSj​ 这轮操作中，S[i..j]S_[i..j]S[​i..j] 满足了 情况 2 ，那么以后插入 S[k] (k&gt;j)S[k]\\ (k&gt;j)S[k] (k&gt;j) 的操作中可以直接从 S[i+1..k]S[i+1..k]S[i+1..k] 开始 总结来说现在有了两个 优化 ： 当插入时遇到了 情况 1 ，结束此轮插入 若插入 SjS_jSj​ 这轮操作中，S[i..j]S[i..j]S[i..j] 满足了 情况 2 ，那么以后插入 S[k] (k&gt;j)S[k]\\ (k&gt;j)S[k] (k&gt;j) 的操作中可以直接从 S[i+1..k]S[i+1..k]S[i+1..k] 开始 我们还是举个例子来说明： 这是优化后构造 S=acamsam$S=\\mathtt{acamsam\\$}S=acamsam$ 的步骤，每幅图中都标注了尝试插入了哪些串，灰色是已经被跳过的串，红色是上述 情况 1 ，橙色是 情况 2 ，蓝色是正常插入（ 方案 2,3 ） 这个优化看起来不大，但却为线性时间做了很大的贡献。我们可以发现，优化后插入的串的个数一定是线性的： 满足 情况 1 的插入是 O(n)\\mathcal{O}(n)O(n) 的 因为每轮插入一但碰到 情况 1 就结束了，所以每轮最多 111 次 满足 情况 2 的插入是 O(n)\\mathcal{O}(n)O(n) 的 因为这个情况当且仅当在叶节点上插入才会出现，叶节点一共有 n+1n+1n+1 个，而根据 优化 2 每个叶节点也都只会被访问 111 次 不满足 情况 1,2（即不是 方案 1 ）的插入是 O(n)\\mathcal{O}(n)O(n) 的 可以看到既然不是 方案 1 ，那么这次插入必然会增加至少 111 个节点，而根据后缀树 性质 1 可以得到其至多有 2n2n2n 个节点，所以这类插入不超过 2n2n2n 次 这是一个很大的进步，但我们发现每次插入时依然得重新在后缀树中给串串定位，而这就是 O(n)\\mathcal{O}(n)O(n) 的了，所以总时间复杂度依然 O(n2)\\mathcal{O}(n^2)O(n2)……因此又有了二次优化。 二次优化 观察到一次优化后最耗时间的是每次在后缀树中定位串串，我们考虑如何降低这个的复杂度。这里，我们每轮插入时假设最后还插入了一个空串（后文将体现其用处）。 现在引入两个新概念 后缀链 对于一个节点 AAA，若其对应串为 S[l..r]S[l..r]S[l..r]，那么它的 后缀链 link[A]link[A]link[A] 指向对应串为 S[l+1..r]S[l+1..r]S[l+1..r] 的节点（如果不存在这样的节点则指向根节点）。 活动点 即当前正在插入的后缀在原树（还未插入此串时的后缀树）中的位置，这个后缀我们称为 活动串 。 活动点 我们用一个三元组 (now, rem, char)(now,\\,rem,\\,char)(now,rem,char) 来记录，nownownow 表示活动点位于哪个节点的子边上（或正好在节点上），remremrem 表示活动点在子边上的长度（即节点对应串连上子边标记串的前 remremrem 个字符就是活动串），charcharchar 表示这个子边的起始字符。 记录这两个东西有什么用呢？我们下面就来说。 考虑这个 活动点 的含义，我们发现，一轮插入后，比结束插入时的 活动串 长的所有后缀，一定都在后缀树的某个非根叶节点上（这个不太好解释，可以照着后面的例子理解一下）。那么也就是说，在进行下一轮操作时，我们可以直接从上轮插入遗留下的 活动串 加上新插入的字符这里开始插入，再简洁一点，进行下一轮操作时，我们只用将老 活动点 的 rem+1rem+1rem+1 就能得到现需的 活动点 。 比如如果上一轮插入的原串是 abab\\mathtt{abab}abab，结束上轮插入时 活动串 是 ab\\mathtt{ab}ab，此轮插入要追加字符 c\\mathtt{c}c，那么此轮就可以直接从 abc\\mathtt{abc}abc 开始插入；如果上一轮插入的原串是 abc\\mathtt{abc}abc，结束上轮插入时 活动串 是空串，此轮插入要追加字符 d\\mathtt{d}d，那么此轮就可以直接从 d\\mathtt{d}d 开始插入。 再考虑 后缀链 的性质，我们发现插入一个串后，我们发现，如果 nownownow 不为根节点，将 nownownow 更改为 link[now]link[now]link[now]；如果 nownownow 是根节点，则将 rem−1rem-1rem−1。这样，组成的新三元组就是新的 活动点 。 现在再来考虑如何维护上面两个概念。事实上在上述对其作用的讲解中， 活动点 已经被维护了。而对于 后缀链 ，我们可以在一轮操作中，插入的第一个串 后缀链 指向根节点；其余每次插入新串，那么它的 后缀链 一定指向上一次插入的串所在的节点。 注意前面对活动点的维护还有一个遗漏，就是在几次更新后可能 remremrem 比 nownownow 的首字母为 charcharchar 的子边还长，这时我们应该顺着子边跳到它的子节点，并更新 remremrem 和 charcharchar。 上面几个地方其实不太好讲也不太好理解，需要揣摩一下，可以对照一些例子帮助理解（比如可以试试 S=noinonoipnoiS=\\mathtt{noinonoipnoi}S=noinonoipnoi） 在二次优化后得到的这个方法，正是大名鼎鼎的 Ukkonen 算法。 下面是一个 Ukkonen 算法的构造过程可视化（原址在 https://github.com/brenden/ukkonen-animation，根据需求稍有修改）。图中红色节点和边即为 活动点 ，虚线连接的节点则表示 后缀链 。 复杂度分析 第一次优化时我们已经证明了向后缀树插入串的次数是 O(n)\\mathcal{O}(n)O(n) 级别的，注意到每次插入时我们只是维护了几个值，可以对照代码看到除了 活动点 中“顺着子边跳到它的子节点”这里有循环，其它位置都必定是 O(1)\\mathcal{O}(1)O(1) 的。而我们发现活动点的 remremrem 只会在每轮插入的开始 +1+1+1，而每次“顺着子边跳到它的子节点”都会使 remremrem 减小，remremrem 又一直 &gt;0&gt;0&gt;0，所以“顺着子边跳到它的子节点”是均摊 O(1)\\mathcal{O}(1)O(1) 的。所以，我们可以知道其时间复杂度为 O(n)\\mathcal{O}(n)O(n)。 注意到最多 2n2n2n 个节点，而每个节点的 chchch 数组是 O(∣Σ∣)\\mathcal{O}(|\\Sigma|)O(∣Σ∣) 的，因此总的空间复杂度为 O(n∣Σ∣)\\mathcal{O}(n|\\Sigma|)O(n∣Σ∣) 当然，也可以用平衡树（map）维护子节点的映射，这样可以做到时空复杂度均为 O(nlog⁡Σ∣)\\mathcal{O}(n\\log\\Sigma|)O(nlogΣ∣) Code 为了方便，在实现时记根节点为 1 号节点，而活动点的 charcharchar 则被原串和 remremrem 表示。在实现中也还有一些小技巧，可以仔细理解一下代码。 class suffix_tree{ public: int s[maxn],n,now,rem,cnt; struct NODE{int link,pos,len,ch[maxm];}t[maxn&lt;&lt;1]; // link 是后缀链，其它同上文中 NODE 的各变量 inline int newnode(int pos,int l) { NODE &amp;x=t[++cnt]; x.link=1,x.pos=pos,x.len=l; memset(x.ch,0,sizeof(x.ch)); return cnt; } inline void extend(int x) { s[++n]=x,++rem; for(rgi last=1;rem;) { while(rem&gt;t[t[now].ch[s[n-rem+1]]].len) // 即“顺着子边跳到它的子节点” rem-=t[now=t[now].ch[s[n-rem+1]]].len; // s[n-rem+1] 即为文中的 char int &amp;v=t[now].ch[s[n-rem+1]],c=s[t[v].pos+rem-1]; if(!v||c==x) { t[last].link=now,last=now; if(!v) v=newnode(n-rem+1,inf); else break; } else { int u=newnode(t[v].pos,rem-1); t[u].ch[c]=v,t[u].ch[x]=newnode(n,inf); t[v].pos+=rem-1,t[v].len-=rem-1; t[last].link=v=u,last=u; } if(now==1) --rem; else now=t[now].link; } } inline void build(const char *str) { cnt=n=rem=0,t[0].len=inf,now=newnode(0,0); // t[0].len=inf 是为了在 while(rem&gt;t[t[now].ch[s[n-rem+1]]].len) 这句话中 t[now].ch[s[n-rem+1]]（now 没有这个儿子）时及时跳出循环 for(rgi i=0,l=strlen(str);i&lt;l;++i) extend(str[i]-'a'+1); extend(0); } }sft; 应用 后缀树能解决的问题很多，下面给出几个比较常见的。 给定文本串 SSS 和多个模式串 {T}\\{T\\}{T}，查询串 TiT_iTi​ 在 SSS 中的出现次数。 对 SSS 构造后缀树，对每个模式串 T′T&#x27;T′ 都先从根往下找到其在树中的位置。根据 性质 4 ，所到节点的子树中叶节点个数，也就是 SSS 的所有后缀中有前缀为 T′T&#x27;T′ 的个数，即为 SSS 中出现次数。 给定串 SSS，求 SSS 中不同连续子串个数。 对 SSS 构造后缀树。根据 性质 2 ，SSS 的所有连续子串都在树中，或者说原来提到过的后缀 Trie 的节点数正是不同连续子串个数。所以其所有树边的长度和（长度即标记串长度，注意这里构造完后要把标为长 inf⁡\\infinf 的边还原成真实长度）即为不同连续子串个数。 查询串 SSS 中最长重复子串 对 SSS 构造后缀树，其最长重复子串即为出现过至少两次的最长子串，也就是最长的非叶节点对应串。 求两串 S, TS,\\,TS,T 的最长公共子序列（LCS） 对 S # T $‾\\overline{S\\ \\mathtt{\\#}\\ T\\ \\mathtt{\\$}}S # T $​ 建立后缀树，我们发现后缀树叶节点的父边标记串的第一个非字母的字符，要么是 #\\mathtt{\\#}#，要么是 $\\mathtt{\\$}$；如果是 #\\mathtt{\\#}# 就说明这个节点的对应串是 SSS 的后缀，否则即为 TTT 的后缀。那么，既然要求 LCS，也就是求最长的串使得 S, TS,\\,TS,T 均存在一个后缀，满足所求串是它的前缀。也就是在树中求最长的串使其对应节点的子树中有 #\\mathtt{\\#}# 和 $\\mathtt{\\$}$ 即可。 求串 SSS 的最长回文子串 首先和 manacher 算法类似的，我们先在原串每两个位置间插入 ∣\\mathtt{|}∣，然后跟求 LCS 时一样先将 S # S′ $‾\\overline{S\\ \\mathtt{\\#}\\ S&#x27;\\ \\mathtt{\\$}}S # S′ $​（其中 S′S&#x27;S′ 为 SSS 的反串）构造后缀树，我们发现以第 iii 个字符为回文中心的最长回文串就是 SiS^iSi 和 S′n−i+1S&#x27;^{n-i+1}S′n−i+1 的最长公共前缀，对应到后缀树上就是这两个串对应节点的最近公共祖先（LCA）然后就可以求了。 求 SSS 的所有子序列中字典序第 iii 大的串 # 1 重复串算一个 建 SSS 的后缀树，对每个节点 iii 记录其子树中所有边的长度和 sum0[i]sum0[i]sum0[i]，记 iii 的对应串为 S′S&#x27;S′ 与 问题 2 类似的我们可以得到这个长度和即为有 SSS 中前缀有 S′S&#x27;S′ 的不同子串个数。所以预处理 sum0sum0sum0 后我们在树上 DFS，沿字典序枚举子节点的 sum0sum0sum0 加上子边长度，比 iii 大 iii 就减去它并继续枚举，否则 iii 减去子边长并进入此子树 # 2 重复串不算一个 注意到 问题 1 给出的结论，告诉我们一个串 TTT 在文本串 SSS 中的出现次数就是文本串的后缀树上 TTT 对应节点的子树中的叶节点数 siz[i]siz[i]siz[i]。根据这个我们可以求出 SSS 中前缀有 TTT 的子串个数 sum1[i]sum1[i]sum1[i]。剩下跟上面就一样了。 上面两个说起来都有点绕，下面给出对应代码帮助理解。 注意这份代码中已经把标为长 inf⁡\\infinf 的边还原成真实长度，即在 suffix_tree::build() 的最后一行加上 for(rgi i=1;i&lt;=cnt;++i) if(t[i].len&gt;n&lt;&lt;1) t[i].len=n-t[i].p; char str[maxn]; int n; int siz[maxn&lt;&lt;1],sum[2][maxn&lt;&lt;1]; void getsum(int x) { if(sft.t[x].p+sft.t[x].len&gt;n) return siz[x]=1,void(); for(rgi i=0,v;i&lt;=26;++i) if(sft.t[x].ch[i]) { getsum(v=sft.t[x].ch[i]); sum[0][x]+=sum[0][v]+sft.t[v].len; sum[1][x]+=sum[1][v]+sft.t[v].len*siz[v]; siz[x]+=siz[v]; } } char ans[maxn]; int indx; bool dfs(int t,int x,int p) // 返回值为 1 则找不到第 p 大的串 { for(rgi i=0,v,tmp;i&lt;=26;++i) if(sft.t[x].ch[i]) { v=sft.t[x].ch[i],tmp=sft.t[v].len*(t?siz[v]:1); if(p&gt;sum[t][v]+tmp) p-=sum[t][v]+tmp; else { for(rgi i=0;i&lt;sft.t[x].len;++i) ans[indx++]=str[sft.t[x].p+i-1]; if(p&lt;=tmp) for(rgi i=0;i&lt;(p-1)/(t?siz[v]:1)+1;++i) ans[indx++]=str[sft.t[v].p+i-1]; else dfs(t,v,p-tmp); return 0; } } return 1; } signed main() // Luogu P3975 { scanf(&quot;%s&quot;,str),n=strlen(str); sft.build(str),getsum(1); int t,k; fin&gt;&gt;t&gt;&gt;k; // t=0 求 #1，t=1 求 #2 if(dfs(t,1,k)) puts(&quot;-1&quot;); else ans[indx++]='\\0',printf(&quot;%s&quot;,ans); return 0; } 后缀数组 前置知识 字符串和树的定义与基础知识 字典树（Trie） 排序 最好对基数排序有一定的了解，不列为前置知识是因为文中会有详细介绍。 定义 后缀数组（Suffix Array, SA）就是 SSS 的所有后缀按字典序排序后的排名数组，即有 ∀i&lt;j, SSA[i]&lt;SSA[j]\\forall i&lt;j,\\ S^{SA[i]}&lt;S^{SA[j]} ∀i&lt;j, SSA[i]&lt;SSA[j] 举个例子，S=fzfzzfzzzzS=\\texttt{fzfzzfzzzz}S=fzfzzfzzzz 的后缀数组是 {1,3,6,10,2,5,9,4,8,7}\\{1,3,6,10,2,5,9,4,8,7\\}{1,3,6,10,2,5,9,4,8,7} 后缀数组也可以理解为后缀树的 DFS 序中各叶节点的出现顺序： 构建 朴素构建方式 我们根据后缀数组的定义来构造，也就是先列出所有的后缀，然后对其进行排序。 可以发现，排序需要比较 nlog⁡nn\\log nnlogn 次两串，而比较两串则是 (n)\\mathcal(n)(n) 的，因此总时间复杂度是 O(n2log⁡n)\\mathcal{O}(n^2\\log n)O(n2logn)，相较于最低的时空复杂度均 (O)n\\mathcal(O){n}(O)n 差距还很大。 通过后缀树构建 也就是先构建出后缀树，然后在树上 DFS 出后缀数组。 跟直接用后缀树比没有任何优势，时空复杂度也与直接构建后缀树相同。 倍增法 倍增法是竞赛中最常用的个 SA 构建方法，其具有占用空间低、思路清晰易懂、代码短、时间复杂度较优的优点。 为了说明倍增法的思想，我们依然从基本思想开始说起。考虑这样进行排序：第 iii 轮排序对于每个 jjj 的 S[j..min⁡(j+2i−1,n)]S[j..\\min(j+2^i-1,n)]S[j..min(j+2i−1,n)]，直到 2i≥n2^i\\ge n2i≥n（即第 iii 轮排序长度为 2i2^i2i 的子串）。举个例子我们还是排序串 S=fzfzzfzzzzS=\\mathtt{fzfzzfzzzz}S=fzfzzfzzzz，下面列举了每轮排序的待排序串： 第 0 轮 第 1 轮 第 2 轮 第 3 轮 第 4 轮 f z f z z f z z z z\\begin{aligned}\\\\\\mathtt{f\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{z\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{f\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{z\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{z\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{f\\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{z\\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{z\\ \\ \\ \\ }&amp;\\\\\\mathtt{z\\ \\ }&amp;\\\\\\mathtt{z}\\end{aligned}f z f z z f z z z z​​ fz zf fz zz zf fz zz zz zzz\\begin{aligned}\\\\\\mathtt{fz\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zf\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{fz\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zz\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zf\\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{fz\\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zz\\ \\ \\ \\ }&amp;\\\\\\mathtt{zz\\ \\ }&amp;\\\\\\mathtt{zz}&amp;\\\\\\mathtt{z}\\end{aligned}fz zf fz zz zf fz zz zz zzz​​ fzfz zfzz fzzf zzfz zfzz fzzz zzzzzzzzzz\\begin{aligned}\\\\\\mathtt{fzfz\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zfzz\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{fzzf\\ \\ \\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zzfz\\ \\ \\ \\ \\ \\ }&amp;\\\\\\mathtt{zfzz\\ \\ \\ \\ }&amp;\\\\\\mathtt{fzzz\\ \\ }&amp;\\\\\\mathtt{zzzz}&amp;\\\\\\mathtt{zzz}&amp;\\\\\\mathtt{zz}&amp;\\\\\\mathtt{z}\\end{aligned}fzfz zfzz fzzf zzfz zfzz fzzz zzzzzzzzzz​​ fzfzzfzz zfzzfzzz fzzfzzzzzzfzzzzzfzzzzfzzzzzzzzzzzzzz\\begin{aligned}\\\\\\mathtt{fzfzzfzz\\ \\ \\ \\ }&amp;\\\\\\mathtt{zfzzfzzz\\ \\ }&amp;\\\\\\mathtt{fzzfzzzz}&amp;\\\\\\mathtt{zzfzzzz}&amp;\\\\\\mathtt{zfzzzz}&amp;\\\\\\mathtt{fzzzz}&amp;\\\\\\mathtt{zzzz}&amp;\\\\\\mathtt{zzz}&amp;\\\\\\mathtt{zz}&amp;\\\\\\mathtt{z}\\end{aligned}fzfzzfzz zfzzfzzz fzzfzzzzzzfzzzzzfzzzzfzzzzzzzzzzzzzz​​ fzfzzfzzzzzfzzfzzzzfzzfzzzzzzfzzzzzfzzzzfzzzzzzzzzzzzzz\\begin{aligned}\\\\\\mathtt{fzfzzfzzzz}&amp;\\\\\\mathtt{zfzzfzzzz}&amp;\\\\\\mathtt{fzzfzzzz}&amp;\\\\\\mathtt{zzfzzzz}&amp;\\\\\\mathtt{zfzzzz}&amp;\\\\\\mathtt{fzzzz}&amp;\\\\\\mathtt{zzzz}&amp;\\\\\\mathtt{zzz}&amp;\\\\\\mathtt{zz}&amp;\\\\\\mathtt{z}\\end{aligned}fzfzzfzzzzzfzzfzzzzfzzfzzzzzzfzzzzzfzzzzfzzzzzzzzzzzzzz​​ 定义 Si,j=S[j..min⁡(j+2i−1,n)]S_{i,j}=S[j..\\min(j+2^i-1,n)]Si,j​=S[j..min(j+2i−1,n)]（即如上表中的第 iii 轮第 jjj 行，若 j&gt;nj&gt;nj&gt;n 则令其为 ϵ\\epsilonϵ） 那么很明显，有 Si+1,j=Si,j Si,j+2i‾S_{i+1,j}=\\overline{S_{i,j}\\ S_{i,j+2^i}}Si+1,j​=Si,j​ Si,j+2i​​ 再定义 fi,jf_{i,j}fi,j​ 代表 Si,jS_{i,j}Si,j​ 在 Si,k (1≤k≤n)S_{i,k}\\ (1\\le k\\le n)Si,k​ (1≤k≤n) 中的排名。比如上述第 1 轮对应的 f1={1,3,1,4,3,1,4,4,4,2}f_1=\\{1,3,1,4,3,1,4,4,4,2\\}f1​={1,3,1,4,3,1,4,4,4,2}，第 2 轮对应的 f2={1,5,2,7,5,3,9,8,6,4}f_2=\\{1,5,2,7,5,3,9,8,6,4\\}f2​={1,5,2,7,5,3,9,8,6,4} 我们可以得到一个明显却不太明显的结论： 基于同一个 iii，如果我们对于所有 jjj 将 (fi,j, fi,j+2i)(f_{i,j},\\,f_{i,j+2^i})(fi,j​,fi,j+2i​) 排序去重，则 fi+1,j=(fi,j, fi,j+2i)f_{i+1,j}=(f_{i,j},\\,f_{i,j+2^i})fi+1,j​=(fi,j​,fi,j+2i​)排序后的序号。比如还是举 i=1i=1i=1 的例子，用来排序的数对是： {(1,1),(3,4),(1,3),(4,1),(3,4),(1,4),(4,4),(4,2),(4,0),(2,0)}\\{(1,1),(3,4),(1,3),(4,1),(3,4),(1,4),(4,4),(4,2),(4,0),(2,0)\\} {(1,1),(3,4),(1,3),(4,1),(3,4),(1,4),(4,4),(4,2),(4,0),(2,0)} 第 xxx 个数对里的第一个数叫“第 iii 轮中后缀 xxx 的第一关键字”，第二个数叫“第 iii 轮中后缀 xxx 的第二关键字”，后文就直接这样称呼了 排序去重后的数对是： {(1,1),(1,3),(1,4),(2,0),(3,4),(4,0),(4,1),(4,2),(4,4)}\\{(1,1),(1,3),(1,4),(2,0),(3,4),(4,0),(4,1),(4,2),(4,4)\\} {(1,1),(1,3),(1,4),(2,0),(3,4),(4,0),(4,1),(4,2),(4,4)} 所以排序后的序号为 {1,5,2,7,5,3,9,8,6,4}\\{1,5,2,7,5,3,9,8,6,4\\}{1,5,2,7,5,3,9,8,6,4}，也就是 f2f_2f2​ 的值。 根据这个结论，我们就可以在 ⌈log⁡n⌉\\lceil\\log n\\rceil⌈logn⌉ 次排序以内求出 f⌈log⁡n⌉f_{\\lceil\\log n\\rceil}f⌈logn⌉​ 以及 SASASA（SA[i]SA[i]SA[i] 可以理解为 iii 在 f⌈log⁡n⌉f_{\\lceil\\log n\\rceil}f⌈logn⌉​ 中对应的下标） 如果用普通的排序方式，我们就得到了一个 nlog⁡2nn\\log^2nnlog2n 的求法了。 观察到需要排序的对象是一些有序数对，而有序数对中每个数都不超过 nnn，所以我们引入另一种排序方式使得一次排序只用花费 O(n)\\mathcal{O}(n)O(n) 的时间和空间：基数排序。 简单来讲，基数排序就是先按第二关键字桶排序一遍，再按第一关键字桶排序一遍。 SASASA 的代码是精髓，具体实现方法，先上 code，再一点一点讲 Code int n,m; int SA[maxn],c[maxn],t1[maxn],t2[maxn]; inline void getSA() { int *x=t1,*y=t2; for(rgi i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(rgi i=n;i&gt;=1;--i) SA[c[x[i]]--]=i; for(rgi k=1,p;k&lt;=n;k&lt;&lt;=1) {p=0; for(rgi i=n-k+1;i&lt;=n;++i) y[++p]=i; for(rgi i=1;i&lt;=n;++i) if(SA[i]&gt;k) y[++p]=SA[i]-k; for(rgi i=1;i&lt;=m;++i) c[i]=0; for(rgi i=1;i&lt;=n;++i) ++c[x[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(rgi i=n;i&gt;=1;--i) SA[c[x[y[i]]]--]=y[i],y[i]=0; std::swap(x,y),x[SA[1]]=p=1; for(rgi i=2;i&lt;=n;++i) x[SA[i]]=(y[SA[i]]==y[SA[i-1]]&amp;&amp;y[SA[i]+k]==y[SA[i-1]+k])?p:++p; if(n==(m=p)) break; } } 看起来是不是很玄学？ emmmm……一点一点说吧 int n,m; int SA[maxn],c[maxn],t1[maxn],t2[maxn]; 这里的 nnn 是待求 SASASA 的串的长度即 ∣S∣|S|∣S∣；mmm 开始时可以说是字符集的大小即 ∣Σ∣|\\Sigma|∣Σ∣，后面则成为排名的值域（也就是这轮排序了多少种不同的串），这个意义最后会体现的。 SASASA 就是 SASASA（注意每轮排序的串长度是不同的，所以每轮的后缀排序也是不同的），ccc 是用于桶排序串辅助数组，t1,t2t1,t2t1,t2 是另外两个神神奇奇的辅助数组，后面会讲它的作用。 int *x=t1,*y=t2; 这两个东西在不同的地方有不同的意义 for(rgi i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(rgi i=n;i&gt;=1;--i) SA[c[x[i]]--]=i; 首先预处理第 0 轮排序，即对单个字符排序。这三行是正常的桶排序。 第一行先将所有元素放入桶；第二行对桶做前缀和，方便计算排名；第三行将排名放进 SASASA 数组（再说一遍 SA[i]SA[i]SA[i] 表示排名第 iii 的后缀，为了不重复让排名并列的后缀放进同一个位置所以下标要是 c[x[i]]--） for(rgi k=1,p;k&lt;=n;k&lt;&lt;=1) {p=0; 准备基数排序了。注意，kkk 不是本轮排序的串的长度，而是它的一半！然后 ppp 是个辅助变量，可以说是用来记下标的 现在，先理解一个地方，每轮开始时上一轮已经处理好了这一轮的第一关键字，这里就是 xxx，这个在第 1 轮排序时是显然的（第 0 轮里的 xxx 当然可以作为第 1 轮的第一关键字），而在每轮的末尾也都有这个处理过程，具体后面再讲。现在可以这样记着：第 iii 轮开始时 xxx 就是上文中的 fi−1f_{i-1}fi−1​。 举个例子还是 fzfzzfzzzz\\texttt{fzfzzfzzzz}fzfzzfzzzz，第 2 轮排序开始时，xxx 的值就是 {1,3,1,4,3,1,4,4,4,2}\\{1,3,1,4,3,1,4,4,4,2\\}{1,3,1,4,3,1,4,4,4,2}。 那么既然第一关键字已经准备好了，现在就该处理第二关键字了 来到第一个神奇的位置了，马上要现身的 y[i]y[i]y[i] 在这里指第二关键字排名为 iii 的后缀，它原来所处的位置的下标（大雾）。什么意思呢？依然句 fz 的例子来解释： 如果我们现在正在排序第 2 轮（即长度为 444 的串），那么…… 第二关键字：{1,4,3,1,4,4,4,2,0,0}\\{1,4,3,1,4,4,4,2,0,0\\}{1,4,3,1,4,4,4,2,0,0} 第二关键字排序后应该长这样：{0,0,1,1,2,3,4,4,4,4}\\{0,0,1,1,2,3,4,4,4,4\\}{0,0,1,1,2,3,4,4,4,4} 我们看每个数它原来在哪（即原位置的下标）：前两个 000 分别在 9,109,109,10 号位置，111 在 1,41,41,4，222 只在下标为 888 的位置出现过，333 正好在 333 号位，444 则坐落于 2,5,6,72,5,6,72,5,6,7 这几个下标。 所以 yyy 应该为：{9,10,1,4,8,3,2,5,6,7}\\{9,10,1,4,8,3,2,5,6,7\\}{9,10,1,4,8,3,2,5,6,7} 再换句话说 ∀i&lt;j\\forall i&lt;j∀i&lt;j，后缀 y[i]y[i]y[i] 的第二关键字小于等于后缀 y[j]y[j]y[j] 的第二关键字。 好了差不多就这样了，下面看怎么求 yyy： for(rgi i=n-k+1;i&lt;=n;++i) y[++p]=i; 首先可以看到最后 kkk 个后缀在这一轮排序中是没有第二关键字的（或者说第二关键字为 000），所以它们肯定排在最前面。 for(rgi i=1;i&lt;=n;++i) if(SA[i]&gt;k) y[++p]=SA[i]-k; 注意到这里 SA[i]SA[i]SA[i] 相当于上一轮后缀的排序，也就是相当于 xxx 的排序，或者说现在有 ∀i&lt;j,x[SA[i]]≤x[SA[j]]\\forall i&lt;j,x[SA[i]]\\le x[SA[j]]∀i&lt;j,x[SA[i]]≤x[SA[j]]。又观察到 1∼n−k1\\sim n-k1∼n−k 这些后缀在这轮的第二关键字正好是 k+1∼nk+1\\sim nk+1∼n 的第一关键字。所以呢……根据 yyy 的定义，有 ∀i&lt;j,x[y[i]+k]≤x[y[j]+k]\\forall i&lt;j,x[y[i]+k]\\le x[y[j]+k]∀i&lt;j,x[y[i]+k]≤x[y[j]+k] ，发现这不跟 SASASA 有异曲同工之妙吗！于是乎就有了上面的这行码。注意如果 SA[i]≤kSA[i]\\le kSA[i]≤k，那 x[SA[i]]x[SA[i]]x[SA[i]] 显然不在第二关键字里，所以要跳过。 for(rgi i=1;i&lt;=m;++i) c[i]=0; for(rgi i=1;i&lt;=n;++i) ++c[x[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; 再对第一关键字桶排序一遍，跟前面说的差不多。这里是先扔进桶里并跟第 0 轮时一样求个前缀和。 for(rgi i=n;i&gt;=1;--i) SA[c[x[y[i]]]--]=y[i],y[i]=0; 然后要从桶里取出来算这一轮的 SASASA 了。这里套了大概 444 层方括号令人有点非常眼瞎……所以我们从内往外一层一层看： y[i]y[i]y[i]：第二关键字排名为 iii 的后缀的下标（前面说过了） x[y[i]]x[y[i]]x[y[i]]：第二关键字排名为 iii 的后缀的第一关键字 c[x[y[i]]]c[x[y[i]]]c[x[y[i]]]：“第二关键字排名为 iii 的后缀的第一关键字”在桶里的排名（-- 跟之前说的一样是为了保证不重复） SA[c[x[y[i]]]−−]SA[c[x[y[i]]]--]SA[c[x[y[i]]]−−]：SASASA 数组中，下标为上面的“……的排名”的位置 这个怎么理解呢？可以回头对着第 000 轮的那句话 for(rgi i=n;i&gt;=1;--i) SA[c[x[i]]--]=i; 看。它无非就是把下标里的 iii 改成了 y[i]y[i]y[i]，或者说就是换了个访问顺序。正是因为换成了这个 y[i]y[i]y[i] 才使得在第一关键字有序的情况下，第二关键字有序 这个地方仔细模拟一下这个过程，就能理解了。 最后那个 y[i]=0y[i]=0y[i]=0 没别的意思，就只是清空 yyy。 记得前面提到过的“每轮开始时上一轮已经处理好了这一轮的第一关键字”吗？现在就要“履行这个诺言”了。由于下一轮的第一关键字就是这一轮排序后每个后缀的排名，所以直接求这个排名就好 std::swap(x,y),x[SA[1]]=p=1; 这里的交换纯粹是为了方便写，x[SA[1]]=p=1 也挺显然的，第一名的后缀当然排名老大 111 啦。 for(rgi i=2;i&lt;=n;++i) x[SA[i]]=(y[SA[i]]==y[SA[i-1]]&amp;&amp;y[SA[i]+k]==y[SA[i-1]+k])?p:++p; 这句话呢……挺长……但其实意思挺简单。y[SA[i]]==y[SA[i-1]]&amp;&amp;y[SA[i]+k]==y[SA[i-1]+k] 就是判定的这个后缀和上个后缀是不是俩关键字都相同，如果是的话那肯定排名跟上一个也一样即 ppp，否则就要 +1+1+1。 if(n==(m=p)) break; 最后一句，也不难理解了。 首先，最后的 ppp 值也就是这轮排序出现的不同排名的个数，所以 mmm 要被赋值为 ppp 啦。 然后如果 n=mn=mn=m，就说明排名已经两两不同了，也就是已经完全有序了，所以就不用再继续排下去了呗。 那么到这里，倍增法总算是讲完了。。。 如果还是有问题，可以输出一下 SA,x,ySA,x,ySA,x,y 这三个数组对着看看，比如像下面这样： int n,m,SA[maxn],c[maxn],t1[maxn],t2[maxn]; inline void DEBUG(int time,const char *v,int *x,int *y) { printf(&quot;\\n------ DEBUG:%3d, %s ------\\n&quot;,time,v); printf(&quot; SA: &quot;); for(rgi i=1;i&lt;=n;++i) std::cout&lt;&lt;SA[i]&lt;&lt;' '; std::cout&lt;&lt;'\\n'; printf(&quot; x: &quot;); for(rgi i=1;i&lt;=n;++i) std::cout&lt;&lt;x[i]&lt;&lt;' '; std::cout&lt;&lt;'\\n'; printf(&quot; y: &quot;); for(rgi i=1;i&lt;=n;++i) std::cout&lt;&lt;y[i]&lt;&lt;' '; std::cout&lt;&lt;'\\n'; std::cout&lt;&lt;'\\n'; } inline void getSA() { int *x=t1,*y=t2; DEBUG(1,&quot;No.0&quot;,x,y); for(rgi i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(rgi i=1;i&lt;=n;++i) SA[c[x[i]]--]=i; DEBUG(1,&quot;No.1&quot;,x,y); for(rgi k=1,p;k&lt;=n;k&lt;&lt;=1) {p=0; DEBUG(k&lt;&lt;1,&quot;No.0&quot;,x,y); for(rgi i=n-k+1;i&lt;=n;++i) y[++p]=i; for(rgi i=1;i&lt;=n;++i) if(SA[i]&gt;k) y[++p]=SA[i]-k; DEBUG(k&lt;&lt;1,&quot;No.1&quot;,x,y); for(rgi i=1;i&lt;=m;++i) c[i]=0; for(rgi i=1;i&lt;=n;++i) ++c[x[i]]; for(rgi i=2;i&lt;=m;++i) c[i]+=c[i-1]; for(rgi i=n;i&gt;=1;--i) SA[c[x[y[i]]]--]=y[i],y[i]=0; DEBUG(k&lt;&lt;1,&quot;No.2&quot;,x,y); std::swap(x,y),x[SA[1]]=p=1; for(rgi i=2;i&lt;=n;++i) x[SA[i]]=(y[SA[i]]==y[SA[i-1]]&amp;&amp;y[SA[i]+k]==y[SA[i-1]+k])?p:++p; if(n==(m=p)) break; } } DC3/DC 算法 不会，有时间学了就写 SA-IS 算法 也不会，估计会先学这再学 DC3/DC 辅助工具 单单有个后缀数组其实解决不了什么问题，因此我们要引入另外两个辅助数组：rankrankrank 和 heightheightheight。 rank[i]rank[i]rank[i] 顾名思义就是后缀 SiS^iSi 的排名，即 SA[rank[i]]=iSA[rank[i]]=iSA[rank[i]]=i； height[i]height[i]height[i] 指 SSA[i]S^{SA[i]}SSA[i] 和 SSA[i−1]S^{SA[i-1]}SSA[i−1] 的最长公共前缀（LCP），即有 (SSA[i])height[i]=(SSA[i−1])height[i](S^{SA[i]})_{height[i]}=(S^{SA[i-1]})_{height[i]}(SSA[i])height[i]​=(SSA[i−1])height[i]​ 且 (SSA[i])[height[i]+1]≠(SSA[i−1])[height[i]+1](S^{SA[i]})[height[i]+1]\\neq(S^{SA[i-1]})[height[i]+1](SSA[i])[height[i]+1]​=(SSA[i−1])[height[i]+1] 给个图这俩东西就很清晰了： 闲扯一句，heightheightheight 数组也可以认为代表了后缀树中相邻两个叶节点的 LCALCALCA 的映射。 这两个的求法呢，也不难。 rankrankrank 其实就一行，遍历一次 SASASA 数组就好了 int rank[maxn]; for(rgi i=1;i&lt;=n;++i) rank[SA[i]]=i; 如果求 SASASA 时用的是倍增法，甚至可以直接定义全局变量 int *rank; 然后在 getSA 函数的最外层循环之后加上一句 rank=x; 即可 LCP 与 heightheightheight 我们注意到一个性质，height[rank[i]]≥height[rank[i−1]]−1height[rank[i]]\\ge height[rank[i-1]]-1height[rank[i]]≥height[rank[i−1]]−1。这个性质形式化的证明长得比较丑，这里举个例子说明原因。 看到 i=4i=4i=4 的时候，首先，rank[i−1]=2rank[i-1]=2rank[i−1]=2，后缀 i−1i-1i−1 为 fzzfzzzz\\texttt{fzzfzzzz}fzzfzzzz，排名仅高于它的后缀则是 fzfzzfzzzz\\mathtt{fzfzzfzzzz}fzfzzfzzzz，也就是求的这两行的 LCS： 如果我们将这两个串去掉首字母再在里面定位： 可以发现 zzfzzzz\\texttt{zzfzzzz}zzfzzzz 也就是后缀 iii，而 zfzzfzzzz\\mathtt{zfzzfzzzz}zfzzfzzzz 肯定排在 zzfzzzz\\texttt{zzfzzzz}zzfzzzz 之前。既然排在它之前，所以它俩之间的串 肯定排名在它俩之间。 进一步推断，这一堆的所有串的 LCS 必定就是 height[rank[i−1]]−1height[rank[i-1]]-1height[rank[i−1]]−1： 所以就能得到 height[rank[i]]≥height[rank[i−1]]−1height[rank[i]]\\ge height[rank[i-1]]-1height[rank[i]]≥height[rank[i−1]]−1： 有了这个性质，就很容易线性求 heightheightheight 数组了，下面是代码供参考 inline void getheight() { for(rgi i=1,j,k=0;i&lt;=n;++i) { if(k) --k; j=SA[rank[i]-1]; while(s[i+k]==s[j+k]) ++k; height[rank[i]]=k; } } 然后我们再看到，如何求任意两个后缀的 LCP，也很容易发现后缀 i,j (rank[i]&lt;rank[j])i,j\\ (rank[i]&lt;rank[j])i,j (rank[i]&lt;rank[j]) 的 LCP 是 min⁡(height[rank[i]+1],height[rank[i]+2],⋯ ,height[rank[k]])\\min(height[rank[i]+1],height[rank[i]+2],\\cdots,height[rank[k]])min(height[rank[i]+1],height[rank[i]+2],⋯,height[rank[k]])。给个图就很容易理解了： 这相当于对 heightheightheight 数组求区间最小值（RMQ），可以用 ST 表实现，也可以用其它奇奇怪怪的数据结构实现。 应用 后缀数组能解决的问题还是没后缀树多，多数应用是依赖其优秀的线性空间。 给定文本串 SSS 和多个模式串 {T}\\{T\\}{T}，查询串 TiT_iTi​ 在 SSS 中的出现次数。 给定串 SSS，求 SSS 中不同连续子串个数。 查询串 SSS 中最长重复子串 求两串 S, TS,\\,TS,T 的最长公共子序列（LCS） 求串 SSS 的最长回文子串 求 SSS 的所有子序列中字典序第 iii 大的串 # 1 重复串算一个 # 2 重复串不算一个 ","link":"https://imzzy1201.github.io/post/tbrptnzGB/"},{"title":"笔记 - Lucas 定理","content":" Never put off the work till tomorrow, you can put off today. Lucas 定理用于求 (nm)mod p\\dbinom{n}{m}\\mod p(mn​)modp（ppp 为质数） 一般多用于 n,m&gt;pn,m&gt;pn,m&gt;p，即无法使用阶乘取模法的情况。 形式 下面给出两种 Lucas 定理的形式，一般代码用形式 1 写。 形式 1 令 n=sp+q, m=tp+r, q,r≤pn=sp+q,\\ m=tp+r,\\ q,r\\le pn=sp+q, m=tp+r, q,r≤p 则有 (nm)≡(st)(qr)(modp)\\binom{n}{m}\\equiv\\binom s t \\binom q r \\pmod p (mn​)≡(ts​)(rq​)(modp) 形式 2 若将 nnn 写成 ppp 进制的 aq⋯a2a1a0‾\\overline{a_q\\cdots a_2a_1a_0}aq​⋯a2​a1​a0​​，mmm 写成 ppp 进制的 bq⋯b2b1b0‾\\overline{b_q\\cdots b_2b_1b_0}bq​⋯b2​b1​b0​​ 那么 (nm)≡∏i=0q(aibi)(modp)\\binom{n}{m}\\equiv\\prod_{i=0}^q\\binom{a_i}{b_i}\\pmod p (mn​)≡i=0∏q​(bi​ai​​)(modp) 值得注意的是，若 nnn 与 mmm 的 ppp 进制数位数不同，那么 (nm)≡0(modp)\\dbinom{n}{m}\\equiv0\\pmod p(mn​)≡0(modp) 证明 下面是形式 111 推导过程 令 0&lt;f&lt;p0&lt;f&lt;p0&lt;f&lt;p 则 (pf)≡pf(p−1f−1)≡0(modp)\\dbinom{p}{f}\\equiv\\dfrac{p}{f}\\dbinom{p-1}{f-1}\\equiv 0 \\pmod p(fp​)≡fp​(f−1p−1​)≡0(modp) 所以有 (1+x)n≡(1+x)sp+q≡(1+x)sp⋅(1+x)q≡((1+x)p)s⋅(1+x)q≡(∑i=0p(pi)xi(pn−i))s⋅(1+x)q≡(1+xp)s⋅(1+x)q≡∑i=0s(si)xip⋅∑j=0q(qj)xj(modp)\\begin{aligned}\\\\ &amp;(1+x)^n\\\\ \\equiv&amp;(1+x)^{sp+q}\\\\ \\equiv&amp;(1+x)^{sp}\\cdot(1+x)^q\\\\ \\equiv&amp;((1+x)^p)^s\\cdot(1+x)^q\\\\ \\equiv&amp;\\left(\\sum_{i=0}^p\\binom p i x^i \\binom p {n-i}\\right)^s\\cdot(1+x)^q\\\\ \\equiv&amp;(1+x^p)^s\\cdot(1+x)^q\\\\ \\equiv&amp;\\sum_{i=0}^s\\binom s i x^{ip}\\cdot\\sum_{j=0}^q\\binom{q}{j}x^j \\pmod p\\\\ \\end{aligned} ≡≡≡≡≡≡​(1+x)n(1+x)sp+q(1+x)sp⋅(1+x)q((1+x)p)s⋅(1+x)q(i=0∑p​(ip​)xi(n−ip​))s⋅(1+x)q(1+xp)s⋅(1+x)qi=0∑s​(is​)xip⋅j=0∑q​(jq​)xj(modp)​ 即有 (1+x)n≡∑i=0s∑j=0q(si)(qj)xip+j(modp)(1+x)^n\\equiv\\sum_{i=0}^s\\sum_{j=0}^q\\binom{s}{i}\\binom{q}{j}x^{ip+j}\\pmod p (1+x)n≡i=0∑s​j=0∑q​(is​)(jq​)xip+j(modp) 又因为 (1+x)n=∑i=0n(ni)xi(1+x)^n=\\sum_{i=0}^{n}\\binom{n}{i}x^i (1+x)n=i=0∑n​(in​)xi 所以 xmx^mxm 项系数为 (nm)\\dbinom{n}{m}(mn​) 又 (1+x)n≡∑i=0s∑j=0q(si)(qj)xip+j(modp), m=tp+r(1+x)^n\\equiv\\sum_{i=0}^s\\sum_{j=0}^q\\binom{s}{i}\\binom{q}{j}x^{ip+j}\\pmod p,\\ m=tp+r (1+x)n≡i=0∑s​j=0∑q​(is​)(jq​)xip+j(modp), m=tp+r 所以 xmx^mxm 项系数亦为 (st)(qr)\\dbinom{s}{t}\\dbinom{q}{r}(ts​)(rq​) 即 (nm)≡(st)(qr)(modp)\\dbinom{n}{m}\\equiv\\dbinom s t \\dbinom q r \\pmod p(mn​)≡(ts​)(rq​)(modp) 形式 222 与形式 111 本质相同，只不过把 n=sp+q,m=tp+rn=sp+q,m=tp+rn=sp+q,m=tp+r 简化为 n,mn,mn,m 在 ppp 进制下的每一位 Code 依然是一行 ll Lucas(ll n,ll m,ll p) {return m&lt;=0?1LL:(C(n%p,m%p)*Lucas(n/p,m/p)%p);} 扩展定理 扩展 Lucas 定理（exLucas），用于解决 ppp 不是质数的情况 思路大概是这样的，首先分解 ppp 的质因子 p=p1α1p2α2p3α3⋯pkαk=∏i=1kpiαip=p_1^{\\alpha_1}p_2^{\\alpha_2}p_3^{\\alpha_3}\\cdots p_k^{\\alpha_k}=\\prod_{i=1}^kp_i^{\\alpha_i} p=p1α1​​p2α2​​p3α3​​⋯pkαk​​=i=1∏k​piαi​​ 分别求出 {(nm) mod p1α1(nm) mod p2α2⋯(nm) mod pkαk\\left\\{ \\begin{aligned}\\\\ \\binom{n}{m}&amp;\\bmod p_1^{\\alpha_1}\\\\ \\binom{n}{m}&amp;\\bmod p_2^{\\alpha_2}\\\\ &amp;\\cdots\\\\ \\binom{n}{m}&amp;\\bmod p_k^{\\alpha_k} \\end{aligned} \\right. ⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​(mn​)(mn​)(mn​)​modp1α1​​modp2α2​​⋯modpkαk​​​ 然后根据中国剩余定理求解 现在考虑求 (nm) mod qr (q∈prime)\\binom{n}{m}\\bmod q^r\\ (q\\in \\text{prime}) (mn​)modqr (q∈prime) 考虑到 (nm)≡n!m!(n−m)!≡n!qxm!qy⋅(n−m)!qz⋅qx−y−z(modqr), (q∈prime)\\binom{n}{m}\\equiv\\frac{n!}{m!(n-m)!}\\equiv\\frac{\\frac{n!}{q^x}}{\\frac{m!}{q^y}\\cdot\\frac{(n-m)!}{q^z}}\\cdot q^{x-y-z} \\pmod{q^r},\\ (q\\in \\text{prime}) (mn​)≡m!(n−m)!n!​≡qym!​⋅qz(n−m)!​qxn!​​⋅qx−y−z(modqr), (q∈prime) 若 xxx 取满足 qx∣n!q^x|n!qx∣n! 的最大非负整数（y,zy,zy,z 同理），那么我们就可以用逆元求解了 设 g(t)=xmax⁡ (qx∣t!), f(t)=t!qg(t) mod qrg(t)=x_{\\max}\\,(q^x|t!),\\ f(t)=\\frac{t!}{q^{g(t)}}\\bmod q^r g(t)=xmax​(qx∣t!), f(t)=qg(t)t!​modqr 则 g(t)=⌊tq⌋+g(⌊tq⌋)f(t)=f(⌊tq⌋)⋅(∏i=1, i≡0(modq)qri)⌊tqr⌋⋅(∏i=qr⌊tqr⌋+1, i≡0(modq)ti) mod qr\\begin{aligned}\\\\ g(t)&amp;=\\left\\lfloor\\frac{t}{q}\\right\\rfloor+g\\left(\\left\\lfloor\\frac{t}{q}\\right\\rfloor\\right)\\\\ f(t)&amp;=f\\left(\\left\\lfloor\\frac{t}{q}\\right\\rfloor\\right)\\cdot \\left(\\prod_{i=1,\\,i\\not\\equiv0\\pmod q}^{q^r}i\\right)^{\\left\\lfloor\\frac{t}{q^r}\\right\\rfloor} \\cdot\\left(\\prod_{i=q^r\\left\\lfloor\\frac{t}{q^r}\\right\\rfloor+1,\\,i\\not\\equiv0\\pmod q}^{t}i\\right) \\bmod{q^r} \\end{aligned} g(t)f(t)​=⌊qt​⌋+g(⌊qt​⌋)=f(⌊qt​⌋)⋅⎝⎛​i=1,i​≡0(modq)∏qr​i⎠⎞​⌊qrt​⌋⋅⎝⎜⎛​i=qr⌊qrt​⌋+1,i​≡0(modq)∏t​i⎠⎟⎞​modqr​ 这个东西严格证明过程比较繁琐，感性理解一下就好 举两个例子 当 q=3, r=5q=3,\\,r=5q=3,r=5 则 g(9)=⌊93⌋+g(⌊93⌋)=3+g(3)=3+1=4f(9)=f(⌊93⌋)⋅(∏i=1, i≡0(mod3)35i)⌊935⌋⋅(∏i=35⌊935⌋+1, i≡0(mod3)9i) mod 35=f(3)×1×(1×2×4×5×7×8) mod 243=2×1×2240 mod 243=4480 mod 243=34\\begin{aligned}\\\\ g(9)&amp;=\\left\\lfloor\\frac{9}{3}\\right\\rfloor+g\\left(\\left\\lfloor\\frac{9}{3}\\right\\rfloor\\right)=3+g(3)=3+1=4\\\\ f(9)&amp;=f\\left(\\left\\lfloor\\frac{9}{3}\\right\\rfloor\\right)\\cdot \\left(\\prod_{i=1,\\,i\\not\\equiv0\\pmod 3}^{3^5}i\\right)^{\\left\\lfloor\\frac{9}{3^5}\\right\\rfloor} \\cdot\\left(\\prod_{i=3^5\\left\\lfloor\\frac{9}{3^5}\\right\\rfloor+1,\\,i\\not\\equiv0\\pmod 3}^{9}i\\right) \\bmod{3^5}\\\\ &amp;=f(3)\\times1\\times(1\\times2\\times4\\times5\\times7\\times8) \\bmod{243}\\\\ &amp;=2\\times1\\times2240\\bmod{243}\\\\ &amp;=4480\\bmod{243}\\\\ &amp;=34 \\end{aligned} g(9)f(9)​=⌊39​⌋+g(⌊39​⌋)=3+g(3)=3+1=4=f(⌊39​⌋)⋅⎝⎛​i=1,i​≡0(mod3)∏35​i⎠⎞​⌊359​⌋⋅⎝⎜⎛​i=35⌊359​⌋+1,i​≡0(mod3)∏9​i⎠⎟⎞​mod35=f(3)×1×(1×2×4×5×7×8)mod243=2×1×2240mod243=4480mod243=34​ 当 q=2, r=3q=2,\\,r=3q=2,r=3 则 g(15)=⌊152⌋+g(⌊152⌋)=7+g(7)=7+4=11f(15)=f(⌊152⌋)⋅(∏i=1, i≡0(mod2)23i)⌊1523⌋⋅(∏i=23⌊1523⌋+1, i≡0(mod2)15i) mod 23=f(7)×(1×3×5×7)1×(9×11×13×15) mod 8=3×105×19305 mod 8=6081075 mod 8=3\\begin{aligned}\\\\ g(15)&amp;=\\left\\lfloor\\frac{15}{2}\\right\\rfloor+g\\left(\\left\\lfloor\\frac{15}{2}\\right\\rfloor\\right)=7+g(7)=7+4=11\\\\ f(15)&amp;=f\\left(\\left\\lfloor\\frac{15}{2}\\right\\rfloor\\right)\\cdot \\left(\\prod_{i=1,\\,i\\not\\equiv0\\pmod 2}^{2^3}i\\right)^{\\left\\lfloor\\frac{15}{2^3}\\right\\rfloor} \\cdot\\left(\\prod_{i=2^3\\left\\lfloor\\frac{15}{2^3}\\right\\rfloor+1,\\,i\\not\\equiv0\\pmod 2}^{15}i\\right) \\bmod{2^3}\\\\ &amp;=f(7)\\times(1\\times3\\times5\\times7)^1\\times(9\\times11\\times13\\times15) \\bmod{8}\\\\ &amp;=3\\times105\\times19305\\bmod{8}\\\\ &amp;=6081075\\bmod{8}\\\\ &amp;=3 \\end{aligned} g(15)f(15)​=⌊215​⌋+g(⌊215​⌋)=7+g(7)=7+4=11=f(⌊215​⌋)⋅⎝⎛​i=1,i​≡0(mod2)∏23​i⎠⎞​⌊2315​⌋⋅⎝⎜⎛​i=23⌊2315​⌋+1,i​≡0(mod2)∏15​i⎠⎟⎞​mod23=f(7)×(1×3×5×7)1×(9×11×13×15)mod8=3×105×19305mod8=6081075mod8=3​ 很容易看出，上面的 ggg 函数求值的时间复杂度为 Θ(log⁡qt)\\Theta(\\log_qt)Θ(logq​t)，fff 则为 O(qrlog⁡qt)\\text{O}(q^r\\log_qt)O(qrlogq​t) 所以，我们得到 (nm)≡n!qxm!qy⋅(n−m)!qz⋅qx−y−z≡f(n)f(m)⋅f(n−m)⋅qg(n)−g(m)−g(n−m)(modqr), (q∈prime)\\binom{n}{m}\\equiv\\frac{\\frac{n!}{q^x}}{\\frac{m!}{q^y}\\cdot\\frac{(n-m)!}{q^z}}\\cdot q^{x-y-z}\\equiv\\frac{f(n)}{f(m)\\cdot f(n-m)}\\cdot q^{g(n)-g(m)-g(n-m)} \\pmod{q^r},\\ (q\\in \\text{prime}) (mn​)≡qym!​⋅qz(n−m)!​qxn!​​⋅qx−y−z≡f(m)⋅f(n−m)f(n)​⋅qg(n)−g(m)−g(n−m)(modqr), (q∈prime) 综上方法即为 exLucas 的全过程 exLucas Code Empty! ","link":"https://imzzy1201.github.io/post/C4R_6YYKI/"},{"title":"笔记 - Catalan 数","content":" To live is to risk it at all. Catalan 数是个奇奇怪怪的数列，它十分常见，好多东西的结论都跟它相关。 形式 我们现在用 CiC_iCi​ 代表 Catalan 数列的第 iii 项，有如下定义： 递归定义 Cn=∑i=1nCi−1Cn−iC_n=\\sum_{i=1}^n C_{i-1}C_{n-i} Cn​=i=1∑n​Ci−1​Cn−i​ 递推关系 Cn=4n−2n+1Cn−1C_n=\\frac{4n-2}{n+1}C_{n-1} Cn​=n+14n−2​Cn−1​ 通向公式 Cn=1n+1(2nn)=(2nn)−(2nn+1)C_n=\\frac{1}{n+1}\\binom{2n}{n}=\\binom{2n}{n}-\\binom{2n}{n+1} Cn​=n+11​(n2n​)=(n2n​)−(n+12n​) 其前几项为： 1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190,⋯1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, \\cdots 1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190,⋯ 证明 下面给出上述几个定义等价的证明： 1. 通项公式 (2nn)−(2nn+1)=(2n)!(n!)2−(2n)!(n−1)!(n+1)!=(n+1)(2n)!−n(2n)!n!(n+1)!=(2n)!n!(n+1)!=1n+1(2nn)\\begin{aligned} \\binom{2n}{n}-\\binom{2n}{n+1}=&amp;\\frac{(2n)!}{(n!)^2}-\\frac{(2n)!}{(n-1)!(n+1)!}\\\\ =&amp;\\frac{(n+1)(2n)!-n(2n)!}{n!(n+1)!}=\\frac{(2n)!}{n!(n+1)!}\\\\ =&amp;\\frac{1}{n+1}\\binom{2n}{n} \\end{aligned} (n2n​)−(n+12n​)===​(n!)2(2n)!​−(n−1)!(n+1)!(2n)!​n!(n+1)!(n+1)(2n)!−n(2n)!​=n!(n+1)!(2n)!​n+11​(n2n​)​ 2. 通项公式与递推关系 Cn=1n+1(2nn)=(2n)!n!(n+1)!=(2n)(2n−1)(n)(n+1)⋅(2n−2)!(n−1)!n!=4n−2n+1Cn−1C_n=\\frac{1}{n+1}\\binom{2n}{n}=\\frac{(2n)!}{n!(n+1)!}=\\frac{(2n)(2n-1)}{(n)(n+1)}\\cdot\\frac{(2n-2)!}{(n-1)!n!}=\\frac{4n-2}{n+1}C_{n-1} Cn​=n+11​(n2n​)=n!(n+1)!(2n)!​=(n)(n+1)(2n)(2n−1)​⋅(n−1)!n!(2n−2)!​=n+14n−2​Cn−1​ 3. 通项公式与递归定义 下面证明充分条件（必要条件证法类似）： C0=1,Cn+1=∑i=0nCiCn−i⇒Cn=1n+1(2nn)C_0=1,C_{n+1}=\\sum_{i=0}^nC_iC_{n-i}\\Rightarrow C_n=\\frac{1}{n+1}\\binom{2n}{n} C0​=1,Cn+1​=i=0∑n​Ci​Cn−i​⇒Cn​=n+11​(n2n​) 证明： 令 xxx 为充分小的正实数，设数列 {Cn}\\{C_n\\}{Cn​} 的母函数 G(x)=∑i=0∞xiCiG(x)=\\sum_{i=0}^\\infin x^iC_i G(x)=i=0∑∞​xiCi​ 则有 G2(x)=(∑i=0∞xiCi)2=∑i=0nxiCi∑j=0∞xjCj=∑i=0∞∑j=0∞xi+jCiCj=∑i=0∞∑k=i∞xkCiCk−i=∑k=0∞xk∑i=0kCiCk−i=∑k=0∞xkCk+1G2(x)x=x∑k=0∞xkCk+1=∑k=0∞xk+1Ck+1=∑k=1∞xkCkG2(x)x+1=∑k=1∞xkCk+1=∑k=1∞xkCk+x0C0=∑k=0∞xkCk=G(x)\\begin{aligned} G^2(x)&amp;=\\left(\\sum_{i=0}^\\infin x^iC_i\\right)^2=\\sum_{i=0}^n x^iC_i\\sum_{j=0}^\\infin x^jC_j=\\sum_{i=0}^\\infin\\sum_{j=0}^\\infin x^{i+j}C_iC_j\\\\ &amp;=\\sum_{i=0}^\\infin\\sum_{k=i}^\\infin x^kC_iC_{k-i}=\\sum_{k=0}^\\infin x^k\\sum_{i=0}^kC_iC_{k-i}\\\\ &amp;=\\sum_{k=0}^\\infin x^kC_{k+1}\\\\ G^2(x)x&amp;=x\\sum_{k=0}^\\infin x^kC_{k+1}=\\sum_{k=0}^\\infin x^{k+1}C_{k+1}=\\sum_{k=1}^\\infin x^kC_k\\\\ G^2(x)x+1&amp;=\\sum_{k=1}^\\infin x^kC_k+1=\\sum_{k=1}^\\infin x^kC_k+x^0C_0=\\sum_{k=0}^\\infin x^kC_k=G(x) \\end{aligned} G2(x)G2(x)xG2(x)x+1​=(i=0∑∞​xiCi​)2=i=0∑n​xiCi​j=0∑∞​xjCj​=i=0∑∞​j=0∑∞​xi+jCi​Cj​=i=0∑∞​k=i∑∞​xkCi​Ck−i​=k=0∑∞​xki=0∑k​Ci​Ck−i​=k=0∑∞​xkCk+1​=xk=0∑∞​xkCk+1​=k=0∑∞​xk+1Ck+1​=k=1∑∞​xkCk​=k=1∑∞​xkCk​+1=k=1∑∞​xkCk​+x0C0​=k=0∑∞​xkCk​=G(x)​ 则 G(x)=G2(x)x+1G(x)=G^2(x)x+1\\\\ G(x)=G2(x)x+1 解得 G(x)=1±1−4x2xG(x)=\\frac{1\\pm\\sqrt{1-4x}}{2x} G(x)=2x1±1−4x​​ 那么现在我们讨论 G1(x)=1−1−4x2xG_1(x)=\\dfrac{1-\\sqrt{1-4x}}{2x}G1​(x)=2x1−1−4x​​ 和 G2(x)=1+1−4x2xG_2(x)=\\dfrac{1+\\sqrt{1-4x}}{2x}G2​(x)=2x1+1−4x​​： #1. G(x)=1−1−4x2xG(x)=\\dfrac{1-\\sqrt{1-4x}}{2x}G(x)=2x1−1−4x​​ 引入广义二项式定理 (1+x)α=∑k=0∞(αk)xk(1+x)^\\alpha=\\sum_{k=0}^\\infin\\binom{\\alpha}{k}x^k (1+x)α=k=0∑∞​(kα​)xk 其中 (αk)=∏i=1kα−i+1i\\binom{\\alpha}{k}=\\prod_{i=1}^k\\frac{\\alpha-i+1}{i}\\\\ (kα​)=i=1∏k​iα−i+1​ 则 G(x)=1−∑k=0∞(12k)(−4x)k2x=1−1−∑k=1∞(12k)(−4x)k2x=−12∑k=1∞(12k)(−4)kxk−1=−12∑k=0∞(12k+1)(−4)k+1xk=2∑k=0∞(12k+1)(−4x)kCn=2(12n+1)(−4)n=2∏i=1n+112−i−1i(−4)n=2∏i=0n(12−i)(n+1)!(−1)n22n=∏i=0n(1−2i)(n+1)!(−1)n2n=∏i=1n(−1)(1−2i)(n+1)!2n=∏i=1n(2i−1)(n+1)!2n=(2n−1)!!(n+1)!2n\\begin{aligned} G(x)&amp;=\\frac{1-\\sum_{k=0}^\\infin\\binom{\\frac12}{k}(-4x)^k}{2x}=\\frac{1-1-\\sum_{k=1}^\\infin\\binom{\\frac12}{k}(-4x)^k}{2x}\\\\ &amp;=-\\frac{1}{2}\\sum_{k=1}^\\infin\\binom{\\frac12}{k}(-4)^kx^{k-1}=-\\frac{1}{2}\\sum_{k=0}^\\infin\\binom{\\frac12}{k+1}(-4)^{k+1}x^k\\\\ &amp;=2\\sum_{k=0}^\\infin\\binom{\\frac12}{k+1}(-4x)^k\\\\ C_n&amp;=2\\binom{\\frac12}{n+1}(-4)^n=2\\prod_{i=1}^{n+1}\\frac{\\frac12-i-1}{i}(-4)^n=2\\frac{\\prod_{i=0}^{n}(\\frac{1}{2}-i)}{(n+1)!}(-1)^n2^{2n}\\\\ &amp;=\\frac{\\prod_{i=0}^{n}(1-2i)}{(n+1)!}(-1)^n2^n=\\frac{\\prod_{i=1}^{n}(-1)(1-2i)}{(n+1)!}2^n=\\frac{\\prod_{i=1}^{n}(2i-1)}{(n+1)!}2^n\\\\ &amp;=\\frac{(2n-1)!!}{(n+1)!}2^n \\end{aligned}\\\\ G(x)Cn​​=2x1−∑k=0∞​(k21​​)(−4x)k​=2x1−1−∑k=1∞​(k21​​)(−4x)k​=−21​k=1∑∞​(k21​​)(−4)kxk−1=−21​k=0∑∞​(k+121​​)(−4)k+1xk=2k=0∑∞​(k+121​​)(−4x)k=2(n+121​​)(−4)n=2i=1∏n+1​i21​−i−1​(−4)n=2(n+1)!∏i=0n​(21​−i)​(−1)n22n=(n+1)!∏i=0n​(1−2i)​(−1)n2n=(n+1)!∏i=1n​(−1)(1−2i)​2n=(n+1)!∏i=1n​(2i−1)​2n=(n+1)!(2n−1)!!​2n​ 又 (2n)!=(2n)!!×(2n−1)!!=(2n−1)!!×2nn!(2n)!=(2n)!!\\times(2n-1)!!=(2n-1)!!\\times2^nn! (2n)!=(2n)!!×(2n−1)!!=(2n−1)!!×2nn! 所以 Cn=(2n−1)!!2n(n+1)!=(2n)!n!(n+1)!=1n+1(2n)!(n!)2=1n+1(2nn)\\begin{aligned} C_n&amp;=\\frac{(2n-1)!!2^n}{(n+1)!}=\\frac{(2n)!}{n!(n+1)!}=\\frac{1}{n+1}\\frac{(2n)!}{(n!)^2}=\\frac{1}{n+1}\\binom{2n}{n} \\end{aligned}\\\\ Cn​​=(n+1)!(2n−1)!!2n​=n!(n+1)!(2n)!​=n+11​(n!)2(2n)!​=n+11​(n2n​)​ #2. G(x)=1−1−4x2xG(x)=\\dfrac{1-\\sqrt{1-4x}}{2x}G(x)=2x1−1−4x​​ 同 #1 可得 G(x)=1+∑k=0∞(12k)(−4x)k2x=1x−2∑k=0∞(12k+1)(−4x)kG(x)=\\frac{1+\\sum_{k=0}^\\infin\\binom{\\frac12}{k}(-4x)^k}{2x}=\\frac{1}{x}-2\\sum_{k=0}^\\infin\\binom{\\frac12}{k+1}(-4x)^k G(x)=2x1+∑k=0∞​(k21​​)(−4x)k​=x1​−2k=0∑∞​(k+121​​)(−4x)k 然而，很明显母函数 G(x)G(x)G(x) 没有 x−1x^{-1}x−1 项，所以此情况不成立（舍） 综上，#1 得到 Cn=1n+1(2nn)C_n=\\dfrac{1}{n+1}\\dbinom{2n}{n}Cn​=n+11​(n2n​)，#2 舍去，即命题成立 证毕. 参考文献：Catalan numbers Code 一行 inline ll catalan(int n) {return (C(2*n,n)+mod-C(2*n,n+1))%mod;} 应用 其实许多其应用都能很清晰得说明 通项公式与递归定义 之间的等价关系，下面在 #1 举个例，往后类似 1. 括号匹配问题 nnn 对括号能组成多少个合法括号串？ 合法括号串的定义： 空串是合法括号串 若 AAA 是合法括号串，那么 (A)(A)(A) 也是合法括号串，称这里的左右两括号匹配 若 A,BA,BA,B 均为合法括号串，那么 ABABAB 也是合法括号串 其余串均不为合法括号串 n=3n=3n=3 时的所有合法括号串如下： 1.((())) 2.(()()) 3.(())() 4.()(()) 5.()()() 设答案为 F(n)F(n)F(n)，考虑下面两种方法说明 F(n)=CnF(n)=C_nF(n)=Cn​ #1. 递归定义法 采用第二数学归纳法证明： 当 n=0n=0n=0 时，F(n)=Cn=1F(n)=C_n=1F(n)=Cn​=1，即命题成立 假设当 n≤k (k∈N+)n\\le k\\ (k\\in N_+)n≤k (k∈N+​) 时，命题成立 下面证明 n=k+1n=k+1n=k+1 时命题成立： 考虑一个合法括号串 SSS，令 SiS_iSi​ 表示 SSS 的第 iii 项： 因为 k&gt;1k&gt;1k&gt;1，所以 SSS 不为空串 考虑 S1S_1S1​ 的值，因为所有合法括号串都不可能以 ) 开头，所以 S1=S_1=S1​= ( 枚举 S1S_1S1​ 的匹配括号，设 S1S_1S1​ 与 SiS_iSi​ 匹配，因为合法括号串必定有偶数个字符，所以我们设 i=2k+1i=2k+1i=2k+1，则 S1S_1S1​ 与 SiS_iSi​ 间的 2k2k2k 个字符必定构成合法括号串，而 SiS_iSi​ 往后的 2(n−k−1)2(n-k-1)2(n−k−1) 也必定构成合法括号串。即若 S1S_1S1​ 与 SiS_iSi​ 匹配，则共 F(k)F(n−k−1)=CkCn−k−1F(k)F(n-k-1)=C_kC_{n-k-1}F(k)F(n−k−1)=Ck​Cn−k−1​ 种构造方法 再考虑两个合法括号串 S1,S2S1,S2S1,S2，若 S11S1_1S11​ 的匹配括号为 S1iS1_iS1i​，S21S2_1S21​ 的匹配括号为 S2jS2_jS2j​，且 i≠ji\\neq ji​=j，易得 S1≠S2S1\\neq S2S1​=S2 因此，F(n)=∑k=0n−1CkCn−k−1=CnF(n)=\\sum\\limits_{k=0}^{n-1}C_kC_{n-k-1}=C_nF(n)=k=0∑n−1​Ck​Cn−k−1​=Cn​ 证毕. #2. 通项公式法 考虑用 111 表示左括号，−1-1−1 表示右括号，我们可以将问题归约为： 串 SSS 满足 ∀i≤2n,(∑k=1iSk)≥0\\forall i\\le2n,\\left(\\sum\\limits_{k=1}^i S_k\\right)\\ge0 ∀i≤2n,(k=1∑i​Sk​)≥0 考虑共 2n2n2n 个位置，我们选出其中 nnn 个位置放 111，剩下放 −1-1−1，即 (2nn)\\dbinom{2n}{n}(n2n​) 种放法 现在我们去掉不合法的情况（下面讨论的所有“不合法情况”默认串中有各 nnn 个 111 和 −1-1−1） 若其不合法，则必定存在最小的 ppp，使得 (∑k=1pSk)=−1\\left(\\sum\\limits_{k=1}^p S_k\\right)=-1 (k=1∑p​Sk​)=−1 即串 S1∼(p−1)S_{1\\sim (p-1)}S1∼(p−1)​ 合法，而 Sp=−1S_{p}=-1Sp​=−1 那么若我们将 S(p+1)∼2nS_{(p+1)\\sim 2n}S(p+1)∼2n​ 的所有数取负，得到一个新的生成串 S′S&#x27;S′，可以发现每个 S′S&#x27;S′ 中都含有 n+1n+1n+1 个 −1-1−1 和 n−1n-1n−1 个 111。 若我们枚举每个含有 n+1n+1n+1 个 −1-1−1 和 n−1n-1n−1 个 111 的生成串 S′S&#x27;S′，则可以得到一个神奇的结论：每个 S′S&#x27;S′ 必定对应唯一一个不合法的 SSS 考虑证明： 存在性 因为 S′S&#x27;S′ 有 n+1n+1n+1 个 −1-1−1 和 n−1n-1n−1 个 111，所以必定存在一个最小的 ppp，使得(∑k=1pSk′)=−1\\left(\\sum\\limits_{k=1}^p S&#x27;_k\\right)=-1 (k=1∑p​Sk′​)=−1 我们再对生成串 S(p+1)∼2n′S&#x27;_{(p+1)\\sim 2n}S(p+1)∼2n′​ 的所有数取负，则得到原串 SSS 刚好各 nnn 个 111 和 −1-1−1，且 SSS 必定是一个不合法串，因为(∑k=1pSk)=−1\\left(\\sum\\limits_{k=1}^p S_k\\right)=-1 (k=1∑p​Sk​)=−1 唯一性 因为每个原不合法串 SSS 生成其对应 S′S&#x27;S′ 串的方法唯一，所以不存在两个生成串对应同一个原串 至此，我们证明了每个含有 n+1n+1n+1 个 −1-1−1 和 n−1n-1n−1 个 111 的生成串 S′S&#x27;S′ 必定对应唯一一个不合法的 SSS 因为我们要在 2n2n2n 个位置中选 n+1n+1n+1 个位置放 −1-1−1，其余放 111，所以得到共 (2nn+1)\\dbinom{2n}{n+1}(n+12n​) 种生成串，即共 (2nn+1)\\dbinom{2n}{n+1}(n+12n​) 种不合法串 那么合法串的数量应等于总数量 −-− 不合法数量，即 F(n)=(2nn)−(2nn+1)=CnF(n)=\\binom{2n}{n}-\\binom{2n}{n+1}=C_n F(n)=(n2n​)−(n+12n​)=Cn​ 证毕. 2. 进出栈问题 一个无穷大的栈，进栈队列为 1,2,3,⋯ ,n1,2,3,\\cdots,n1,2,3,⋯,n，问有多少种不同的出栈序列 关于栈的定义可尝试 搜索引擎 这里我们归约为括号匹配问题： 每个括号串表示一条指令，( 表示队首元素入栈，) 表示栈顶元素出栈 可以发现，每个合法括号串都对应唯一一种进出栈策略，并且这个进出栈策略必定合法 唯一性很显然，合法性下面给出证明： 考虑不合法的情况无非 222 种，一种是所有元素进栈后还在发出“进栈”指令，另一种是栈中没有元素了还发出“出栈”指令 对于情况一，因为合法括号串只有 nnn 个 (，所以只进栈 nnn 次，不可能出现此情况 对于情况二，考虑到每个 ) 之前都与一个 ( 相匹配，即每次出栈指令都有一个进栈指令与其匹配，所以也不可能出现此情况 综上，我们将进出栈问题规约为了括号匹配问题 3. 二叉树种类问题 nnn 个无序节点构成的二叉树共多少种 我们设 nnn 个无序节点构成的二叉树共 F(n)F(n)F(n) 种，下面证明 F(n)=CnF(n)=C_nF(n)=Cn​ 再次考虑第二数学归纳法证明： 当 n=0n=0n=0 时，只有一种情况即空二叉树，所以 F(n)=Cn=1F(n)=C_n=1F(n)=Cn​=1，即命题成立 假设当 n≤k (k∈N+)n\\le k\\ (k\\in N_+)n≤k (k∈N+​) 时，命题成立 下面证明 n=k+1n=k+1n=k+1 时命题成立： 我们先按中序遍历的顺序给每个节点编号 考虑枚举树根为 1∼n1\\sim n1∼n 的情况，若树根为 iii，则 1∼(i−1)1\\sim (i-1)1∼(i−1) 这 i−1i-1i−1 个节点为 iii 的左子树，而 (i+1)∼n(i+1)\\sim n(i+1)∼n 这 n−in-in−i 个节点为 iii 的右子树，即以 iii 为根的二叉树共 F(i−1)F(n−i)=Ci−1Cn−iF(i-1)F(n-i)=C_{i-1}C_{n-i}F(i−1)F(n−i)=Ci−1​Cn−i​ 种情况 因此，我们得到F(n)=∑i=1nCi−1Cn−i=CnF(n)=\\sum_{i=1}^nC_{i-1}C_{n-i}=C_n F(n)=i=1∑n​Ci−1​Cn−i​=Cn​ 即命题成立 证毕. 附： 中序遍历（LDR）是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。如下图二叉树中序遍历顺序为 4 2 8 5 9 1 6 3 7 10 12345896710 4. 网格路径问题 对于一个 n×nn\\times nn×n 的正方形网格，每次我们能沿着网格向右或者向上移动一格，那么从左下角到右上角的所有在对角线下方的路径总数为多少？ 举个例子，下图列举了所有 n=4n=4n=4 时的情况： 继续考虑规约，我们将归约为进出栈问题，进栈为向右走，出栈为向上走，下面证明每种进出栈策略与网格路径一一对应： 唯一性也很显然，合法性下面给出证明： 考虑网格路径问题也可以理解为每一步走完后保证竖向路径个数小于等于横向路径个数（即在对角线下方），且走到右上角时竖向路径与横向路径均为 nnn 条（在网格上走） 而每种进出栈策略也满足每一步栈中元素个数大于等于 000，即进栈数大于等于出栈数；一共 nnn 个元素进出栈各 111 次，即进出栈数均为 nnn 所以我们发现进出栈策略的条件与网格路径的条件是一致的，所以每种进出栈策略对应的网格路径均合法 5. 凸多边形分割问题 求一个凸 nnn 边形区域划分成三角形区域的方法数 举个例子，下图列举了 n=6n=6n=6 时的所有方案： 设凸 n (n≥2)n\\ (n\\ge2)n (n≥2) 边形的划分方法共 F(n)F(n)F(n) 种，下面证明 F(n)=Cn−2F(n)=C_{n-2}F(n)=Cn−2​ 同样考虑第二数学归纳法证明： 当 n=2n=2n=2 时，不存在这样的凸 nnn 边形，所以有唯一一种情况就是不分，F(n)=Cn−2=1F(n)=C_{n-2}=1F(n)=Cn−2​=1，即命题成立 假设当 n≤k (k&gt;2)n\\le k\\ (k&gt;2)n≤k (k&gt;2) 时，命题成立 下面证明 n=k+1n=k+1n=k+1 时命题成立： 我们先顺时针给这个凸 nnn 边形的顶点编号 选取一条边 1−21-21−2，显然这条边必定在唯一一个三角形中（也很明显，若两种方案中 1−21-21−2 所在的三角形不同则两方案也不同，即枚举其所在三角形可以保证不重复不遗漏） 这个三角形的其中两个顶点就是 111 和 222，所以我们枚举第三个顶点 设第三个顶点为 iii，则我们发现如果把这个三角形切掉之后会剩下两个凸多边形，一个为 i−1i-1i−1 边形（顶点分别为 2,3,⋯ ,i2,3,\\cdots,i2,3,⋯,i），另一个为 n−i+2n-i+2n−i+2 边形（顶点分别为 i,i+1,⋯ ,n,1i,i+1,\\cdots,n,1i,i+1,⋯,n,1） 所以可得F(n)=∑i=3nF(i−1)F(n−i+2)=∑i=3nCi−3Cn−i=∑i=0n−3CiC(n−3)−i=Cn−2F(n)=\\sum_{i=3}^nF(i-1)F(n-i+2)=\\sum_{i=3}^nC_{i-3}C_{n-i}=\\sum_{i=0}^{n-3}C_iC_{(n-3)-i}=C_{n-2} F(n)=i=3∑n​F(i−1)F(n−i+2)=i=3∑n​Ci−3​Cn−i​=i=0∑n−3​Ci​C(n−3)−i​=Cn−2​ 证毕. 附图： 6. 连线不相交问题 在圆上选择 2n2n2n 个点，这些点两两连接使得所得到的 nnn 条线段不相交，求方案数 举个例子，下图列举了 n=4n=4n=4 的所有方案： 设圆上 2n2n2n 个点两两连线不相交方案数为 F(n)F(n)F(n)，下面证明 F(n)=CnF(n)=C_nF(n)=Cn​ 依然是第二数学归纳法： 当 n=0n=0n=0 时，圆上没有点，所以有唯一一种情况就是不连线，即 F(n)=Cn=1F(n)=C_n=1F(n)=Cn​=1，命题成立 假设当 n≤k (k∈N+)n\\le k\\ (k\\in N_+)n≤k (k∈N+​) 时，命题成立 下面证明 n=k+1n=k+1n=k+1 时命题成立： 我们先顺时针给这 nnn 个点编号，我们讨论与 111 相连的点 iii 首先 iii 必定为偶数。因为 iii 若为奇数，则 111 至 iii 有奇数个点，这些点的连线不能跨越 1−i1-i1−i 这条线，而奇数个点又是不可能两两连接的，所以不成立 那么设 i=2j+1i=2j+1i=2j+1，则 1−i1-i1−i 的左边有 2j2j2j 个点，右边有 2(n−j−1)2(n-j-1)2(n−j−1) 个点，即共 F(j)F(2(n−j−1)F(j)F(2(n-j-1)F(j)F(2(n−j−1) 种方案 所以有F(n)=∑j=0n−1F(j)F(n−j−1)=∑j=0n−1CjCn−j−1=CnF(n)=\\sum_{j=0}^{n-1}F(j)F(n-j-1)=\\sum_{j=0}^{n-1}C_jC_{n-j-1}=C_n F(n)=j=0∑n−1​F(j)F(n−j−1)=j=0∑n−1​Cj​Cn−j−1​=Cn​ 证毕. 附图： 7. 阶梯切割问题 求 nnn 个矩形填充一个高度为 nnn 的阶梯状图形的方案数 举个例子，下图列举了 n=4n=4n=4 的所有方案 设 nnn 阶阶梯共 F(n)F(n)F(n) 种方案，下面证明 F(n)=CnF(n)=C_nF(n)=Cn​ 第 二 数 学 归 纳 法 当 n=0n=0n=0 时，没有阶梯，所以有唯一一种情况就是不填矩形，即 F(n)=Cn=1F(n)=C_n=1F(n)=Cn​=1，命题成立 假设当 n≤k (k∈N+)n\\le k\\ (k\\in N_+)n≤k (k∈N+​) 时，命题成立 下面证明 n=k+1n=k+1n=k+1 时命题成立： 考虑如下图中灰色的 nnn 个阶梯顶端的格子 它们一定互不在一个矩形内，因为这之中任意两个如果在一个矩形内那那个矩形必定从阶梯的右上方超出阶梯 我们再枚举阶梯左下角的格子（如图中绿格）所在的矩形。若它包含从上往下数第 iii 个灰格子，那么它上面就隔离出了一个 i−1i-1i−1 阶的阶梯，右边隔离出了一个 n−in-in−i 阶的阶梯，即共 F(i−1)F(n−i)F(i-1)F(n-i)F(i−1)F(n−i) 种方案 所以有F(n)=∑i=1nF(i−1)F(n−i)=∑i=1nCi−1Cn−i=CnF(n)=\\sum_{i=1}^nF(i-1)F(n-i)=\\sum_{i=1}^nC_{i-1}C_{n-i}=C_n F(n)=i=1∑n​F(i−1)F(n−i)=i=1∑n​Ci−1​Cn−i​=Cn​ 证毕. 8. 格子填数问题 在一个 2×n2\\times n2×n 的格子中填入 111 到 2n2n2n 这些数，求使得每个格子内的数值都比其左上方的所有数值小的情况数 举个例子，下表列举了所有 n=4n=4n=4 的情况 1 2 3 4 1 2 3 5 1 2 3 6 1 2 3 7 1 2 4 5 1 2 4 6 1 2 4 7 5 6 7 8 4 6 7 8 4 5 7 8 4 5 6 8 3 6 7 8 3 5 7 8 3 5 6 8 1 2 5 6 1 2 5 7 1 3 4 5 1 3 4 6 1 3 4 7 1 3 5 6 1 3 5 7 3 4 7 8 3 4 6 8 2 6 7 8 2 5 7 8 2 5 6 8 2 4 7 8 2 4 6 8 考虑规约至括号匹配问题，我们枚举每个长度为 2n2n2n 的合法括号串 SSS，其对应的填数方案：若 SiS_iSi​ 为 ( 则 iii 格子放第一行，为 ) 则放第二行（因为格子里的每行都是有序的，所以我们顺着放就好） 比如串 ()(()()) 对应的填数方案为： 1 3 4 6 2 5 7 8 我们证明合法括号串和填数策略可如上一一对应： 唯一性亦很容易证明，我们主要看合法性的证明 首先，可以肯定此合法括号串有各 nnn 个 ( 和 )，即其对应的填数策略填满了两行 然后我们发现对于每个位置 k≤2nk\\le2nk≤2n 合法括号串必然满足 ∑i=1k[Si=( ] ≥ ∑i=1k[Si=) ]\\sum_{i=1}^k[S_i=\\texttt{\\color{brown}(}\\ ]\\ \\ge\\ \\sum_{i=1}^k[S_i=\\texttt{\\color{brown})}\\ ] i=1∑k​[Si​=( ] ≥ i=1∑k​[Si​=) ] 即前 kkk 个字符中 ( 的个数大于等于 ) 的个数，放在格子填数的方案里对应的就是小于等于 kkk 的数至少一半在第一行 所以对于每一个在第二行数都有至少一半小于等于它的数在第一行所以它的左上方的所有数都比它小，满足其要求 综上，我们已将格子填数问题规约至括号匹配问题 证毕. ","link":"https://imzzy1201.github.io/post/QhLY5-IRd/"},{"title":"杂题 - BZOJ2839 集合计数","content":" S={x:x∉x}S=\\{x:x\\notin x\\}S={x:x∈/​x} 🤔 题面（黑暗爆炸OJ） 前置知识 集合相关内容 二项式反演 思路 考虑转换为计算“钦定”的值：先求 fif_ifi​ 表示钦定交集有 iii 个元素，即选出的子集的交集包含选定 iii 个元素的方案数。 首先，nnn 个元素中选出 iii 个元素，即有 CniC_n^iCni​ 种选法。然后，我们固定每个选取的子集都包含这 iii 个元素，剩下的可选可不选。对于其中一个子集，因为剩下共 n−in-in−i 个元素，每个元素都可以选或不选，所以共 2n−i2^{n-i}2n−i 种子集可供选择。而这 2n−i2^{n-i}2n−i 种子集中每个子集又都可以选取或不选取，所以共 22n−12^{2^{n-1}}22n−1 种选取方案，排除什么都不选的一种情况，即共 22n−1−12^{2^{n-1}}-122n−1−1 种情况。 至此，我们得到： fi=(ni)(22n−1−1)f_i=\\dbinom{n}{i}\\left(2^{2^{n-1}}-1\\right) fi​=(in​)(22n−1−1) 再回头来，若定义 gig_igi​ 为交集元素刚好 iii 个的取法，即题目所求，因为每种交集元素个数为 jjj 的方案都被重复计算 CjiC_j^iCji​ 次，所以： fi=∑j=in(ji)gjf_i=\\sum\\limits_{j=i}^n\\dbinom{j}{i}g_j fi​=j=i∑n​(ij​)gj​ 套用二项式反演的公式，得到： gk=∑i=kn(−1)i−k(ik)fi=∑i=kn(−1)i−k(ik)(ni)(22n−i−1)\\begin{aligned}\\\\ g_k&amp;=\\sum\\limits_{i=k}^n(-1)^{i-k}\\dbinom{i}{k}f_i\\\\ &amp;=\\sum\\limits_{i=k}^n(-1)^{i-k}\\dbinom{i}{k}\\dbinom{n}{i}\\left(2^{2^{n-i}}-1\\right) \\end{aligned} gk​​=i=k∑n​(−1)i−k(ki​)fi​=i=k∑n​(−1)i−k(ki​)(in​)(22n−i−1)​ 注意：这里的 22n−i2^{2^{n-i}}22n−i 不建议快速幂，可以倒序递推：22x+1=(22x)22^{2^{x+1}}=(2^{2^x})^222x+1=(22x)2 Code #include&lt;bits/stdc++.h&gt; #define ll long long #define rgi register int #define rgl register ll #define mian main struct fastin{ int _ch,_f; inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; struct fastout{ #define endl '\\n' int _num[32],_head; inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=1000004,maxm=1000004; const int mod=1000000007,inf=1000000007; const int debug=0; inline ll powmod(ll a,ll b) { ll res=1; while(b) { if(b&amp;1) (res*=a)%=mod; (a*=a)%=mod,b&gt;&gt;=1; } return res; } inline ll inv(ll a) {return powmod(a,mod-2);} ll fact[maxn],invfact[maxn]; inline void init() { fact[0]=invfact[0]=1; for(rgi i=1;i&lt;maxn;++i) fact[i]=fact[i-1]*i%mod,invfact[i]=inv(fact[i]); } inline ll C(ll n,ll m) {return fact[n]*invfact[m]%mod*invfact[n-m]%mod;} signed main() { int n,k; fin&gt;&gt;n&gt;&gt;k; ll ans=0,tmp=2; init(); for(rgi i=n;i&gt;=k;--i) ans+=((i-k)&amp;1?(mod-1LL):1LL)*C(i,k)%mod*C(n,i)%mod*(tmp-1)%mod, (tmp*=tmp)%=mod,ans%=mod; fout&lt;&lt;ans; return 0; } // ---------------------------- // by imzzy ","link":"https://imzzy1201.github.io/post/qUuCFD8g0/"},{"title":"笔记 - 二项式反演","content":" You aren't fully capable of deciding your own destiny. 二项式反演，即式项二 算是反演系列知识点中最简单最好背的之一 码量小，证明简单，还很好理解 形式 先给出来式子： 从 000 到 nnn ： ①fn=∑i=0n(−1)i(ni)gi⇔gn=∑i=0n(−1)i(ni)fi\\tag*{①} \\large \\begin{aligned}\\\\ f_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_i\\\\ \\end{aligned} fn​=i=0∑n​(−1)i(in​)gi​​⇔gn​=i=0∑n​(−1)i(in​)fi​​① ②亦作 fn=∑i=0n(ni)gi⇔gn=∑i=0n(−1)n−i(ni)fi\\tag*{②} \\normalsize\\textsf{亦作}\\ \\large \\begin{aligned}\\\\ f_n=\\sum\\limits_{i=0}^n\\dbinom{n}{i}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=0}^n (-1)^{n-i} \\dbinom{n}{i} f_i\\\\ \\end{aligned} 亦作 fn​=i=0∑n​(in​)gi​​⇔gn​=i=0∑n​(−1)n−i(in​)fi​​② 从 nnn 到 mmm ： ③fn=∑i=nm(−1)i(in)gi⇔gn=∑i=nm(−1)i(in)fi\\tag*{③} \\large \\begin{aligned}\\\\ f_n=\\sum\\limits_{i=n}^m(-1)^i\\dbinom{i}{n}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=n}^m(-1)^i\\dbinom{i}{n}f_i \\\\ \\end{aligned} fn​=i=n∑m​(−1)i(ni​)gi​​⇔gn​=i=n∑m​(−1)i(ni​)fi​​③ ④亦作 fn=∑i=nm(in)gi⇔gn=∑i=nm(−1)i−n(in)fi\\tag*{④} \\normalsize\\textsf{亦作}\\ \\large \\begin{aligned}\\\\ f_n=\\sum\\limits_{i=n}^m\\dbinom{i}{n}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=n}^m (-1)^{i-n} \\dbinom{i}{n} f_i \\\\ \\end{aligned} 亦作 fn​=i=n∑m​(ni​)gi​​⇔gn​=i=n∑m​(−1)i−n(ni​)fi​​④ 这些式子看起来又对称又妙，妙得都看不出来有啥用 好吧其实还是很有用的，具体用法参见例题 证明 现在先说它的证明 方法 1 把它想象成一个特殊的容斥 这里引用一下 GXZlegend 的博客 中的证明（稍有修改）： 既然形式和多步容斥相似，我们就从多步容斥讲起 我们都知道：∣A∪B∣=∣A∣+∣B∣−∣A∩B∣|A\\cup B|=|A|+|B|−|A\\cap B|∣A∪B∣=∣A∣+∣B∣−∣A∩B∣ ，这其实就是容斥原理 记用来容斥的 mmm 个集合为 A1,A2⋯AmA_1,A_2\\cdots A_mA1​,A2​⋯Am​ 中它的一般形式为： ∣A1∪A2∪⋯∪Am∣=∑1≤i≤m∣Ai∣−∑1≤i&lt;j≤m∣Ai∩Aj∣+∑1≤i&lt;j&lt;k≤m∣Ai∩Aj∩Ak∣−⋯+(−1)n−1×∣A1∩A2∩⋯∩Am∣|A_1\\cup A_2\\cup \\cdots \\cup A_m|=\\sum\\limits_{1\\le i\\le m} |A_i|−\\sum\\limits_{1\\le i&lt;j\\le m} |A_i\\cap A_j|+\\sum\\limits_{1\\le i&lt;j&lt;k\\le m} |A_i\\cap A_j\\cap A_k|-\\cdots+(−1)^{n−1}\\times |A_1\\cap A_2\\cap \\cdots \\cap A_m| ∣A1​∪A2​∪⋯∪Am​∣=1≤i≤m∑​∣Ai​∣−1≤i&lt;j≤m∑​∣Ai​∩Aj​∣+1≤i&lt;j&lt;k≤m∑​∣Ai​∩Aj​∩Ak​∣−⋯+(−1)n−1×∣A1​∩A2​∩⋯∩Am​∣ 或作 ∣⋃i=1mAi∣=∑k=1m(−1)k−1∑1≤i1&lt;i2&lt;⋯&lt;ik≤m∣Ai1∩Ai2∩⋯∩Aik∣\\left|\\bigcup\\limits_{i=1}^m A_i\\right|=\\sum\\limits_{k=1}^m (-1)^{k-1} \\sum\\limits_{1\\le i_1&lt;i_2&lt;\\cdots&lt;i_k\\le m}|A_{i_1}\\cap A_{i_2}\\cap\\cdots\\cap A_{i_k}| ∣∣∣∣∣​i=1⋃m​Ai​∣∣∣∣∣​=k=1∑m​(−1)k−11≤i1​&lt;i2​&lt;⋯&lt;ik​≤m∑​∣Ai1​​∩Ai2​​∩⋯∩Aik​​∣ 证明： 设某一元素被 mmm 个集合所包含，则其对左侧的贡献为 111 对右侧的贡献为 ∑i=1m(−1)i−1(mi)=−∑i=1m(−1)i(mi)=1−∑i=0m(−1)i(mi)=1−(1−1)m=1\\sum\\limits_{i=1}^m (−1)^{i−1}\\dbinom{m}{i}=−\\sum\\limits_{i=1}^m (−1)^i\\dbinom{m}{i}=1−\\sum\\limits_{i=0}^m (−1)^i \\dbinom{m}{i}=1−(1−1)^m=1i=1∑m​(−1)i−1(im​)=−i=1∑m​(−1)i(im​)=1−i=0∑m​(−1)i(im​)=1−(1−1)m=1 故左侧等于右侧 ，证毕 沿用刚刚多步容斥的公式，记 Ai‾\\overline{A_i}Ai​​ 表示 AiA_iAi​ 的补集，UUU 为全集，则将一般形式边形得： ∣A1‾∩A2‾∩⋯∩Am‾∣=∣U∣−∣A1∪A2∪⋯∪Am‾∣=∣U∣−∑1≤i≤m∣Ai∣+∑1≤i&lt;j≤m∣Ai∩Aj∣−⋯+(−1)m×∣A1∩A2∩⋯∩Am∣\\left|\\overline{A_1}\\cap \\overline{A_2} \\cap\\cdots\\cap \\overline{A_m}\\right|=|U|-\\left|\\overline{A_1\\cup A_2 \\cup\\cdots\\cup A_m}\\right|=|U|-\\sum\\limits_{1\\le i\\le m}|A_i|+\\sum\\limits_{1\\le i&lt;j\\le m}|A_i\\cap A_j|-\\cdots+(-1)^m\\times |A_1\\cap A_2\\cap\\cdots\\cap A_m| ∣∣​A1​​∩A2​​∩⋯∩Am​​∣∣​=∣U∣−∣∣​A1​∪A2​∪⋯∪Am​​∣∣​=∣U∣−1≤i≤m∑​∣Ai​∣+1≤i&lt;j≤m∑​∣Ai​∩Aj​∣−⋯+(−1)m×∣A1​∩A2​∩⋯∩Am​∣ 同时，由于补集的补集就是原集，因此又有： ∣A1∩A2∩⋯∩Am∣=∣U∣−∑1≤i≤m∣Ai‾∣+∑1≤i&lt;j≤m∣Ai‾∩Aj‾∣−⋯+(−1)m×∣A1‾∩A2‾∩⋯∩Am‾∣|A_1\\cap A_2\\cap\\cdots\\cap A_m|=|U|-\\sum\\limits_{1\\le i\\le m}\\left|\\overline{A_i}\\right|+\\sum\\limits_{1\\le i&lt;j\\le m}\\left|\\overline{A_i}\\cap\\overline{A_j}\\right|-\\cdots+(-1)^m\\times\\left|\\overline{A_1}\\cap\\overline{A_2}\\cap\\cdots\\cap\\overline{A_m}\\right| ∣A1​∩A2​∩⋯∩Am​∣=∣U∣−1≤i≤m∑​∣∣​Ai​​∣∣​+1≤i&lt;j≤m∑​∣∣​Ai​​∩Aj​​∣∣​−⋯+(−1)m×∣∣​A1​​∩A2​​∩⋯∩Am​​∣∣​ 考虑一种特殊情况：多个集合的交集大小只和集合的数目有关 记 f(n)f(n)f(n) 表示 nnn 个补集的交集的基数，g(n)g(n)g(n) 表示 nnn 个原集的交集的基数 形式化的表示： ∀1≤i1&lt;i2&lt;⋯&lt;in≤m ∣⋂j=1nAij‾∣=f(n),∣⋂j=1nAij∣=g(n)\\large \\forall _{1\\le i_1&lt;i_2&lt;\\cdots&lt;i_n\\le m}\\ \\normalsize\\left|\\bigcap\\limits_{j=1}^n \\overline{A_{i_j}}\\right|=f(n),\\left|\\bigcap\\limits_{j=1}^n A_{i_j}\\right|=g(n) ∀1≤i1​&lt;i2​&lt;⋯&lt;in​≤m​ ∣∣∣∣∣​j=1⋂n​Aij​​​∣∣∣∣∣​=f(n),∣∣∣∣∣​j=1⋂n​Aij​​∣∣∣∣∣​=g(n) 则上面两个公式可以分别表示为 f(n)=∑i=0n(−1)i(ni)g(i)g(n)=∑i=0n(−1)i(ni)f(i)f(n)=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g(i)\\\\g(n)=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f(i) f(n)=i=0∑n​(−1)i(in​)g(i)g(n)=i=0∑n​(−1)i(in​)f(i) 显然这两个公式是等价关系，更是相互推导的关系，于是我们得到了原 ①①① 式： fn=∑i=0n(−1)i(ni)gi⇔gn=∑i=0n(−1)i(ni)fif_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g_i\\Leftrightarrow g_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_i fn​=i=0∑n​(−1)i(in​)gi​⇔gn​=i=0∑n​(−1)i(in​)fi​ 方法 2 推式子！🤔 我们尝试由 fn=∑i=0n(−1)i(ni)gif_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g_ifn​=i=0∑n​(−1)i(in​)gi​ 推导至 gn=∑i=0n(−1)i(ni)fig_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_ign​=i=0∑n​(−1)i(in​)fi​（很明显这两个式子完全对称，证明了一个方向就可以证明充要性了）： ∵ fn=∑i=0n(−1)i(ni)gi∴∑i=0n(−1)i(ni)fi=∑i=0n(−1)i(ni)∑j=0i(−1)j(ij)gj=∑i=0n∑j=0i(−1)i+j(ni)(ij)gj=∑j=0ngj∑i=jn(−1)i+j(ni)(ij)=∑j=0ngj∑i=jn(−1)i+jn!i!(n−i)!×i!j!(i−j)!=∑j=0ngj∑i=jn(−1)i+jn!j!(n−j)!×(n−j)!(n−i)!(i−j)!=∑j=0ngj∑i=jn(−1)i+j(nj)(n−jn−i)=∑j=0n(nj)gj∑i=jn(−1)i+j(n−jn−i)又∵ ∀x∈Z+∑i=0x(−1)i(xi)=0∴ ∀j∈N∧j&lt;n∑i=jn(−1)i+j(n−jn−i)=0∴∑i=0n(−1)i(ni)fi=∑j=0n(nj)gj∑i=jn(−1)i+j(n−jn−i)=(nn)gn∑i=nn(−1)i+j(n−jn−i)=gn综上得到，fn=∑i=0n(−1)i(ni)gi⇔gn=∑i=0n(−1)i(ni)fi证毕.\\begin{aligned}\\\\ \\because &amp;\\ f_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g_i\\\\ \\therefore&amp;\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_i\\\\ =&amp;\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}\\sum\\limits_{j=0}^i(-1)^j\\dbinom{i}{j}g_j\\\\ =&amp;\\sum\\limits_{i=0}^n\\sum\\limits_{j=0}^i(-1)^{i+j}\\dbinom{n}{i}\\dbinom{i}{j}g_j\\\\ =&amp;\\sum\\limits_{j=0}^ng_j\\sum\\limits_{i=j}^n(-1)^{i+j}\\dbinom{n}{i}\\dbinom{i}{j}\\\\ =&amp;\\sum\\limits_{j=0}^ng_j\\sum\\limits_{i=j}^n(-1)^{i+j}\\dfrac{n!}{i!(n-i)!}\\times\\dfrac{i!}{j!(i-j)!}\\\\ =&amp;\\sum\\limits_{j=0}^ng_j\\sum\\limits_{i=j}^n(-1)^{i+j}\\dfrac{n!}{j!(n-j)!}\\times\\dfrac{(n-j)!}{(n-i)!(i-j)!}\\\\ =&amp;\\sum\\limits_{j=0}^ng_j\\sum\\limits_{i=j}^n(-1)^{i+j}\\dbinom{n}{j}\\dbinom{n-j}{n-i}\\\\ =&amp;\\sum\\limits_{j=0}^n\\dbinom{n}{j}g_j\\sum\\limits_{i=j}^n(-1)^{i+j}\\dbinom{n-j}{n-i}\\\\ 又&amp;\\because\\ \\large\\forall _{x\\in \\text{Z}^+} \\normalsize\\sum\\limits_{i=0}^{x}(-1)^i\\dbinom{x}{i}=0\\\\ \\therefore&amp;\\ \\large\\forall _{j\\in \\text{N}\\wedge j&lt;n} \\normalsize \\sum\\limits_{i=j}^n(-1)^{i+j}\\dbinom{n-j}{n-i}=0\\\\ \\therefore&amp;\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_i\\\\ =&amp;\\sum\\limits_{j=0}^n\\dbinom{n}{j}g_j\\sum\\limits_{i=j}^n(-1)^{i+j}\\dbinom{n-j}{n-i}\\\\ =&amp;\\dbinom{n}{n}g_n\\sum\\limits_{i=n}^n(-1)^{i+j}\\dbinom{n-j}{n-i}\\\\ =&amp;g_n\\\\ 综&amp;上得到，f_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g_i\\Leftrightarrow g_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_i\\\\ 证&amp;毕. \\end{aligned} ∵∴=======又∴∴===综证​ fn​=i=0∑n​(−1)i(in​)gi​i=0∑n​(−1)i(in​)fi​i=0∑n​(−1)i(in​)j=0∑i​(−1)j(ji​)gj​i=0∑n​j=0∑i​(−1)i+j(in​)(ji​)gj​j=0∑n​gj​i=j∑n​(−1)i+j(in​)(ji​)j=0∑n​gj​i=j∑n​(−1)i+ji!(n−i)!n!​×j!(i−j)!i!​j=0∑n​gj​i=j∑n​(−1)i+jj!(n−j)!n!​×(n−i)!(i−j)!(n−j)!​j=0∑n​gj​i=j∑n​(−1)i+j(jn​)(n−in−j​)j=0∑n​(jn​)gj​i=j∑n​(−1)i+j(n−in−j​)∵ ∀x∈Z+​i=0∑x​(−1)i(ix​)=0 ∀j∈N∧j&lt;n​i=j∑n​(−1)i+j(n−in−j​)=0i=0∑n​(−1)i(in​)fi​j=0∑n​(jn​)gj​i=j∑n​(−1)i+j(n−in−j​)(nn​)gn​i=n∑n​(−1)i+j(n−in−j​)gn​上得到，fn​=i=0∑n​(−1)i(in​)gi​⇔gn​=i=0∑n​(−1)i(in​)fi​毕.​ 其它 上面的两个方法只说明了 ①①① 式的证明，而事实上剩下的三个式子可以很容易从 ①①① 式边形得到，或也可用方法 2 类似的做法得到 扩展 二项式反演可以用 NTT 优化（还没学，学了马上写 Code Empty! ( 应用 套路 求“恰好 nnn 个”的答案困难，但求“选出 nnn 个”容易，然后通过“选出 nnn 个”再得到“钦定 nnn 个”（即选出 nnn 个之后，剩下的随便搞的方案数），而“钦定 nnn 个”与“恰好 nnn 个”刚好有二项式反演的形式（一般是 ②②② 或 ④④④ 式） 例题 BZOJ2839 - 集合计数 NOI Online R2 TG - T3 游戏 习题 BZOJ4710 / Luogu P5505 - 「JSOI2011」分特产 BZOJ3622 / Luogu P4859 - 已经没有什么好害怕的了 ","link":"https://imzzy1201.github.io/post/sdj9zeaTV/"},{"title":"NOI Online R2 TG 订正","content":" If you don't try, how can you know what it feels like to be desperate? 1. 概况 悲 T1 80pts 该死地用了某 __gcd。还好过了编，大概丢了 10 分？ T2 90pts 该死地被卡了常，丢 10 分。 T3 20pts 剩下的分我也不会。 总分 190pts，一般。 2. 题解 题解同期发布于我的 luogu 博客 T1 涂色游戏 题面（luogu） 前置知识 欧几里得算法 思路 因为 p1,p2≤109p_1,p_2\\le10^9p1​,p2​≤109，而我们有 102010^{20}1020 个格子， 所以 [p1,p2]≤p1p2&lt;1020[p_1,p_2]\\le p_1p_2&lt;10^{20}[p1​,p2​]≤p1​p2​&lt;1020，而每 [p1,p2][p_1,p_2][p1​,p2​] 个格子都是个循环节，即若第一个循环节范围内存在合法解，则后面的每个循环节都能按照此解来染色。 所以 102010^{20}1020 可以扔掉（在一个周期里存在合法解即可得无论多少格子都存在合法解）。 我们先令 f(a,b,c)f(a,b,c)f(a,b,c) 表示 p1=a,p2=b,k=cp_1=a,p_2=b,k=cp1​=a,p2​=b,k=c 对应的答案。 那么首先我们可以发现，若 p1=q1g, p2=q2gp_1=q_1g,\\ p_2=q_2gp1​=q1​g, p2​=q2​g，则 f(p1,p2,k)=f(q1,q2,k)f(p_1,p_2,k)=f(q_1,q_2,k)f(p1​,p2​,k)=f(q1​,q2​,k)。因为若 p1=q1g, p2=q2gp_1=q_1g,\\ p_2=q_2gp1​=q1​g, p2​=q2​g，则必定所有编号不为 ggg 的倍数的格子都不会被染色，可以忽略掉。 所以不妨令 q1≥q2, (q1,q2)=1q_1\\ge q_2,\\ (q_1,q_2)=1q1​≥q2​, (q1​,q2​)=1 求 f(q1,q2,k)f(q_1,q_2,k)f(q1​,q2​,k)。 因为 q1&gt;q2q_1&gt;q_2q1​&gt;q2​，所以首个格子填红色比填蓝色更优（蓝色方块密度更大）。 又因为 (q1,q2)=1(q_1,q_2)=1(q1​,q2​)=1， 所以根据裴蜀定理易得对于所有整数 nnn 都存在一个 mmm 使 q1∣m, q2∣m+nq_1|m,\\ q_2|m+nq1​∣m, q2​∣m+n。 即对于每个 nnn ，都能在格中找到编号 mmm ，使得 mmm 为红，m+nm+nm+n 为蓝。 所以我们现在只需要处理最坏情况，即 mmm 为红，m+1m+1m+1 为蓝。 观察下面几个例子： 我们可以推出，染 xxx 个蓝格子至少需要 q2(x−1)+1q_2(x-1)+1q2​(x−1)+1 个连续非红格子。 所以最坏情况下，最多有 ⌊q1−2q2⌋+1\\Large\\lfloor\\normalsize\\dfrac{q_1-2}{q_2}\\Large\\rfloor\\normalsize+1⌊q2​q1​−2​⌋+1 个连续的蓝格子。 注意：特判 k=1k=1k=1 的情况为 NO。 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=200004; const int mod=998244353,inf=1000000007; ll gcd(ll a,ll b) {return a==0?b:gcd(b%a,a);} // gcd, 最大公约数 signed main() { // freopen(&quot;color.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;color.out&quot;,&quot;w&quot;,stdout); ll T,p1,p2,k; fin&gt;&gt;T; while(T--) { fin&gt;&gt;p1&gt;&gt;p2&gt;&gt;k; if(k==1) {puts(&quot;NO&quot;); continue;} // 特判 ll g=gcd(p1,p2); p1/=g,p2/=g; if(p1&lt;p2) std::swap(p1,p2); puts(((p1-2LL)/p2+1&lt;k)?&quot;YES&quot;:&quot;NO&quot;); } return 0; } // ---------------------------- // by imzzy T2 子序列问题 题面（luogu） 前置知识 普通线段树 思路 考虑离散化 AAA 数组，以便于对每个位置的数记录一个 pre[i]pre[i]pre[i] 表示一个最大的数 jjj 满足 j&lt;ij&lt;ij&lt;i 且 Aj=AiA_j=A_iAj​=Ai​（若不存在这样的 jjj 则令其为 000）。 建立一颗线段树，支持一下操作：区间加 1，全局查询每个数的平方的和。具体实现方法见代码。 考虑递推计算以每个位置为结尾的区间的贡献； 即对于每个 iii，计算 gi=∑j=1if(j,i)2g_i=\\sum\\limits_{j=1}^i f(j,i)^2gi​=j=1∑i​f(j,i)2。 我们还可以得到，∀j≤pre[i+1]\\forall j\\le pre[i+1]∀j≤pre[i+1]，有 f(j,i)=f(j,i+1)f(j,i)=f(j,i+1)f(j,i)=f(j,i+1)，因为此区间 (j,i)(j,i)(j,i) 中必定包含 Apre[i+1]=Ai+1A_{pre[i+1]}=A_{i+1}Apre[i+1]​=Ai+1​，即第 i+1i+1i+1 个数对此区间的 fff 值无贡献。 同理得，∀j&gt;pre[i+1]\\forall j&gt;pre[i+1]∀j&gt;pre[i+1]，有 f(j,i)+1=f(j,i+1)f(j,i)+1=f(j,i+1)f(j,i)+1=f(j,i+1)。 记 hi,j=f(j,i)h_{i,j}=f(j,i)hi,j​=f(j,i) 那么我们维护 hih_ihi​ 这个序列，考虑到 hih_ihi​ 转移到 hi+1h_{i+1}hi+1​ 仅需将 (pre[i+1]+1,i+1)(pre[i+1]+1,i+1)(pre[i+1]+1,i+1) 这个区间的每个数加 111，求 gig_igi​ 则正是全局查询每个数的平方的和，所以正可以上述线段树来维护。 注意：跑 luogu 民间数据如果不开 O2，可能需要常数优化。 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=1000004; const int mod=1000000007,inf=1000000007; int a[maxn]; int val[maxn],last[maxn],pre[maxn]; class segment_tree{ #define mid ((l+r)&gt;&gt;1) private: int size,ql,qr; int sum[2097154],sqrsum[2097154],tag[2097154]; // 线段树维护 3 个值，sum 即区间和，sqrsum 即区间平方和，tag 即区间加的标记 inline void pushdown(int p,int l,int r) { if(tag[p]) { tag[p&lt;&lt;1]+=tag[p],tag[p&lt;&lt;1|1]+=tag[p]; sqrsum[p&lt;&lt;1]=(1LL*sqrsum[p&lt;&lt;1] + 1LL*(mid-l+1)*tag[p]%mod*tag[p]%mod + 2LL*tag[p]*sum[p&lt;&lt;1]%mod)%mod; sqrsum[p&lt;&lt;1|1]=(1LL*sqrsum[p&lt;&lt;1|1] + 1LL*(r-mid)*tag[p]%mod*tag[p]%mod + 2LL*tag[p]*sum[p&lt;&lt;1|1]%mod)%mod; // 考虑 (a+b)²=a²+b²+2ab，所以区间加 b 后，每个数的平方值+=b²+2ab // 即区间平方和 += 区间长度×b²+2×区间和×b sum[p&lt;&lt;1]=(1LL*sum[p&lt;&lt;1] + 1LL*tag[p]*(mid-l+1))%mod; sum[p&lt;&lt;1|1]=(1LL*sum[p&lt;&lt;1|1] + 1LL*tag[p]*(r-mid))%mod; tag[p]=0; } } void update(int p,int l,int r) { if(l&gt;=ql&amp;&amp;r&lt;=qr) { sqrsum[p]=(1LL*sqrsum[p]+sum[p]*2LL+(r-l+1))%mod; // 同理，(a+1)²=a²+2a+1 // 即区间平方和+=2×区间和+区间长度 if((sum[p]+=r-l+1)&gt;=mod) sum[p]-=mod; ++tag[p]; return; } pushdown(p,l,r); if(mid&gt;=ql) update(p&lt;&lt;1,l,mid); if(mid&lt;qr) update(p&lt;&lt;1|1,mid+1,r); if((sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1])&gt;=mod) sum[p]-=mod; if((sqrsum[p]=sqrsum[p&lt;&lt;1]+sqrsum[p&lt;&lt;1|1])&gt;=mod) sqrsum[p]-=mod; } public: inline void build(int siz) {size=siz;} inline void update(int l,int r) {ql=l,qr=r,update(1,1,size);} inline int query() {return sqrsum[1];} #undef mid }sgt; signed main() { // freopen(&quot;sequence.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;sequence.out&quot;,&quot;w&quot;,stdout); rgi n,cnt; fin&gt;&gt;n; for(rgi i=1;i&lt;=n;++i) fin&gt;&gt;a[i]; memcpy(val,a,sizeof(int)*(n+1)); std::sort(val+1,val+1+n),cnt=std::unique(val+1,val+1+n)-val; for(rgi i=1;i&lt;=n;++i) { a[i]=std::lower_bound(val+1,val+cnt,a[i])-val; pre[i]=last[a[i]],last[a[i]]=i; // last[i] 当前最大的 j 满足 A[j]=i } sgt.build(n); rgi ans=0; for(rgi i=1;i&lt;=n;++i) { sgt.update(pre[i]+1,i); if((ans+=sgt.query())&gt;=mod) ans-=mod; } fout&lt;&lt;ans; return 0; } // ---------------------------- // by imzzy T3 游戏 题面（luogu） 前置知识 二项式反演 树上背包* 思路 定义 g[i][j]g[i][j]g[i][j] 代表在以节点 iii 为根的子树中选出 jjj 对非平局的方案数，D[i]D[i]D[i] 代表 iii 为根的子树中，为节点 iii 的对手的节点的个数。 用样例举个栗子： 12348756 这里加粗的节点是小 A 的，其余为小 B 的。 ggg 的值如下表 节点编号 iii g[i][0]g[i][0]g[i][0] g[i][1]g[i][1]g[i][1] g[i][2]g[i][2]g[i][2] g[i][3]g[i][3]g[i][3] g[i][4]g[i][4]g[i][4] 1 1 7 11 4 0 2 1 1 0 0 0 3 1 2 0 0 0 4 1 0 0 0 0 5 1 0 0 0 0 6 1 0 0 0 0 7 1 0 0 0 0 8 1 0 0 0 0 考虑树上动态规划计算 ggg 的值： 对于 g[i][j]g[i][j]g[i][j] 的值，我们可以发现有 222 种来源情况：一种选中了节点 iii，一种没选中（显然啊）。 现在先定义一个 g′[i][j]g&#x27;[i][j]g′[i][j] 代表没选中节点 iii 时，以节点 iii 为根的子树中选出 jjj 对非平局的方案数。 下表为 g′g&#x27;g′ 的值表 节点编号 iii g′[i][0]g&#x27;[i][0]g′[i][0] g′[i][1]g&#x27;[i][1]g′[i][1] g′[i][2]g&#x27;[i][2]g′[i][2] g′[i][3]g&#x27;[i][3]g′[i][3] g′[i][4]g&#x27;[i][4]g′[i][4] 1 1 3 2 0 0 2 1 0 0 0 0 3 1 0 0 0 0 4 1 0 0 0 0 5 1 0 0 0 0 6 1 0 0 0 0 7 1 0 0 0 0 8 1 0 0 0 0 则很容易得到 g[i][j]=g′[i][j]+g′[i][j−1]×(D[i]−j+1)g[i][j]=g&#x27;[i][j]+g&#x27;[i][j-1]\\times (D[i]-j+1)g[i][j]=g′[i][j]+g′[i][j−1]×(D[i]−j+1)，因为不选中节点 iii 的方案数就是 g′[i][j]g&#x27;[i][j]g′[i][j]；而选中节点 iii 后必然有个对手的点与其凑成一非平局，这个对手的点共 D[i]−j+1D[i]-j+1D[i]−j+1 个可选。 现在考虑如何计算 g′[i][j]g&#x27;[i][j]g′[i][j]。易得，可从 iii 的各个子树中各选取几对非平局，使得选出来的总数为 jjj，即 g′[i][j]=∑k1+k2+⋯+ktg[soni,1][k1]×g[soni,2][k2]×⋯×g[soni,t][kt]g&#x27;[i][j]=\\sum_{k_1+k_2+\\cdots+k_t} g[son_{i,1}][k_1]\\times g[son_{i,2}][k_2]\\times\\cdots\\times g[son_{i,t}][k_t]g′[i][j]=∑k1​+k2​+⋯+kt​​g[soni,1​][k1​]×g[soni,2​][k2​]×⋯×g[soni,t​][kt​]（这里 soni,tson_{i,t}soni,t​ 表示 iii 的第 ttt 个子节点）。 发现这个复杂度很不正确，肯定过不了，所以要改进。 可以考虑这样：先把 iii 的所有子树砍掉，每次插入一颗子树，并计算其对 g′g&#x27;g′ 的新贡献。 则可以看出若定义 g′′[i][k]g&#x27;&#x27;[i][k]g′′[i][k] 表示以 iii 为根的子树中，前 kkk 个 iii 的子树对 g′g&#x27;g′ 的贡献， 那么 g′′[i][k][a+b]=∑g′′[i][k−1][a]×g′[soni,k][b]g&#x27;&#x27;[i][k][a+b]=\\sum g&#x27;&#x27;[i][k-1][a]\\times g&#x27;[son_{i,k}][b]g′′[i][k][a+b]=∑g′′[i][k−1][a]×g′[soni,k​][b]，即前 k−1k-1k−1 个子树中选 aaa 对，第 kkk 个子树中选 bbb 对。 这样算，乍一看是 O(n3)O(n^3)O(n3) 的，但其实不然。 如果 g′′[i][k−1][a]=0g&#x27;&#x27;[i][k-1][a]=0g′′[i][k−1][a]=0，则显然 g′′[i][k−1][a+1]=0g&#x27;&#x27;[i][k-1][a+1]=0g′′[i][k−1][a+1]=0；同理，若 g′[soni,k][b]=0g&#x27;[son_{i,k}][b]=0g′[soni,k​][b]=0，则显然 g′[soni,k][b+1]=0g&#x27;[son_{i,k}][b+1]=0g′[soni,k​][b+1]=0。 所以如果我们卡 a,ba,ba,b 的上界，使得参与计算的 g′′[i][k−1][a]×g′[soni,k][b]≠0g&#x27;&#x27;[i][k-1][a]\\times g&#x27;[son_{i,k}][b]\\neq 0g′′[i][k−1][a]×g′[soni,k​][b]​=0，则可证明复杂度为 O(n2)O(n^2)O(n2)。 这其实是一个树上背包，具体复杂度证明可以看 ouuan 的博客，这里不赘述。 说明：这里的 g′g&#x27;g′ 和 g′′g&#x27;&#x27;g′′ 仅为了方便描述，其实在代码中不需要专门存储。 至此，我们用 O(n2)O(n^2)O(n2) 的复杂度内得出了 ggg 的值表。 现在定义 f[i]f[i]f[i] 为正好 iii 对非平局的方案总数，h[i]h[i]h[i] 为钦定 iii 对非平局的方案总数。 这可能不太好理解，换句话说，就是 ∑任意选定 j 对非平局后剩下的节点自由配对的方案数\\sum_{任意选定\\ j\\ 对非平局后} 剩下的节点自由配对的方案数∑任意选定 j 对非平局后​剩下的节点自由配对的方案数。 样例中，h[0]=24, h[1]=42, h[2]=22, h[3]=4, h[4]=0h[0]=24,\\ h[1]=42,\\ h[2]=22,\\ h[3]=4,\\ h[4]=0h[0]=24, h[1]=42, h[2]=22, h[3]=4, h[4]=0。 很明显，根据定义，h[i]=g[1][i]×(m−i)!h[i]=g[1][i]\\times (m-i)!h[i]=g[1][i]×(m−i)!，因为 iii 对节点被选中后共可匹配 m−im-im−i 对局面。 你可能能感觉出 hhh 与 fff 间有某种关系，然而 hhh 与 fff 的关系并不只是简简单单的后缀和，考虑 h[i]h[i]h[i] 事实上将每个 jjj 对非平局的情况都算了 (ji)\\dbinom{j}{i}(ij​) 次，因为钦定其中每 iii 个节点时，都会算上一次这个状态； 即 h[i]=∑j=im(ji)f[j]h[i]=\\sum\\limits_{j=i}^m\\dbinom{j}{i}f[j]h[i]=j=i∑m​(ij​)f[j]。 我们便发现，这是一个 二项式反演 的形式， 可得 h[i]=∑j=im(ji)f[j]⇔f[i]=∑j=im(−1)j−i(ji)h[j]h[i]=\\sum\\limits_{j=i}^m\\dbinom{j}{i}f[j]\\Leftrightarrow f[i]=\\sum\\limits_{j=i}^m(-1)^{j-i}\\dbinom{j}{i}h[j]h[i]=j=i∑m​(ij​)f[j]⇔f[i]=j=i∑m​(−1)j−i(ij​)h[j]。 那么我们就可以根据这个公式，通过 hhh 值表在 O(n2)O(n^2)O(n2) 以内计算出 fff 值表了。 至此，我们在 O(n2)O(n^2)O(n2) 的复杂度内计算出了答案。 Code #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=5004; const int mod=998244353,inf=1000000007; int n,m; struct EDGE{int v,nxt;}e[maxn&lt;&lt;1]; int first[maxn],cnte; inline void addedge(int u,int v) { e[++cnte].v=v, e[cnte].nxt=first[u], first[u]=cnte; } char s[maxn]; int cnt[maxn][2],siz[maxn]; // cnt[i][j] 表示 i 的子树中，隶属于 j 的节点的个数；siz[i] 代表 i 的子树节点数 ll tmp[maxn],g[maxn][maxn],h[maxn]; void dfs(int fa,int now) { cnt[now][s[now]=='1']=siz[now]=1,g[now][0]=1; for(rgi i=first[now],to=e[i].v;i;i=e[i].nxt,to=e[i].v) { if(to==fa) continue; dfs(now,to); for(rgi j=0;j&lt;=siz[now]+siz[to];++j) tmp[j]=0; for(rgi j=0;g[now][j];++j) for(rgi k=0;g[to][k];++k) (tmp[j+k]+=g[now][j]*g[to][k])%=mod; for(rgi j=0;j&lt;=siz[now]+siz[to];++j) g[now][j]=tmp[j]; siz[now]+=siz[to],cnt[now][0]+=cnt[to][0],cnt[now][1]+=cnt[to][1]; } // 上面这段相当于计算 g' for(rgi i=m;i&gt;0;--i) (g[now][i]+=g[now][i-1]*std::max(0,cnt[now][s[now]=='0']-i+1))%=mod; // 上面这段则相当于计算真实的 g 值 } ll ans[maxn]; ll fact[maxn],invfact[maxn]; inline ll inv(ll a) { ll b=mod-2,res=1; while(b) {if(b&amp;1) (res*=a)%=mod; (a*=a)%=mod,b&gt;&gt;=1;} return res; } inline ll C(ll a,ll b) {return fact[a]*invfact[b]%mod*invfact[a-b]%mod;} inline void solve() { fact[0]=invfact[0]=1; for(rgi i=1;i&lt;=m;++i) fact[i]=fact[i-1]*i%mod,invfact[i]=inv(fact[i]); for(rgi i=0;i&lt;=m;++i) h[i]=g[1][i]*fact[m-i]%mod/*,fout&lt;&lt;h[i]&lt;&lt;' '*/; for(rgi i=0;i&lt;=m;++i) for(rgi j=i;j&lt;=m;++j) (ans[i]+=h[j]*(((j-i)&amp;1)?(mod-1):1)%mod*C(j,i))%=mod; } signed main() { // freopen(&quot;match.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;match.out&quot;,&quot;w&quot;,stdout); int x,y; fin&gt;&gt;n; scanf(&quot;%s&quot;,s+1); for(rgi i=1;i&lt;n;++i) fin&gt;&gt;x&gt;&gt;y,addedge(x,y),addedge(y,x); m=n&gt;&gt;1,dfs(0,1),solve(); // for(rgi i=1;i&lt;=n;++i) // { // for(rgi j=0;j&lt;=m;++j) fout&lt;&lt;g[i][j]&lt;&lt;' '; // fout&lt;&lt;endl; // } for(rgi i=0;i&lt;=m;++i) fout&lt;&lt;ans[i]&lt;&lt;endl; return 0; } // ---------------------------- // by imzzy 3. 总结 Never use __gcd! ","link":"https://imzzy1201.github.io/post/-5pBeF37l/"},{"title":"备忘录","content":" The more you learn, the more you know; the more you know, the more you forget; the more you forget, the less you know. So why bother to learn? 板子 #include&lt;bits/stdc++.h&gt; #define rgi register int #define ll long long class fastin{ private: int _ch,_f; public: inline fastin&amp; operator&gt;&gt;(char&amp;c) {c=getchar(); return *this;} template&lt;typename _Tp&gt; inline fastin&amp; operator&gt;&gt;(_Tp&amp;_x){ _x=0; while(!isdigit(_ch)) _f|=(_ch==45),_ch=getchar(); while(isdigit(_ch)) _x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0); return *this;} fastin() {_ch=_f=0;} }fin; class fastout{ #define endl '\\n' private: int _num[32],_head; public: inline fastout&amp; operator&lt;&lt;(char c) {putchar(c); return *this;} template&lt;typename _Tp&gt; inline fastout&amp; operator&lt;&lt;(_Tp _x){ _Tp _k; if(_x==0) {putchar('0'); return *this;} if(_x&lt;0) putchar('-'),_x=-_x; while(_x&gt;0) _k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0) putchar(_num[_head]),--_head; return *this;} fastout() {_head=0;} }fout; // ---------------------------- // #define int ll // using namespace std; const int maxn=200004; const int mod=998244353,inf=1000000007; signed main() { return 0; } // ---------------------------- // by imzzy 数学相关 排列组合 Pnm=Anm=n!(n−m)!Cnm=(nm)=Pnmm!=n!m!(n−m)!\\large \\begin{aligned} \\\\ &amp; P_n^m=A_n^m=\\dfrac{n!}{(n-m)!} \\\\ &amp; C_n^m=\\dbinom{n}{m}=\\dfrac{P_n^m}{m!}=\\dfrac{n!}{m!(n-m)!} \\\\ \\end{aligned} ​Pnm​=Anm​=(n−m)!n!​Cnm​=(mn​)=m!Pnm​​=m!(n−m)!n!​​ exgcd void exgcd(ll a,ll b,ll &amp;x,ll &amp;y,ll &amp;d) {if(!b) x=1,y=0,d=a; else exgcd(b,a%b,y,x,d),y-=x*(a/b);} Miller-Rabin 素性检测 来自 Wikipedia 的数据 if n &lt; 2,047, it is enough to test a = 2; if n &lt; 1,373,653, it is enough to test a = 2 and 3; if n &lt; 9,080,191, it is enough to test a = 31 and 73; if n &lt; 25,326,001, it is enough to test a = 2, 3, and 5; if n &lt; 3,215,031,751, it is enough to test a = 2, 3, 5, and 7; if n &lt; 4,759,123,141, it is enough to test a = 2, 7, and 61; if n &lt; 1,122,004,669,633, it is enough to test a = 2, 13, 23, and 1662803; if n &lt; 2,152,302,898,747, it is enough to test a = 2, 3, 5, 7, and 11; if n &lt; 3,474,749,660,383, it is enough to test a = 2, 3, 5, 7, 11, and 13; if n &lt; 341,550,071,728,321, it is enough to test a = 2, 3, 5, 7, 11, 13, and 17. if n &lt; 3,825,123,056,546,413,051, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, and 23. if n &lt; 18,446,744,073,709,551,616 = 264, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37. if n &lt; 318,665,857,834,031,151,167,461, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37. if n &lt; 3,317,044,064,679,887,385,961,981, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, and 41. inline ll mulmod(ll a,ll b,ll m) { ll res=0; while(b) { if(b&amp;1) if((res+=a)&gt;=m) res-=m; if((a+=a)&gt;=m) a-=m; b&gt;&gt;=1; } return res; } inline ll powmod(ll a,ll b,ll m) { ll res=1; while(b) { if(b&amp;1) res=mulmod(res,a,m); a=mulmod(a,a,m); b&gt;&gt;=1; } return res; } inline bool Miller_Rabin(ll n) // true 为质数，false 为非质数 { if(n&lt;2) return false; const ll tests[]={2,3,5,7,11,13,17,19,23,29,31,37}; ll tmp=n-1,d,a,t; while(!(tmp&amp;1)) tmp&gt;&gt;=1; for(rgi i=0;i&lt;12&amp;&amp;tests[i]&lt;n;++i) { a=tests[i],t=powmod(a,d=tmp,n); while(d!=n-1&amp;&amp;t!=1&amp;&amp;t!=n-1) t=mulmod(t,t,n),d&lt;&lt;=1; if(t!=n-1&amp;&amp;!(t==1&amp;&amp;d&amp;1)) return false; } return true; } 二项式反演 四种常用形式： 从 000 到 nnn ： fn=∑i=0n(−1)i(ni)gi⇔gn=∑i=0n(−1)i(ni)fi亦作 fn=∑i=0n(ni)gi⇔gn=∑i=0n(−1)n−i(ni)fi\\large \\begin{aligned}\\\\ f_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=0}^n(-1)^i\\dbinom{n}{i}f_i \\\\ \\normalsize\\textsf{亦作}\\ \\large f_n=\\sum\\limits_{i=0}^n\\dbinom{n}{i}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=0}^n (-1)^{n-i} \\dbinom{n}{i} f_i \\\\ \\end{aligned} fn​=i=0∑n​(−1)i(in​)gi​亦作 fn​=i=0∑n​(in​)gi​​⇔gn​=i=0∑n​(−1)i(in​)fi​⇔gn​=i=0∑n​(−1)n−i(in​)fi​​ 从 nnn 到 mmm ： fn=∑i=nm(−1)i(in)gi⇔gn=∑i=nm(−1)i(in)fi亦作 fn=∑i=nm(in)gi⇔gn=∑i=nm(−1)i−n(in)fi\\large \\begin{aligned}\\\\ f_n=\\sum\\limits_{i=n}^m(-1)^i\\dbinom{i}{n}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=n}^m(-1)^i\\dbinom{i}{n}f_i \\\\ \\normalsize\\textsf{亦作}\\ \\large f_n=\\sum\\limits_{i=n}^m\\dbinom{i}{n}g_i&amp;\\Leftrightarrow g_n=\\sum\\limits_{i=n}^m (-1)^{i-n} \\dbinom{i}{n} f_i \\\\ \\end{aligned} fn​=i=n∑m​(−1)i(ni​)gi​亦作 fn​=i=n∑m​(ni​)gi​​⇔gn​=i=n∑m​(−1)i(ni​)fi​⇔gn​=i=n∑m​(−1)i−n(ni​)fi​​ 莫比乌斯反演 莫比乌斯函数 μ(d)={1d=1(−1)kd=p1p2p3...pk, pi为 d 的质因子且两两互素0otherwise\\mu(d)= \\begin{cases} 1 &amp; d=1\\\\ (-1)^k &amp; d=p_1p_2p_3...p_k,\\ p_i \\text{为 } d \\text{ 的质因子且两两互素} \\\\ 0 &amp; \\text{otherwise} \\end{cases} μ(d)=⎩⎪⎨⎪⎧​1(−1)k0​d=1d=p1​p2​p3​...pk​, pi​为 d 的质因子且两两互素otherwise​ 性质： 1.∑d∣nμ(d)={1n=10n&gt;12.∑d∣nμ(d)d=ϕ(n)n\\begin{aligned}\\\\ 1. &amp;\\sum_{d|n}\\mu(d)= \\begin{cases} 1&amp;n=1\\\\ 0&amp;n&gt;1 \\end{cases}\\\\ 2. &amp;\\sum_{d|n}\\frac{\\mu(d)}{d}=\\frac{\\phi(n)}{n} \\end{aligned}\\\\ 1.2.​d∣n∑​μ(d)={10​n=1n&gt;1​d∣n∑​dμ(d)​=nϕ(n)​​ 莫比乌斯反演 F(n)=∑d∣nf(d)⇔f(d)=∑d∣nμ(d)F(nd)\\large F(n)=\\sum_{d|n}f(d)\\Leftrightarrow f(d)=\\sum_{d|n}\\mu(d)F\\left(\\frac{n}{d}\\right) F(n)=d∣n∑​f(d)⇔f(d)=d∣n∑​μ(d)F(dn​) 图论 网络瘤 Dinic 原理我想是不会忘了的。 MCMF 我们写的方法基本都是指数级别的，很容易被叉，参考 ouuan's Blog 下面是我巨大的 Dinic 当前弧优化 + 史上最慢指数级 MCMF 板子： namespace FLOWS{ struct EDGE{int to,w,nxt;} e[maxm&lt;&lt;1|1]; int n,cnte,first[maxn+1]; inline void init(int _n) {n=_n,cnte=-1,memset(first,-1,(n+1)*sizeof(int));} inline void addedge(int from,int to,int w) {e[++cnte]=(EDGE){to,w,first[from]},first[from]=cnte;} } namespace MAXFLOW{ using namespace FLOWS; int n,s,t,ans; inline void init(int _n,int _s,int _t) {s=_s,t=_t,ans=0,n=_n,FLOWS::init(n);} inline void addedge(int from,int to,int w) { if(debug&amp;1) std::cout&lt;&lt;&quot;MAXFLOW::addedge &quot;&lt;&lt;from&lt;&lt;' '&lt;&lt;to&lt;&lt;' '&lt;&lt;w&lt;&lt;endl; FLOWS::addedge(from,to,w),FLOWS::addedge(to,from,0); } int dep[maxn+1],cur[maxn+1],q[maxn+1]; inline bool bfs() { memcpy(cur,first,(n+1)*sizeof(int)); memset(dep,0,(n+1)*sizeof(int)); rgi l=1,r=1,u,i; q[1]=s,dep[s]=1; while(l&lt;=r) for(u=q[l++],i=first[u];~i;i=e[i].nxt) if(e[i].w&gt;0&amp;&amp;!dep[e[i].to]) dep[e[i].to]=dep[u]+1,q[++r]=e[i].to; return dep[t]; } int dfs(int now,int flow) { if(now==t) return flow; int res=0; for(rgi i=cur[now],to;~i;i=e[i].nxt) { cur[now]=i,to=e[i].to; if(dep[to]==dep[now]+1&amp;&amp;e[i].w&gt;0) if((res=dfs(to,std::min(flow,e[i].w)))&gt;0) {e[i].w-=res,e[i^1].w+=res; return res;} } return 0; } inline int work() { int now; while(bfs()) while((now=dfs(s,inf))&gt;0) { ans+=now; if((debug&gt;&gt;1)&amp;1) std::cout&lt;&lt;&quot;MAXFLOW::work &quot;&lt;&lt;ans&lt;&lt;'\\n'; } return ans; } } namespace MCMF{ using namespace FLOWS; int n,s,t,maxflow,mincost; int cost[maxm&lt;&lt;1|1]; inline void init(int _n,int _s,int _t) {n=_n,s=_s,t=_t,maxflow=mincost=0,FLOWS::init(n);} inline void addedge(int from,int to,int w,int c) { if(debug&amp;1) std::cout&lt;&lt;&quot;MCMF::addedge &quot;&lt;&lt;from&lt;&lt;' '&lt;&lt;to&lt;&lt;' '&lt;&lt;w&lt;&lt;' '&lt;&lt;c&lt;&lt;'\\n'; FLOWS::addedge(from,to,w),cost[cnte]=c; FLOWS::addedge(to,from,0),cost[cnte]=-c; } int dist[maxn+1],flow[maxn+1]; int pre[maxn+1]; bool vis[maxn+1]; std::queue&lt;int&gt; q; inline bool SPFA() { memset(vis,0,(n+1)*sizeof(bool)); memset(flow,0,(n+1)*sizeof(int)); memset(dist,0x3f,(n+1)*sizeof(int)); rgi u,i,to; q.push(s),dist[s]=0,flow[s]=inf; while(!q.empty()) { vis[u=q.front()]=0; q.pop(); for(i=first[u];~i;i=e[i].nxt) { to=e[i].to; if(e[i].w&gt;0&amp;&amp;dist[to]&gt;dist[u]+cost[i]) { dist[to]=dist[u]+cost[i],pre[to]=i; flow[to]=std::min(flow[u],e[i].w); if(!vis[to]) q.push(to),vis[to]=1; } } } return dist[t]&lt;inf; } inline std::pair&lt;int,int&gt; work() { rgi i; while(SPFA()) { maxflow+=flow[t],mincost+=flow[t]*dist[t]; for(i=t;i!=s;i=e[pre[i]^1].to) e[pre[i]].w-=flow[t],e[pre[i]^1].w+=flow[t]; if((debug&gt;&gt;1)&amp;1) std::cout&lt;&lt;&quot;MCMF::work &quot;&lt;&lt;maxflow&lt;&lt;' '&lt;&lt;mincost&lt;&lt;'\\n'; } return std::make_pair(maxflow,mincost); } } DS 普通平衡树 SPLAY 我的未压行的板子 class SPLAY { private: int sum,root,inf_; struct NODE{int son[2],fa,val,cnt,siz;} node[maxn]; inline bool son(int x) {return x==node[node[x].fa].son[1];} inline void connect(int x,int f,int d) {node[x].fa=f,node[f].son[d]=x;} inline int make(int f,int v) { node[++sum].fa=f; node[sum].val=v; node[sum].son[0]=node[sum].son[1]=0; node[sum].siz=node[sum].cnt=1; return sum; } inline void update(int x) {node[x].siz=node[node[x].son[0]].siz+node[node[x].son[1]].siz+node[x].cnt;} inline void rotate(int x) { int f=node[x].fa,g=node[f].fa; int s1=son(x),s2=son(f); connect(x,g,s2); connect(node[x].son[s1^1],f,s1); connect(f,x,s1^1); update(f),update(x); } inline void splay(int x,int tmp) { int t=node[tmp].fa; while(node[x].fa!=t) { int f=node[x].fa,g=node[f].fa; if(t!=g) son(f)^son(x)?rotate(x):rotate(f); rotate(x); } if(root==tmp) root=x; } inline int near(int x,int d) { int p=root; int res=d?-inf_:inf_; while(p) { if((d?x:node[p].val)&lt;(d?node[p].val:x)) res=node[p].val,p=node[p].son[d^1]; else p=node[p].son[d]; } return res; } public: SPLAY() {sum=root=0,inf_=1000000007;} inline int find(int x) { int p=root; while(p) { if(node[p].val==x) {splay(p,root);return p;} p=node[p].son[x&gt;node[p].val]; } return 0; } inline void ins(int x) { int p=root; if(!p) {root=make(0,x);return;} while(true) { ++node[p].siz; if(node[p].val==x) { ++node[p].cnt; splay(p,root); return; } int nxt=(x&gt;node[p].val); if(!node[p].son[nxt]) { node[p].son[nxt]=make(p,x); splay(node[p].son[nxt],root); return; } p=node[p].son[nxt]; } } inline void del(int x) { int p=find(x); if(!p) return; if(node[p].cnt&gt;1) {--node[p].cnt,--node[p].siz;return;} if(!node[p].son[0]||!node[p].son[1]) { root=node[p].son[0]+node[p].son[1]; node[root].fa=0; return; } int tmp=node[p].son[1]; while(node[tmp].son[0]) tmp=node[tmp].son[0]; splay(tmp,root); connect(node[p].son[0],tmp,0); node[tmp].fa=0; update(tmp); } inline int rank(int x) { int p=root,res=0; while(p) { if(node[p].val==x) { res+=node[node[p].son[0]].siz+1; splay(p,root); return res; } if(x&lt;node[p].val) p=node[p].son[0]; else { res+=node[node[p].son[0]].siz+node[p].cnt; p=node[p].son[1]; } } return 0; } inline int kth(int x) { int p=root; while(p) { int d=node[p].siz-node[node[p].son[1]].siz; if(node[node[p].son[0]].siz&lt;x&amp;&amp;d&gt;=x) {splay(p,root);return node[p].val;} if(d&gt;x) p=node[p].son[0]; else x-=d,p=node[p].son[1]; } return x&gt;0?inf_:-inf_; } inline int pre(int x) {return near(x,0);} inline int suc(int x) {return near(x,1);} inline void debug() { cout&lt;&lt;endl&lt;&lt;&quot;--------splay--------&quot;&lt;&lt;endl; cout&lt;&lt;sum&lt;&lt;&quot; &quot;&lt;&lt;root&lt;&lt;endl; for(rgi i=1;i&lt;=sum;++i) cout&lt;&lt;node[i].son[0]&lt;&lt;&quot; &quot;&lt;&lt;node[i].son[1]&lt;&lt;&quot; &quot;&lt;&lt;node[i].fa&lt;&lt;&quot; &quot;&lt;&lt;node[i].val&lt;&lt;&quot; &quot;&lt;&lt;node[i].cnt&lt;&lt;&quot; &quot;&lt;&lt;node[i].siz&lt;&lt;endl; cout&lt;&lt;&quot;---------------------&quot;&lt;&lt;endl; } }splay; treap 我的未压行的板子 class treap { #define lson_ son[0] #define rson_ son[1] private: int inf_; int sum,root; struct NODE {int son[2],val,pri,cnt,siz;} node[maxn]; inline void pushup(int p) {node[p].siz=node[node[p].lson_].siz+node[node[p].rson_].siz+node[p].cnt;} inline void rotate(int &amp; p,int d) { int k=node[p].son[d^1]; node[p].son[d^1]=node[k].son[d]; node[k].son[d]=p; pushup(p),pushup(k); p=k; } void ins_(int &amp; p,int k) { if(!p) { p=++sum; node[p].siz=node[p].cnt=1; node[p].val=k,node[p].pri=rand(); node[p].lson_=node[p].rson_=0; return; } if(node[p].val==k) { ++node[p].cnt,++node[p].siz; return; } int d=(k&gt;node[p].val); ins_(node[p].son[d],k); if(node[p].pri&lt;node[node[p].son[d]].pri) rotate(p,d^1); pushup(p); } void del_(int &amp; p,int k) { if(!p) return; if(k!=node[p].val) del_(node[p].son[k&gt;node[p].val],k); else if(!node[p].lson_&amp;&amp;!node[p].rson_) { --node[p].cnt,--node[p].siz; if(node[p].cnt==0)p=0; } else if(node[p].lson_^node[p].rson_) { int d=(node[p].rson_==0); rotate(p,d); del_(node[p].son[d],k); } else if(node[p].lson_&amp;&amp;node[p].rson_) { int d=(node[node[p].lson_].pri&gt;node[node[p].rson_].pri); rotate(p,d); del_(node[p].son[d],k); } pushup(p); } inline int near(int k,int d) { int x=root; int tmp=-inf_; while(x) { if((d?k:node[x].val)&lt;(d?node[x].val:k)) tmp=node[x].val,x=node[x].son[d^1]; else x=node[x].son[d]; } return tmp; } public: inline void debug() { cout&lt;&lt;endl&lt;&lt;&quot;--------treap--------&quot;&lt;&lt;endl; cout&lt;&lt;sum&lt;&lt;&quot; &quot;&lt;&lt;root&lt;&lt;endl; for(rgi i=1;i&lt;=sum;++i) cout&lt;&lt;node[i].son[0]&lt;&lt;&quot; &quot;&lt;&lt;node[i].son[1]&lt;&lt;&quot; &quot;&lt;&lt;node[i].val&lt;&lt;&quot; &quot;&lt;&lt;node[i].pri&lt;&lt;&quot; &quot;&lt;&lt;node[i].cnt&lt;&lt;&quot; &quot;&lt;&lt;node[i].siz&lt;&lt;endl; cout&lt;&lt;&quot;---------------------&quot;&lt;&lt;endl; } inline void ins(int k) {ins_(root,k);} inline void del(int k) {del_(root,k);} inline int rank(int k) { int x=root; int tmp=0; while(x) { if(k==node[x].val) return tmp+node[node[x].lson_].siz+1; else if(k&lt;node[x].val) x=node[x].lson_; else tmp+=node[node[x].lson_].siz+node[x].cnt,x=node[x].rson_; } return tmp; } inline int kth(int k) { int x=root; while(x) { if(node[node[x].lson_].siz&lt;k&amp;&amp;node[node[x].lson_].siz+node[x].cnt&gt;=k) return node[x].val; if(node[node[x].lson_].siz&gt;=k) x=node[x].lson_; else k-=node[node[x].lson_].siz+node[x].cnt,x=node[x].rson_; } return 0; } inline int pre(int k) {return near(k,0);} inline int suc(int k) {return near(k,1);} treap() {inf_=1000000007,sum=root=0;} #undef lson_ #undef rson_ }trp; ","link":"https://imzzy1201.github.io/post/1y_vHr2_t/"},{"title":"友情链接","content":" Some people come to you in your life, to make you know that you are such an easy target. dalao 们 Clever_Jimmy\\textsf\\color{black}C\\color{red}lever\\_JimmyClever_Jimmy FZzzz\\textsf\\color{black}F\\color{red}ZzzzFZzzz xiong_6\\textsf\\color{black}x\\color{red}iong\\_6xiong_6 lzc\\textsf\\color{black}l\\color{red}zclzc xzx\\textsf\\color{black}x\\color{red}zxxzx Polaris_Dane\\textsf\\color{black}P\\color{red}olaris\\_DanePolaris_Dane 好用的网址们 OEIS（数列找规律） NumberEmpire（数字性质） WolframAlpha（数学工具） LaTeX\\LaTeXLATE​X 索引 tool.lu（在线工具） Chrome Extension CRX Downloader（Chrome Web Store 插件下载器） ","link":"https://imzzy1201.github.io/post/friends/"},{"title":"博客搭建说明","content":" All roads lead to Rome. Yet, some people have been living there ever since they were born. Gridea 👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ 强烈安利 Gridea！确实十分好用，原因如下： 首先，Gridea 开源、安全、免费、无捆绑广告，有清新的图形界面和简易的安装方式，部署到 GitHub Pages 上只须要进行简单的几步配置，比起 Hexo 等的命令行操作及繁杂的安装过程和部署过程，显得容易上手许多。在部署上，Gridea 仅须用户 GitHub 账户及密码，即可部署至 GitHub Pages，比配置 SSH 更为方便；仅须简单的几步就可以完成 Gitalk 的配置；可实现随身携带、编辑和同步 Gridea 还自带 markdown + tex 公式编辑器，无须使用其它编辑器即可完成大部分编辑工作 Gridea 亦可跨平台操作，对于我这种双系统党较为便捷 Gridea 的缺点： 目前现有的主题还是较少，与 Hexo 和 Jekyll 等还是不可同日而语 同步的速度有待提高 主题 本站采用了 ITJoker233 大牛从 Hexo 中移植到 Gridea 的 Chic 主题，做了一些小修改 博客搭建教程 注册一个 GitHub 账号（不详讲） 来到 New Repository 界面 在 &quot;Repository name&quot; 下填写 [你的用户名].github.io 比如我的用户名为 imzzy1201，则我应填写 imzzy1201.github.io 注意这讲成为将来你的 GitHub Pages 的地址 然后 &quot;Create repository&quot; 现在转到 https://github.com/[你的用户名]/[你的用户名].github.io/settings 下拉到 &quot;GitHub Pages&quot; 一栏，你会看到： ✔️ Your site is published at https://[你的用户名].github.io/\\small\\textsf{\\color{green}Your site is published at \\color{blue}https://[你的用户名].github.io/}Your site is published at https://[你的用户名].github.io/ 这就说明你的 &quot;GitHub Pages&quot; 设置成功了。 现在下载某 Gridea 并安装（安装默认选项安装即可） 打开它，再页面左下角有个选项栏，里面可以自己设置语言和站点源文件位置，建议记下来你的站点源文件位置，以便折腾主题之类的东西 现在开始配置同步服务 在域名中选择 &quot;https://&quot;，然后填入 [你的用户名].github.io/ 仓库名称填 [你的用户名].github.io 分支填 master 仓库用户名填 [你的用户名] 邮箱填你用来注册 GitHub 的那个邮箱 令牌填你 GitHub 的密码 保存后，点检测远程连接，如果上方出现： ✔️ 远程连接成功 则说明你的博客已经配置好了 现在点左下角的 &quot;同步&quot;，等待它提示 &quot;同步成功&quot; 后，再在浏览器打开 [你的用户名].github.io，就会发现 Gridea 预置的主题和文章已经上传到了你的 GitHub Pages 上了 如果需要改主题可以将你的主题放在 [你的站点源文件路径]/themes/，然后重启 Gridea 即可在“主题”一栏找到你的新主题了。 ","link":"https://imzzy1201.github.io/post/myblog/"},{"title":"板子","content":" 一个压行狂人是从不受限于码风的 #include&lt;bits/stdc++.h&gt; namespace P_TEMPLATE{ #define endl '\\n' #define ccf std::cout&lt;&lt;&quot;f**k&quot;&lt;&lt;endl #define rgi register int #define ll long long class fastin{private:int _ch,_f; public:inline fastin&amp;operator&gt;&gt;(char&amp;c){c=getchar();return*this;} template&lt;typename _Tp&gt;inline fastin&amp;operator&gt;&gt;(_Tp&amp;_x){ _x=0;while(!isdigit(_ch))_f|=(_ch==45),_ch=getchar(); while(isdigit(_ch))_x=(_x&lt;&lt;1)+(_x&lt;&lt;3)+(_ch^48),_ch=getchar(); _f&amp;&amp;(_x=-_x,_f=0);return*this;}fastin(){_ch=_f=0;} }fin;class fastout{private:int _num[32],_head; public:inline fastout&amp;operator&lt;&lt;(char c){putchar(c);return*this;} template&lt;typename _Tp&gt; inline fastout&amp;operator&lt;&lt;(_Tp _x){ _Tp _k;if(_x==0){putchar('0');return *this;}if(_x&lt;0)putchar('-'),_x=-_x; while(_x&gt;0)_k=_x/10,++_head,_num[_head]=(_x-(_k&lt;&lt;1)-(_k&lt;&lt;3))^48,_x=_k; while(_head&gt;0)putchar(_num[_head]),--_head;return*this;}fastout(){_head=0;} }fout;inline void P_INIT(){ #ifdef D_STDOUT_UNBUFFERED setbuf(stdout,NULL); #endif }}using namespace P_TEMPLATE; // ---------------------------- // #define int ll // using namespace std; const int maxn=1000004; const int mod=1000000007,inf=1201201201; signed main() {P_INIT(); return 0; } // ---------------------------- // by imzzy ","link":"https://imzzy1201.github.io/post/bNfwKgoRt/"}]}